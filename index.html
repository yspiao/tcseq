<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title>TCSEQ - v9.7 FIXED</title>
  <style>
    /* === THEME: STRICT NOIR === */
    :root{
      --bg: #000000;           
      --panel: #0a0a0a;        
      --panel-border: #1a1a1a;  
      
      --text-main: #d0d0d0;       
      --text-dim: #555555;
      
      /* ACCENTS */
      --deep-blue: #0033ff;    
      --deep-blue-glow: rgba(0, 51, 255, 0.6);
      --playhead: #ffffff;
      --playhead-glow: #00ffff;
      
      --rad: 0px; 
      
      --font-ui: "Inter", -apple-system, BlinkMacSystemFont, Roboto, sans-serif;
      --font-mono: "JetBrains Mono", "Menlo", "Consolas", monospace;
    }

    *{ box-sizing:border-box; -webkit-font-smoothing: antialiased; }
    
    html,body{ height:100%; overflow: hidden; background: #000; }
    
    body{
      margin:0;
      background: var(--bg);
      color: var(--text-main);
      font-family: var(--font-ui);
      font-size: 11px;
      display: flex;
      flex-direction: column;
    }

    /* --- CONTROLS --- */
    button, select, input {
      font-family: var(--font-mono);
      font-weight: 500;
      font-size: 10px;
      text-transform: uppercase;
      border: 1px solid var(--panel-border);
      outline: none;
      cursor: pointer;
      border-radius: var(--rad);
      background: #000;
      color: #777;
      transition: all 0.1s;
    }

    button { padding: 6px 12px; }
    button:hover { border-color: #444; color: #fff; background: #111; }
    button:active { background: #fff; color: #000; }
    
    button.primary { background: #151515; color: #fff; border-color: #333; }
    button.primary:hover { background: #eee; color: #000; }
    
    button.ghost { background: transparent; border-color: transparent; color: var(--text-dim); }
    button.ghost:hover { color: #fff; background: #111; border-color: #222; }

    select, input[type="text"], input[type="number"] {
      background: #000; border: 1px solid var(--panel-border); color: #fff; padding: 4px 8px;
    }
    select:hover, input:hover { border-color: #555; }
    input[type="number"]::-webkit-inner-spin-button { opacity: 1; }

    input[type=number]::-webkit-inner-spin-button, 
    input[type=number]::-webkit-outer-spin-button { 
      -webkit-appearance: none; 
      margin: 0; 
    }
    input[type=number] { -moz-appearance: textfield; }

    input[type=range] {
      -webkit-appearance: none; background: transparent; margin: 0; height: 16px; border: none;
    }
    input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 1px; background: #333; }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none; height: 8px; width: 4px; background: #fff; margin-top: -3.5px; border: none;
    }

    /* --- LAYOUT --- */
    .app { display: flex; flex-direction: column; height: 100%; padding: 0; }

    .topbar {
      display: flex; align-items: center; justify-content: space-between;
      padding: 0 16px; background: #000; border-bottom: 1px solid var(--panel-border);
      height: 44px; flex-shrink: 0;
    }

    @keyframes deep-breathe {
      0% { color: #1a237e; text-shadow: 0 0 0px rgba(0,0,0,0); opacity: 0.5; }
      50% { color: #2962ff; text-shadow: 0 0 15px var(--deep-blue-glow); opacity: 1; }
      100% { color: #1a237e; text-shadow: 0 0 0px rgba(0,0,0,0); opacity: 0.5; }
    }

    .brand {
      font-family: var(--font-mono); font-weight: 800; font-size: 16px; letter-spacing: 2px;
      margin-right: auto; user-select: none; animation: deep-breathe 4s ease-in-out infinite; 
    }

    .cluster { display: flex; gap: -1px; } 
    .cluster button { border-right: none; }
    .cluster button:last-child { border-right: 1px solid var(--panel-border); }

    .main { flex: 1; display: grid; grid-template-columns: 260px 1fr; min-height: 0; overflow: hidden; position: relative; }

    /* Left Sidebar */
    .left-col {
      display: flex; flex-direction: column; border-right: 1px solid var(--panel-border);
      background: #050505; height: 100%; min-height: 0; overflow: hidden;
      z-index: 50;
    }

    .panel-header {
      padding: 10px 12px; font-size: 9px; font-weight: 600; color: #444;
      display: flex; justify-content: space-between; align-items: center;
      text-transform: uppercase; letter-spacing: 1px;
      border-bottom: 1px solid var(--panel-border); background: #020202; flex-shrink: 0;
    }

    .left-controls {
      padding: 8px; border-bottom: 1px solid var(--panel-border);
      display: flex; flex-direction: column; gap: 6px; flex-shrink: 0;
    }
    
    .filelist {
      flex: 1; overflow-y: auto; font-family: var(--font-mono); font-size: 10px; background: #000; min-height: 0; 
    }
    .filelist::-webkit-scrollbar { width: 6px; }
    .filelist::-webkit-scrollbar-track { background: #000; }
    .filelist::-webkit-scrollbar-thumb { background: #333; border: 1px solid #000; }

    .fileitem {
      padding: 6px 12px; display: flex; justify-content: space-between; align-items: center;
      cursor: pointer; color: #555; border-bottom: 1px solid #0a0a0a;
    }
    .fileitem:hover { background: #111; color: #fff; }
    .fileitem.selected { background: #222; color: #fff; }
    .fname { white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width: 140px; }
    
    .cat {
      font-size: 9px; color: #333; border: 1px solid #222;
      padding: 1px 4px; min-width: 36px; text-align: center;
    }
    .cat:hover { border-color: #fff; color: #fff; }

    .hint-bar {
      padding: 8px 12px; border-top: 1px solid var(--panel-border);
      font-size: 9px; color: #333; background: #020202; flex-shrink: 0;
    }
    .kbd { color: #fff; font-family: var(--font-mono); font-weight: bold; }

    /* Right Area */
    .right-col {
      display: flex; flex-direction: column; background: #000; height: 100%; min-height: 0; overflow: hidden;
    }

    /* 1. PARAMETER BAR */
    .param-bar {
      display: flex; border-bottom: 1px solid var(--panel-border); background: #030303;
      height: 60px; flex-shrink: 0; overflow-x: auto;
    }
    .param-slot {
      display: flex; flex-direction: column; justify-content: center;
      padding: 0 16px; border-right: 1px solid var(--panel-border); gap: 4px; min-width: 100px;
    }
    .param-label { font-size: 9px; color: #444; font-weight: bold; letter-spacing: 0.5px; }
    
    /* 2. SEQUENCER GRID */
    .sequencer-area {
      flex: 1; display: flex; flex-direction: column; overflow: hidden; position: relative;
    }
    
    .gridwrap {
      flex: 1; padding: 20px; overflow-y: auto; background: #000;
      display: flex; flex-direction: column; justify-content: center; 
    }

    .grid {
      display: grid; 
      gap: 1px; align-items: center; width: 100%; margin: 0 auto;
    }
    .steps-header {
      display: grid; gap: 1px; margin-bottom: 4px;
      padding-bottom: 6px; margin-bottom: 2px;
      font-family: var(--font-mono); font-size: 9px; color: #555; text-align: center;
      width: 100%; margin: 0 auto 4px auto;
      align-items: end;
    }
    
    .grid > div, .steps-header > div { min-width: 0; overflow: hidden; }

    .rlabel {
      font-size: 10px; font-weight: 500; color: #666; letter-spacing: 1px;
      text-align: right; padding-right: 10px; font-family: var(--font-mono);
    }

    .step {
      aspect-ratio: 1; background: #080808; border: 1px solid #151515; cursor: pointer; position: relative;
      width: 100%; 
    }
    .step:hover { border-color: #444; background: #111; }
    
    .step[data-state="1"] { background: #222; }
    .step[data-state="2"] { background: #666; }
    .step[data-state="3"] { 
      background: #b0b0b0; border-color: #e0e0e0; box-shadow: inset 0 0 4px rgba(255,255,255,0.3); 
    }

    /* === MODIFIED: DIMMED PLAYHEAD CURSOR === */
    .step.playing { 
        background: rgba(255,255,255,0.15) !important; 
        border-color: rgba(255,255,255,0.4) !important;
        box-shadow: none !important;
        z-index: 99;
    }

    /* 3. VISUALS */
    .vis-container {
      height: 240px; flex-shrink: 0;
      border-top: 1px solid var(--panel-border); background: #000; position: relative;
    }
    .vis-main { width: 100%; height: 100%; background: #000; position: relative; }
    
    canvas { width: 100%; height: 100%; display: block; }

    /* Status Bar */
    .status {
      display: flex; justify-content: space-between; align-items: center;
      padding: 0 16px; height: 28px; background: #000;
      border-top: 1px solid var(--panel-border);
      font-family: var(--font-mono); font-size: 9px; color: #333; flex-shrink: 0;
    }

    /* Mobile specific elements */
    #mobileLibBtn { display: none; }
    #closeLibBtn { display: none; }
    #desktopExportBtn { display: block; }

    .toast {
      position: fixed; bottom: 40px; right: 20px;
      background: #fff; border: 1px solid #fff; color: #000;
      padding: 8px 12px; font-size: 11px; display: none; z-index: 200;
      font-family: var(--font-mono); font-weight: bold;
    }
    
    .modal-backdrop {
      background: rgba(0,0,0,0.95); backdrop-filter: blur(2px);
      position: fixed; inset: 0; display: none;
      align-items: center; justify-content: center; z-index: 99;
    }
    .modal {
      background: #050505; border: 1px solid #333; padding: 24px; width: 400px; color: #ccc;
    }
    .modal h3 { color: #fff; margin-top: 0; font-size: 12px; letter-spacing: 2px; text-transform: uppercase; border-bottom: 1px solid #222; padding-bottom: 10px; margin-bottom: 20px; font-family: var(--font-mono);}

    @media (max-width: 900px) {
      html, body { height: 100%; overflow: hidden; position: fixed; width: 100%; }
      .app { height: 100%; position: relative; }

      .topbar { padding: 0 8px; }
      .brand { font-size: 14px; margin-right: 0; }
      
      #mobileLibBtn { display: block; margin-right: 8px; border-right: 1px solid #333; }
      #closeLibBtn { display: block; }
      #desktopExportBtn { display: block; } 

      .cluster { gap: -1px; }
      .cluster button { padding: 8px 10px; font-size: 10px; }

      .main { 
        display: flex; flex-direction: column; height: 100%; position: relative; overflow: hidden;
      }
      
      .left-col { 
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(10,10,10,0.98); 
        border-right: none;
        transform: translateX(-100%); 
        transition: transform 0.25s cubic-bezier(0.16, 1, 0.3, 1);
        z-index: 9999; 
      }
      .left-col.active { transform: translateX(0); }
      
      .right-col { 
        width: 100%; height: 100%; display: flex; flex-direction: column; 
      }
      
      .param-bar { 
        height: 50px; overflow-x: auto; -webkit-overflow-scrolling: touch; 
        border-bottom: 1px solid #222; flex-shrink: 0;
      }
      
      .sequencer-area { 
        flex: 1; min-height: 0; display: flex; flex-direction: column;
      }
      .gridwrap { padding: 5px; justify-content: center; }
      .grid { max-width: 100%; }

      .vis-container { 
        height: 140px; border-top: 1px solid #222; flex-shrink: 0; 
      }
      
      .vis-main { border-right: none; }
      button { padding: 6px 8px; font-size: 9px; }
    }
  </style>
</head>
<body>
<div class="app" id="app">
  <div class="topbar">
    <div class="cluster">
        <button id="mobileLibBtn" class="primary">LIB</button>
        <div class="brand" style="margin-left: 10px;">TCSEQ</div>
    </div>
    <div class="cluster">
      <button id="btnPlay" class="primary">PLAY</button>
      <button id="btnStop">STOP</button>
      <button id="btnRecord">REC</button>
      <button id="btnExport" id="desktopExportBtn">EXP</button>
    </div>
  </div>

  <div class="main">
    <div class="left-col" id="leftCol">
      <div class="panel-header">
        <span>DATA POOL</span>
        <button id="closeLibBtn" class="ghost" style="border:none;">CLOSE [X]</button>
        <span id="audioState" style="color:#333; display:none;">OFFLINE</span>
      </div>

      <div class="left-controls">
        <div class="control-row" style="display:flex; gap:0px">
          <button id="btnLoadFile" style="flex:1; border-right:none;">FILES</button>
          <button id="btnLoadFolder" style="flex:1;">FOLDER</button>
          <button id="btnClear" class="ghost" style="width:30px; margin-left:4px;">X</button>
        </div>
        <button id="btnAnalyzeGenerate" style="width:100%; color:#fff; border-color:#333;">AUTO-GENERATE</button>
        <div style="display:flex; gap:4px; margin-top:4px;">
           <button id="btnRecord" style="flex:1;">REC</button>
        </div>
      </div>

      <div class="filelist" id="fileList" tabindex="0"></div>
    </div>

    <div class="right-col">
      
      <div class="param-bar">
        <div class="param-slot">
          <span class="param-label">STEPS</span>
          <input id="meterMode" type="number" min="1" max="128" value="16" style="width:40px;">
        </div>
        <div class="param-slot">
          <span class="param-label">ALGO</span>
          <select id="styleMode">
            <option value="techno">TECHNO</option>
            <option value="industrial">INDUST</option>
            <option value="dub">DUB</option>
            <option value="dnb">DNB</option>
            <option value="breakbeat">BREAK</option>
            <option value="house">HOUSE</option>
            <option value="trap">TRAP</option>
          </select>
        </div>
        <div class="param-slot">
          <span class="param-label">DENS</span>
          <input id="density" type="range" min="0" max="400" value="58">
        </div>
        <div class="param-slot">
          <span class="param-label">FX</span>
          <select id="glitchStyle">
            <option value="stutter">STUTT</option>
            <option value="bitcrush">CRUSH</option>
            <option value="tear">TEAR</option>
            <option value="distort">DIST</option>
            <option value="filter">FILT</option>
          </select>
        </div>
        <div class="param-slot">
          <span class="param-label">AMT</span>
          <input id="glitchAmt" type="range" min="0" max="100" value="0">
        </div>
        <div class="param-slot">
          <span class="param-label">BPM</span>
          <div style="display:flex; align-items:center; gap:4px;">
            <input id="bpmBar" type="range" min="60" max="220" value="135">
            <span id="bpmVal" style="font-family:var(--font-mono); color:#fff; font-size:9px;">135</span>
          </div>
        </div>
        <div class="param-slot" style="flex:1; flex-direction:row; align-items:center; justify-content:flex-end; gap:8px;">
           <button id="btnRandom" class="primary">GENERATE</button>
           <button id="btnResetGrid" class="ghost">CLR</button>
        </div>
      </div>

      <div class="sequencer-area">
        <div class="gridwrap" id="gridWrap">
          <div class="steps-header" id="stepsHeader"></div>
          <div class="grid" id="grid"></div>
        </div>
      </div>

      <div class="vis-container">
        <div class="vis-main">
          <canvas id="cvMain"></canvas>
        </div>
      </div>
    </div>
  </div>

  <div class="status">
    <div id="statusLeft">SYSTEM STANDBY</div>
    <div class="right" id="statusRight">v9.7 FIXED</div>
  </div>
</div>

<div class="modal-backdrop" id="modalBackdrop">
  <div class="modal">
    <h3 id="exportTitle">EXPORT SEQUENCE</h3>
    <div style="display:grid; grid-template-columns:1fr 1fr; gap:20px; margin-bottom:20px;">
       <div class="mini"><label>FORMAT</label><select id="exportFormat" style="width:100%"><option value="wav">WAV</option><option value="webm">WEBM</option></select></div>
       <div class="mini"><label>BARS</label><select id="exportBars" style="width:100%"><option value="1">1</option><option value="2">2</option><option value="4" selected>4</option></select></div>
    </div>
    <div style="display:flex; justify-content:flex-end; gap:10px;">
      <button id="btnExportCancel" class="ghost">CANCEL</button>
      <button id="btnExportGo" class="primary">PROCESS</button>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<input id="fileInputFile" type="file" multiple style="display:none"/>
<input id="fileInputFolder" type="file" webkitdirectory directory multiple style="display:none"/>

<script>
(() => {
  "use strict";

  const $ = (id) => document.getElementById(id);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const now = () => performance.now();
  const toast = (msg, ms=2600) => {
    const t = $("toast"); t.textContent = msg; t.style.display = "block";
    clearTimeout(toast._tm); toast._tm = setTimeout(()=>{ t.style.display="none"; }, ms);
  };

  // 添加移动设备检测函数
  const isMobile = () => {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
           (window.innerWidth <= 900);
  };

  const __glitchParams = { style: "stutter", amt: 0.0 };
  const __glitchStyleEl = $("glitchStyle");
  const __glitchAmtEl = $("glitchAmt");

  if (__glitchStyleEl){
    __glitchStyleEl.addEventListener("change", e=>{ __glitchParams.style = String(e.target.value || "stutter"); });
  }
  
  if (__glitchAmtEl){
    const __applyGlitchAmt = () => {
      let v = Number(__glitchAmtEl.value); if (v <= 1) v = 0;
      if (v !== Number(__glitchAmtEl.value)) __glitchAmtEl.value = String(v);
      const amt = clamp(v/100, 0, 1);
      __glitchParams.amt = amt;
      if (audioCtx && state._glitch && state._glitch.wet && state._glitch.dry){
        const t = audioCtx.currentTime;
        const mix = Math.pow(amt, 0.85);
        state._glitch.wet.gain.setTargetAtTime(mix, t, 0.01);
        state._glitch.dry.gain.setTargetAtTime(1-mix, t, 0.01);
        if (state._glitch.filter) state._glitch.filter.frequency.setTargetAtTime(200 + amt*3000, t, 0.1);
      }
    };
    __glitchAmtEl.addEventListener("input", __applyGlitchAmt);
    __glitchAmtEl.addEventListener("change", __applyGlitchAmt);
    setTimeout(__applyGlitchAmt, 0);
  }

  function mulberry32(seed){
    let t = seed >>> 0;
    return function(){
      t += 0x6D2B79F5;
      let x = Math.imul(t ^ (t >>> 15), 1 | t);
      x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
      return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
    };
  }

  const CATS = ["KICK","SNARE","HAT","CLAP","BASS","PERC/FX"];
  const ROWS = CATS.length;

  const state = {
    files: [],
    selectedFileIndex: -1,
    steps: 16, 
    pattern: [], 
    bpm: 135, 
    isPlaying: false,
    scheduler: null,
    nextNoteTime: 0,
    currentStep: 0,
    lookaheadMs: 25,
    scheduleAhead: 0.12,
    activeSources: new Set(),
    previewSource: null,
    previewGain: null,
    record: { rec: null, chunks: [], isRecording: false, streamDest: null },
    visual: { lastStep: -1 }
  };

  function initPattern(newSteps) {
    if (!newSteps) newSteps = 16;
    const oldP = state.pattern;
    state.steps = newSteps;
    state.pattern = Array.from({length: ROWS}, (_, r) => {
        const row = new Array(state.steps).fill(0);
        if(oldP && oldP[r]){
            for(let i=0; i<Math.min(oldP[r].length, state.steps); i++) row[i] = oldP[r][i];
        }
        return row;
    });
  }
  initPattern(16);

  let audioCtx = null;
  let master = null;
  let analyser = null;
  let glitchNode = null;

  function createGlitchNode(ctx){
    const node = ctx.createScriptProcessor(2048, 2, 2);
    let hold = 0, holdL = 0, holdR = 0, bits = 10, stutter = 0, tearFrames = 0;
    let ph=0; 
    node.onaudioprocess = (e) => {
      const in0 = e.inputBuffer.getChannelData(0);
      const in1 = e.inputBuffer.numberOfChannels > 1 ? e.inputBuffer.getChannelData(1) : in0;
      const out0 = e.outputBuffer.getChannelData(0);
      const out1 = e.outputBuffer.getChannelData(1);

      const amt = (__glitchParams?.amt ?? 0);
      const style = String(__glitchParams?.style ?? "stutter");

      if (amt === 0){ out0.set(in0); out1.set(in1); return; }
      const a = Math.pow(amt, 0.55);
      const pStutter = (style==="stutter" ? (0.00025 + 0.0022*a) : 0);
      const crush = (style==="bitcrush" ? 1 : 0);
      const tear = (style==="tear" ? 1 : 0);
      const dist = (style==="distort" ? 1 : 0);
      const ring = (style==="ring" ? 1 : 0);
      const ds = 1 + Math.floor(11*a);
      const N = in0.length;
      if (stutter <= 0 && pStutter > 0 && Math.random() < (pStutter * N)) stutter = (10 + ((Math.random()*(40 + 260*a))|0));
      if (tearFrames <= 0 && tear && Math.random() < 0.001*a*N) tearFrames = 6 + ((Math.random()*(18 + 70*a))|0);
      if(crush) bits = clamp(16 - 12*a, 2, 16);
      for (let i=0;i<N;i++){
        let l = in0[i], r = in1[i];
        if (tearFrames > 0){ l = -l; r = -r; tearFrames--; }
        if (dist) { l = Math.tanh(l * (1+a*10)); r = Math.tanh(r * (1+a*10)); }
        if (ring) { ph += 0.1 + a*0.5; const rm = Math.sin(ph); l *= rm; r *= rm; }
        if (crush){ 
            if ((i % ds) === 0){ holdL = l; holdR = r; } 
            l = holdL; r = holdR; const q = 1 << bits; l = Math.round(l*q)/q; r = Math.round(r*q)/q;
        } 
        else if (stutter > 0){ l = holdL; r = holdR; stutter--; } 
        else { holdL = l; holdR = r; }
        out0[i] = l; out1[i] = r;
      }
    };
    return node;
  }

  async function ensureAudio(){
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)({latencyHint:"interactive"});
    master = audioCtx.createGain();
    master.gain.value = 0.85;
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 1024;
    glitchNode = createGlitchNode(audioCtx);
    const dry = audioCtx.createGain();
    const wet = audioCtx.createGain();
    const filter = audioCtx.createBiquadFilter();
    filter.type = "lowpass"; filter.frequency.value = 20000; filter.Q.value = 5;
    const a0 = (__glitchParams?.amt ?? 0);
    const m0 = Math.pow(a0, 0.85);
    wet.gain.value = m0; dry.gain.value = 1 - m0;
    master.connect(dry); dry.connect(analyser);
    master.connect(filter); filter.connect(glitchNode); glitchNode.connect(wet); wet.connect(analyser);
    analyser.connect(audioCtx.destination);
    state._glitch = {dry, wet, filter};
    $("audioState").textContent = "AUDIO: ACTIVE";
    audioCtx.onstatechange = () => $("audioState").textContent = "AUDIO: " + audioCtx.state.toUpperCase();
  }

  function killAllSources(){
    for (const s of state.activeSources){ try{ s.stop(); }catch(e){} }
    state.activeSources.clear();
    if (state.previewSource){ try{ state.previewSource.stop(); }catch(e){} state.previewSource = null; }
  }
  function safeStopSource(src, when=0){ try{ src.stop(when); }catch(e){} }

  async function decodeFile(file){
    await ensureAudio();
    const arr = await file.arrayBuffer();
    return await audioCtx.decodeAudioData(arr.slice(0));
  }

  function extractFeatures(buffer){
    const ch = buffer.getChannelData(0);
    const sr = buffer.sampleRate;
    const N = ch.length;
    let zc = 0; for (let i=1;i<N;i++) if ((ch[i-1] >= 0 && ch[i] < 0) || (ch[i-1] < 0 && ch[i] >= 0)) zc++;
    const zcr = zc / N;
    const fftN = Math.min(4096, N);
    const frame = new Float32Array(fftN);
    for (let i=0;i<fftN;i++) frame[i] = ch[i] * (0.5 - 0.5*Math.cos(2*Math.PI*i/(fftN-1)));
    let centroid = 0, magSum = 0;
    for (let k=0;k<128;k++){
      let re=0, im=0;
      for (let n=0;n<fftN;n++){
        const ang = 2*Math.PI*k*n/fftN;
        re += frame[n]*Math.cos(ang); im -= frame[n]*Math.sin(ang);
      }
      const mag = Math.sqrt(re*re + im*im);
      centroid += (k*sr/fftN) * mag; magSum += mag;
    }
    const centroidNorm = (magSum > 1e-9 ? centroid / magSum : 0) / (sr/2);
    let lp=0, lowE=0, totE=0;
    const a = Math.exp(-2*Math.PI*160/sr);
    for (let i=0;i<Math.min(N, sr*0.5);i++){
      lp = a*lp + (1-a)*ch[i]; lowE += lp*lp; totE += ch[i]*ch[i];
    }
    const lowRatio = totE>1e-9 ? lowE/totE : 0;
    const atkWin = Math.min(N, Math.floor(sr*0.2));
    let peak=0; for (let i=0;i<atkWin;i++) peak = Math.max(peak, Math.abs(ch[i]));
    const thresh = peak*0.6;
    let atkSamp = atkWin;
    for (let i=0;i<atkWin;i++) if (Math.abs(ch[i])>=thresh){ atkSamp=i; break; }
    const attack = atkSamp/sr;
    return { zcr, centroidNorm, lowRatio, attack };
  }

  function classify(features){
    const {zcr, centroidNorm, lowRatio, attack} = features;
    if (centroidNorm > 0.55 && zcr > 0.12 && lowRatio < 0.35) return "HAT";
    if (lowRatio > 0.68 && centroidNorm < 0.30) return (attack < 0.015 ? "KICK" : "BASS");
    if (centroidNorm > 0.30 && centroidNorm < 0.55){
      if (zcr > 0.10 && attack < 0.02) return "CLAP";
      return "SNARE";
    }
    return "PERC/FX";
  }

  const fileListEl = $("fileList");
  function setStatus(left, right=""){ $("statusLeft").textContent=left.toUpperCase(); $("statusRight").textContent=right.toUpperCase(); }

  function renderFileList(){
    fileListEl.innerHTML = "";
    state.files.forEach((f, idx) => {
      const row = document.createElement("div");
      row.className = "fileitem" + (idx === state.selectedFileIndex ? " selected" : "");
      const name = document.createElement("div");
      name.className = "fname"; name.textContent = f.name;
      name.addEventListener("click", async (ev) => {
        ev.stopPropagation(); state.selectedFileIndex = idx; renderFileList(); await previewFile(idx);
      });
      const cat = document.createElement("div");
      cat.className = "cat"; cat.textContent = f.category || "—";
      cat.addEventListener("click", (ev) => {
        ev.stopPropagation(); state.selectedFileIndex = idx; renderFileList(); openCatMenu(cat, idx);
      });
      row.appendChild(name); row.appendChild(cat);
      fileListEl.appendChild(row);
    });
    if (!state.files.length) fileListEl.innerHTML = "<div style='padding:10px; color:#333'>[EMPTY]</div>";
  }

  function openCatMenu(anchorEl, fileIdx){
    const f = state.files[fileIdx];
    const sel = document.createElement("select");
    CATS.forEach(c => {
      const op = document.createElement("option"); op.value = c; op.textContent = c;
      if (c === f.category) op.selected = true; sel.appendChild(op);
    });
    anchorEl.parentElement.replaceChild(sel, anchorEl);
    sel.focus();
    const commit = () => { f.category = sel.value; f.override = true; renderFileList(); updateVisualDistribution(); };
    sel.addEventListener("change", commit);
    sel.addEventListener("blur", commit, {once:true});
  }

  const gridEl = $("grid");
  const headerEl = $("stepsHeader");

  function renderHeader(){
    headerEl.innerHTML = "";
    gridEl.style.gridTemplateColumns = `70px repeat(${state.steps}, 1fr)`;
    headerEl.style.gridTemplateColumns = `70px repeat(${state.steps}, 1fr)`;
    const h0 = document.createElement("div"); h0.textContent = "TRK"; h0.className="rlabel"; headerEl.appendChild(h0);
    for (let i=0;i<state.steps;i++){
      const h = document.createElement("div"); h.textContent = String(i+1); headerEl.appendChild(h);
    }
  }

  function renderGrid(){
    gridEl.innerHTML = "";
    for (let r=0;r<ROWS;r++){
      const lab = document.createElement("div");
      lab.className = "rlabel"; lab.textContent = CATS[r];
      gridEl.appendChild(lab);
      for (let s=0;s<state.steps;s++){
        const cell = document.createElement("div");
        cell.className = "step";
        cell.dataset.r = String(r); cell.dataset.s = String(s);
        cell.dataset.state = String(state.pattern[r][s]);
        cell.addEventListener("click", (ev) => {
          ev.preventDefault();
          const next = (state.pattern[r][s] + 1) % 4;
          state.pattern[r][s] = next;
          cell.dataset.state = String(next);
          updateVisualDistribution();
        });
        gridEl.appendChild(cell);
      }
    }
  }

  function setPlayingColumn(step){
    const cells = gridEl.querySelectorAll(".step");
    cells.forEach(c => c.classList.remove("playing"));
    for (const c of cells) if (Number(c.dataset.s) === step) c.classList.add("playing");
  }

  async function previewFile(idx){
    const f = state.files[idx]; if (!f) return;
    await ensureAudio(); if (audioCtx.state !== "running") await audioCtx.resume();
    if (state.previewSource) safeStopSource(state.previewSource);
    if (!f.buffer){ setStatus("DECODING…"); f.buffer = await decodeFile(f.file); }
    const src = audioCtx.createBufferSource(); src.buffer = f.buffer;
    const g = audioCtx.createGain(); const t0 = audioCtx.currentTime;
    g.gain.setValueAtTime(0.0001, t0); g.gain.linearRampToValueAtTime(0.65, t0+0.01);
    g.gain.linearRampToValueAtTime(0.0001, t0+Math.min(0.35, f.buffer.duration));
    src.connect(g); g.connect(master); src.start();
    state.previewSource = src; state.previewGain = g;
    setStatus("PREVIEW", f.name);
    src.onended = () => { if (state.previewSource === src) state.previewSource = null; };
  }

  function velocityFromState(st){
    if (st === 1) return 0.25; if (st === 2) return 0.55; if (st === 3) return 0.85; return 0.0;
  }

  function pickBufferForCat(cat){
    const list = state.files.filter(f => f.buffer && f.category === cat);
    if (list.length) return list[Math.floor(Math.random()*list.length)].buffer;
    const any = state.files.filter(f => f.buffer);
    if (any.length) return any[Math.floor(Math.random()*any.length)].buffer;
    return null;
  }

  function scheduleStep(step, time){
    for (let r=0;r<ROWS;r++){
      const st = state.pattern[r][step];
      if (st === 0) continue;
      const buf = pickBufferForCat(CATS[r]);
      if (!buf) continue;
      const src = audioCtx.createBufferSource(); src.buffer = buf;
      const g = audioCtx.createGain();
      const vel = velocityFromState(st);
      g.gain.setValueAtTime(0.0001, time);
      g.gain.linearRampToValueAtTime(vel, time + 0.006);
      g.gain.linearRampToValueAtTime(0.0001, time + Math.min(0.18, buf.duration));
      src.connect(g); g.connect(master); src.start(time);
      safeStopSource(src, time + buf.duration + 0.05);
      state.activeSources.add(src); src.onended = () => state.activeSources.delete(src);
    }
  }

  function schedulerTick(){
    if (!state.isPlaying) return;
    const ct = audioCtx.currentTime;
    while (state.nextNoteTime < ct + state.scheduleAhead){
      if (state.currentStep >= state.steps) state.currentStep = 0;
      scheduleStep(state.currentStep, state.nextNoteTime);
      state.nextNoteTime += (60/state.bpm)/4;
      state.currentStep = (state.currentStep + 1) % state.steps;
    }
  }

  function startTransport(){
    if (state.isPlaying) return;
    state.isPlaying = true; state.currentStep = 0;
    state.nextNoteTime = audioCtx.currentTime + 0.05;
    state.scheduler = setInterval(schedulerTick, state.lookaheadMs);
    setStatus("PLAYING");
  }

  function stopTransport(){
    state.isPlaying = false;
    if (state.scheduler){ clearInterval(state.scheduler); state.scheduler = null; }
    killAllSources(); setPlayingColumn(-1); setStatus("STOPPED");
  }

  function resetPattern(){
    for (let r=0;r<ROWS;r++) for (let s=0;s<state.steps;s++) state.pattern[r][s] = 0;
    renderGrid(); updateVisualDistribution();
  }

  function setHit(cat, step, st=2){
    const r = CATS.indexOf(cat); if (r < 0) return;
    const safeStep = ((step%state.steps)+state.steps)%state.steps;
    state.pattern[r][safeStep] = st;
  }

  function generateBase(style, rng){
    resetPattern();
    if (style === "techno"){
      for(let i=0;i<state.steps;i+=4) setHit("KICK", i, 3);
      for(let i=2;i<state.steps;i+=4) setHit("BASS", i, 2);
      for(let i=0;i<state.steps;i++) if(i%2!==0) setHit("HAT", i, 2);
    } else if (style === "industrial"){
      setHit("KICK",0,3); setHit("KICK",2,2); setHit("KICK",8,3);
      for(let i=0;i<state.steps;i++) if(rng()<0.4) setHit("PERC/FX", i, 2);
      setHit("SNARE", 4, 3); setHit("SNARE", 12, 3);
    } else if (style === "dub"){
      setHit("KICK",0,2); setHit("KICK",4,1); setHit("KICK",8,2);
      setHit("BASS",2,2); setHit("BASS",10,2); setHit("BASS",14,1);
      for(let i=0;i<state.steps;i++) if(i%2!==0 && rng()<0.6) setHit("HAT", i, 1);
    } else if (style === "minimal"){
      setHit("KICK",0,3); setHit("KICK",8,2); setHit("SNARE",4,3); setHit("SNARE",12,3);
      for(let i=0;i<state.steps;i+=2) setHit("HAT", i, 1);
    } else if (style === "dnb"){
      setHit("KICK",0,3); setHit("KICK",10,2); setHit("SNARE",4,3); setHit("SNARE",12,3);
      for(let i=0;i<state.steps;i+=2) setHit("HAT", i, 2);
    } else if (style === "breakbeat"){
      setHit("KICK",0,3); setHit("KICK",7,2); setHit("KICK",10,2); setHit("SNARE",4,3); setHit("SNARE",12,3);
      setHit("HAT",2,1); setHit("HAT",6,1); setHit("HAT",8,1); setHit("HAT",14,1);
    } else if (style === "house"){
      for(let i=0;i<state.steps;i+=4) setHit("KICK", i, 3);
      for(let i=2;i<state.steps;i+=4) setHit("HAT", i, 2);
      setHit("CLAP",4,2); setHit("CLAP",12,2);
    } else if (style === "trap"){
      setHit("KICK",0,3); setHit("KICK",10,2); setHit("SNARE",8,3);
      for(let i=0;i<state.steps;i++) setHit("HAT",i, (rng()<0.3?3:1));
    }
  }

  function applyDensity(density, rng, style){
    const d = density / 100;
    for (let r=0;r<ROWS;r++){
      for (let s=0;s<state.steps;s++){
        if (state.pattern[r][s] && rng() > (0.4 + 0.6*d)) state.pattern[r][s] = 0;
      }
    }
    const addP = Math.max(0, d - 0.45) * 1.5;
    for (let s=0;s<state.steps;s++){
      if (rng() < addP){
        if (rng() < 0.6) state.pattern[CATS.indexOf("HAT")][s] = Math.max(state.pattern[CATS.indexOf("HAT")][s], rng()<0.3?3:2);
        else {
          const rr = rng() < 0.5 ? "PERC/FX" : "CLAP";
          state.pattern[CATS.indexOf(rr)][s] = Math.max(state.pattern[CATS.indexOf(rr)][s], 1);
        }
      }
    }
  }

  function randomizePattern(){
    const style = $("styleMode").value;
    const density = Number($("density").value);
    const rng = mulberry32((Date.now() ^ Math.random()*1e9) >>> 0);
    generateBase(style, rng);
    applyDensity(density, rng, style);
    renderGrid(); updateVisualDistribution();
    setStatus("GENERATED: " + style.toUpperCase());
  }

  const cvMain=$("cvMain"), ctx=cvMain.getContext("2d");
  let geoRot=0, geoTime=now(), ampSmooth=0, beatSmooth=0;
  
  const vis = { pulse:0, energy:0, trig:{KICK:0,SNARE:0,HAT:0,CLAP:0,BASS:0,"PERC/FX":0}, colorHue: 220 };
  function lerp(a,b,t){ return a + (b-a)*t; }
  function approach(c,t,d){ return c<t ? Math.min(t,c+d) : Math.max(t,c-d); }
  function easeInOut(t){ return t<0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2; }

  const flight = (() => {
    const F = {
      z: 0, gridSpeed: 0, stars: [], 
      init(){
        for(let i=0; i<150; i++) this.stars.push({x:Math.random()*2-1, y:Math.random()*2-1, z:Math.random()*4, sz: Math.random()});
      },
      tick(dt, amp, density, active){
        const boost = active ? amp * 35.0 : 0.05; 
        this.gridSpeed = active ? (2.0 + boost + (density * 5)) : 0.05; 
        this.z += dt * 0.005 * this.gridSpeed;

        for(const s of this.stars) {
          s.z -= dt * 0.005 * (this.gridSpeed * 0.5);
          if (s.z <= 0) { s.z = 4; s.x = Math.random()*2-1; s.y = Math.random()*2-1; }
        }
      },
      renderBackground(ctx, width, height, amp){
        const cx = width/2, cy = height/2, fov = 300;
        ctx.fillStyle = "#fff";
        for(const s of this.stars) {
           const scale = fov / s.z, sx = cx + s.x * scale, sy = cy + s.y * scale;
           if (sx>0 && sx<width && sy>0 && sy<height) {
             const sz = Math.max(0.5, (2.0 / s.z) * s.sz);
             ctx.globalAlpha = Math.min(1, 1/s.z); ctx.fillRect(sx, sy, sz, sz);
           }
        }
        ctx.globalAlpha = 1.0;
      }
    };
    F.init(); return F;
  })();

  const geoMorph = (() => {
    return {
      inited:false, nextVariant:0, t:1, from:[], target:[], points:[], 
      visibleCount:90, targetCount:90, energy:0, requestUpdate:true, _speed:null,
      dimension: 3.0, 
      init(){ this.inited=true; this.points=[]; },
    };
  })();

  function geoShapePoint(v,u,tt){
    const a=u*Math.PI*2;
    if(v===0){
      const e=Math.floor(u*12), f=(u*12)-e, s=1.8, vv=[[-s,-s,-s],[s,-s,-s],[s,s,-s],[-s,s,-s],[-s,-s,s],[s,-s,s],[s,s,s],[-s,s,s]];
      const ed=[[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];
      const [i,j]=ed[e%12], p=vv[i], q=vv[j]; return [lerp(p[0],q[0],f), lerp(p[1],q[1],f), lerp(p[2],q[2],f)];
    }
    if(v===1){
        const i = u * 100; const phi = Math.acos(1 - 2 * u); const theta = Math.sqrt(Math.PI * 100) * phi;
        const r = 2.0;
        return [r*Math.cos(theta)*Math.sin(phi), r*Math.sin(theta)*Math.sin(phi), r*Math.cos(phi)];
    }
    if(v===2){ const ph=Math.acos(lerp(-1,1,(u*.97+.015)%1)), r=2.0; return [r*Math.sin(ph)*Math.cos(a), r*Math.cos(ph), r*Math.sin(ph)*Math.sin(a)]; }
    if(v===3){
       const s=2.2; const p=[[s,s,s], [-s,-s,s], [-s,s,-s], [s,-s,-s]];
       const seg = Math.floor(u*6); const f = (u*6)-seg; const map = [[0,1],[1,2],[2,0],[0,3],[1,3],[2,3]];
       const [i,j] = map[seg%6];
       return [lerp(p[i][0],p[j][0],f), lerp(p[i][1],p[j][1],f), lerp(p[i][2],p[j][2],f)];
    }
    if(v===4){
        const t = u * 2*Math.PI; const s = 0.8;
        const x = (1 + s*Math.cos(t/2)) * Math.cos(t);
        const y = (1 + s*Math.cos(t/2)) * Math.sin(t);
        const z = s * Math.sin(t/2);
        return [x*2.0, y*2.0, z*2.0];
    }
    if(v===5){ const t = u * 8 * Math.PI; return [Math.sin(t)*1.5, Math.cos(t)*1.5, (u-0.5)*5]; }
    if(v===6){
        const r = 1.0 + Math.pow(Math.sin(u*Math.PI*12), 4) * 2.0;
        const phi = Math.acos(1 - 2 * u); const theta = Math.sqrt(Math.PI * 60) * phi;
        return [r*Math.cos(theta)*Math.sin(phi), r*Math.sin(theta)*Math.sin(phi), r*Math.cos(phi)];
    }
    if(v===7){ return [(Math.random()-0.5)*6, (Math.random()-0.5)*6, (Math.random()-0.5)*6]; }
    return [(Math.sin(a)+2*Math.sin(2*a))*0.6, (Math.cos(a)-2*Math.cos(2*a))*0.35, -Math.sin(3*a)*0.55];
  }

  // 修复：添加返回语句
  function geoBuildTarget(v,cnt,tt){
    const pts=new Array(cnt);
    for(let i=0;i<cnt;i++){
      const u=i/cnt, p=geoShapePoint(v,u,tt), e=geoMorph.energy||0;
      const j=0.06*Math.sin(i*17.13+tt*1.7) + 0.15*e*Math.sin(i*7.77+tt*20.0); 
      pts[i]={x:p[0]+j, y:p[1]-j*0.7, z:p[2]+j*0.5, a:1};
    }
    return pts;  // 添加这行，返回创建的数组
  }

  function onStep(step){
    const cats={}; for(const c of CATS) cats[c]=0;
    let hits=0, acc=0;
    for(let r=0;r<ROWS;r++){ const st=state.pattern[r][step]; if(st){ cats[CATS[r]]=Math.max(cats[CATS[r]],st); hits++; if(st===3)acc++; } }
    vis.pulse=1.0; vis.energy=clamp(vis.energy+0.15+0.12*acc,0,1.7);
    geoMorph.energy=Math.max(geoMorph.energy, 0.25+0.35*acc+0.1*hits); 
    
    if (cats["HAT"] > 0) vis.colorHue = (vis.colorHue + 40) % 360; 
    if (cats["KICK"] > 0) vis.pulse = 2.0; 
    if (cats["SNARE"] > 0) geoRot += 0.5; 

    if(acc) geoMorph.requestUpdate=true;
  }

  function updateVisualDistribution(){ geoMorph.requestUpdate=true; }

  function rmsFromAnalyser(){
    if(!analyser) return 0;
    const arr = new Uint8Array(analyser.fftSize);
    analyser.getByteTimeDomainData(arr);
    let s=0; for(let i=0;i<arr.length;i++) s+=((arr[i]-128)/128)**2;
    return Math.sqrt(s/arr.length);
  }

  const dosVis = (() => {
    const hex = "0123456789ABCDEF";
    const linesLeft = [], linesRight = [];
    const maxLines = 25; 
    let frame = 0;

    return {
      tick(amp, active) {
        frame++;
        const speed = active ? (2 + Math.floor(amp * 10)) : 0.5; 
        const interval = Math.max(5, Math.floor(60 / speed));

        if (frame % interval === 0) {
          let l = "";
          const d = new Date();
          const mode = Math.random();
          
          if (mode < 0.2) l = d.toISOString().split('T')[0]; 
          else if (mode < 0.4) l = d.toLocaleTimeString(); 
          else if (mode < 0.6) l = "CPU " + (Math.random()*100).toFixed(1) + "%";
          else if (mode < 0.8) l = "TMP " + (30 + Math.random()*40).toFixed(1) + "C";
          else l = "CORE " + (active ? "ACTIVE" : "IDLE");

          linesLeft.unshift({ t: l, hi: mode < 0.4 });
          if (linesLeft.length > maxLines) linesLeft.pop();

          let r = "";
          const modeR = Math.random();
          if (modeR < 0.25) r = "WIND " + (Math.random()*20).toFixed(1) + "km";
          else if (modeR < 0.5) r = "HUM " + (Math.random()*100).toFixed(0) + "%";
          else if (modeR < 0.75) r = "MEM " + (Math.random()*16384).toFixed(0) + "MB";
          else r = "0x" + Math.random().toString(16).substr(2, 8).toUpperCase();

          linesRight.unshift({ t: r, hi: modeR < 0.5 });
          if (linesRight.length > maxLines) linesRight.pop();
        } 
      },
      render(ctx, w, h) {
        ctx.font = "10px monospace";
        const startY = 30;
        
        ctx.textAlign = "left";
        linesLeft.forEach((l, i) => {
          ctx.fillStyle = l.hi ? "#fff" : "rgba(0, 204, 255, 0.7)";
          ctx.fillText(l.t, 10, startY + i * 12);
        });

        ctx.textAlign = "right";
        linesRight.forEach((l, i) => {
          ctx.fillStyle = l.hi ? "#00ccff" : "rgba(100, 100, 100, 0.6)"; 
          ctx.fillText(l.t, w - 10, startY + i * 12);
        });
      }
    };
  })();

  function drawHyperCore(dt){
    const g = ctx, w = cvMain.width, h = cvMain.height;
    
    g.fillStyle = "#000"; g.fillRect(0,0,w,h);
    
    const active = state.isPlaying;
    const ampRaw= active ? rmsFromAnalyser() : 0;
    ampSmooth=approach(ampSmooth, ampRaw, dt*0.008);
    const amp=ampSmooth, act=clamp(amp*80,0,1), dt3=dt*(act>0.02?0.04+0.96*act:0.006);
    const density = Number($("density").value) / 100;

    flight.tick(dt, amp, density, active);
    flight.renderBackground(g, w, h, amp);

    if(!geoMorph.inited) geoMorph.init();
    
    geoTime += active ? dt3 : (dt * 0.05); 
    
    const tt=geoTime/1000, desiredVariant=Math.floor(geoTime/3000) % 8; 
    const desiredCount=clamp(Math.round(70+geoMorph.energy*18),55,160);
    geoMorph.dimension = 2.5 + 1.5 * Math.sin(geoTime * 0.0005);

    if(geoMorph.requestUpdate || Math.abs(desiredCount-geoMorph.targetCount)>10 || geoMorph.nextVariant !== desiredVariant){
        geoMorph.requestUpdate=false; geoMorph.t=0;
        geoMorph.from=geoMorph.points.length?geoMorph.points.map(p=>({x:p.x,y:p.y,z:p.z,a:p.a})):[];
        geoMorph.nextVariant=desiredVariant; geoMorph.targetCount=desiredCount;
        geoMorph.target=geoBuildTarget(desiredVariant, desiredCount, tt);
        if(!geoMorph.visibleCount) geoMorph.visibleCount=desiredCount;
    }
    
    const targetSpeed=980/(1+Math.min(1.2,geoMorph.energy)*0.7);
    geoMorph._speed=(geoMorph._speed==null)?targetSpeed:approach(geoMorph._speed, targetSpeed, dt3*0.012);
    geoMorph.t=clamp(geoMorph.t+dt3/geoMorph._speed,0,1);
    const e=easeInOut(geoMorph.t);
    geoMorph.visibleCount=approach(geoMorph.visibleCount, geoMorph.targetCount, dt3*0.08);
    
    const vc=Math.max(1,Math.floor(geoMorph.visibleCount)), fromN=geoMorph.from.length||1, tgtN=geoMorph.target.length||1;
    if(geoMorph.points.length<vc) while(geoMorph.points.length<vc) geoMorph.points.push({x:0,y:0,z:0,a:0});
    
    for(let i=0;i<vc;i++){
        const fp=geoMorph.from.length?geoMorph.from[i%fromN]:{x:0,y:0,z:0,a:0};
        const tp=geoMorph.target[i%tgtN]||{x:0,y:0,z:0,a:1};
        geoMorph.points[i]={
            x:lerp(fp.x,tp.x,e), y:lerp(fp.y,tp.y,e), z:lerp(fp.z,tp.z,e),
            a:clamp(lerp(fp.a??1,1,e)*(i<geoMorph.visibleCount?1:0),0,1)
        };
    }
    
    geoRot += active ? (dt3*0.0012*(1+amp*20)) : 0.0005; 
    geoMorph.energy=Math.max(0,geoMorph.energy*0.92-dt3*0.00025);
    const warp=1+amp*0.55+geoMorph.energy*0.12, pts2=new Array(vc);
    
    for(let i=0;i<vc;i++){
        const p=geoMorph.points[i];
        let x=p.x*warp, y=p.y*warp, z=p.z;
        if (geoMorph.dimension < 2.0) y *= (geoMorph.dimension-1);
        if (geoMorph.dimension < 3.0) z *= (geoMorph.dimension-2);
        let x1=x*Math.cos(geoRot)+z*Math.sin(geoRot), z1=-x*Math.sin(geoRot)+z*Math.cos(geoRot);
        let y2=y*Math.cos(geoRot*0.83)-z1*Math.sin(geoRot*0.83);
        let z2=y*Math.sin(geoRot*0.83)+z1*Math.cos(geoRot*0.83);
        const ss=(120/(z2+5.0)); 
        pts2[i]=[w/2+x1*ss, h/2+y2*ss];
    }
    
    g.lineWidth=1.5; 
    g.beginPath(); 
    for(let i=0;i<vc-1;i++){ 
        const a=pts2[i],b=pts2[i+1]; 
        const hue = (220 + amp*60 + i*2) % 360;
        const lig = 40 + amp*20; 
        g.strokeStyle = `hsla(${hue}, 60%, ${lig}%, 0.8)`;
        g.beginPath();
        g.moveTo(a[0],a[1]); 
        if (active && amp > 0.05) {
             const cx = (a[0]+b[0])/2 + Math.sin(i*0.5 + geoTime*0.01) * (amp*20);
             const cy = (a[1]+b[1])/2 + Math.cos(i*0.5 + geoTime*0.01) * (amp*20);
             g.quadraticCurveTo(cx, cy, b[0], b[1]);
        } else { g.lineTo(b[0],b[1]); }
        g.stroke();
    }
    
    g.fillStyle= active ? "#fff" : "#444"; 
    for(let i=0;i<vc;i++) g.fillRect(Math.round(pts2[i][0])-1, Math.round(pts2[i][1])-1, 2, 2);

    dosVis.tick(amp, active);
    dosVis.render(g, w, h);
  }

  let lastFrame=now();
  function animLoop(){
    const t=now(), dt=t-lastFrame; lastFrame=t;
    if(cvMain.width !== cvMain.clientWidth || cvMain.height !== cvMain.clientHeight){
        cvMain.width = cvMain.clientWidth;
        cvMain.height = cvMain.clientHeight;
    }
    if(state.isPlaying){
      const stepDur=(60/state.bpm)/4;
      const displayStep=(state.currentStep-1+state.steps)%state.steps;
      setPlayingColumn(displayStep);
      if(displayStep!==state.visual.lastStep){ state.visual.lastStep=displayStep; onStep(displayStep); }
    }
    drawHyperCore(dt);
    vis.energy*=0.9;
    requestAnimationFrame(animLoop);
  }

  // WIRING
  const libBtn = $("mobileLibBtn");
  if(libBtn) libBtn.onclick = () => { $("leftCol").classList.toggle("active"); };
  
  const closeBtn = $("closeLibBtn");
  if(closeBtn) closeBtn.onclick = () => { $("leftCol").classList.remove("active"); };

  // 修改：移动设备文件选择优化
  function handleFileSelect(e){
    addFiles(Array.from(e.target.files||[])); 
    e.target.value="";
  }

  $("fileInputFile").addEventListener("change", handleFileSelect);
  $("fileInputFolder").addEventListener("change", handleFileSelect);

  $("btnLoadFile").onclick = () => $("fileInputFile").click();
  
  // 修改：移动设备上，将文件夹按钮转换为文件选择
  $("btnLoadFolder").onclick = () => {
    if (isMobile()) {
      // 在移动设备上，使用常规文件选择
      $("fileInputFile").click();
      // 显示提示信息
      setTimeout(() => {
        toast("提示: 在手机上请逐个选择音频文件", 3000);
      }, 300);
    } else {
      // 在桌面设备上，使用文件夹选择
      $("fileInputFolder").click();
    }
  };

  function addFiles(files){
    const audioFiles = files.filter(f => f.type.startsWith('audio/') || f.name.endsWith('.wav') || f.name.endsWith('.mp3') || f.name.endsWith('.aif'));
    const cap=200; const take = audioFiles.slice(0, Math.max(0, cap - state.files.length));
    for(const f of take){
      state.files.push({ id:String(Math.random()), name:f.name, file:f, buffer:null, category:null, override:false });
    }
    if(state.selectedFileIndex<0 && state.files.length) state.selectedFileIndex=0;
    renderFileList(); setStatus("LOADED", `${state.files.length} FILES`);
  }

  async function analyzeAndGenerate(){
    if(!state.files.length) return toast("NO FILES");
    await ensureAudio(); if(audioCtx.state!=="running") await audioCtx.resume();
    setStatus("ANALYZING...");
    for(const f of state.files){
      if(!f.buffer) f.buffer = await decodeFile(f.file);
      if(!f.category) f.category = classify(extractFeatures(f.buffer));
    }
    renderFileList(); randomizePattern(); setStatus("READY");
    if(window.innerWidth < 900) $("leftCol").classList.remove("active");
  }

  // FIXED: Add event listener for Generate button in Param bar
  const btnRandom = $("btnRandom");
  if(btnRandom) btnRandom.onclick = randomizePattern;

  $("btnClear").onclick = () => { stopTransport(); state.files=[]; renderFileList(); resetPattern(); setStatus("CLEARED"); };
  $("btnAnalyzeGenerate").onclick = analyzeAndGenerate;
  $("btnPlay").onclick = async () => { await ensureAudio(); if(audioCtx.state!=="running") await audioCtx.resume(); startTransport(); };
  $("btnStop").onclick = stopTransport;
  
  // Rec button on top for mobile
  $("btnRecord").onclick = async () => {
    await ensureAudio();
    if(!state.record.isRecording){
      if(!state.record.streamDest){ state.record.streamDest=audioCtx.createMediaStreamDestination(); master.connect(state.record.streamDest); }
      state.record.rec = new MediaRecorder(state.record.streamDest.stream, {mimeType:"audio/webm"});
      state.record.chunks=[];
      state.record.rec.ondataavailable=e=>state.record.chunks.push(e.data);
      state.record.rec.onstop=()=>{
        const b=new Blob(state.record.chunks,{type:"audio/webm"});
        const a=document.createElement("a"); a.href=URL.createObjectURL(b); a.download="rec.webm"; a.click();
      };
      state.record.rec.start();
      state.record.isRecording=true; $("btnRecord").textContent="REC..."; setStatus("RECORDING");
    } else {
      state.record.rec.stop(); state.record.isRecording=false; $("btnRecord").textContent="RECORD"; setStatus("SAVED");
    }
  };
  
  // Export button logic
  const openExport = () => $("modalBackdrop").style.display="flex";
  
  const btnExport = $("btnExport");
  if(btnExport) btnExport.onclick = openExport;
  
  const btnExpTop = $("btnExportTop"); 
  if(btnExpTop) btnExpTop.onclick = openExport; // if visible

  $("btnExportCancel").onclick = () => $("modalBackdrop").style.display="none";
  $("btnExportGo").onclick = async () => {
    $("modalBackdrop").style.display="none"; if(!state.files.length) return toast("NO AUDIO"); toast("RENDERING WAV...");
  };

  $("btnResetGrid").onclick = resetPattern;
  
  const _bpm=$("bpmBar"), _bpmV=$("bpmVal");
  _bpm.addEventListener("input", e=>{
    state.bpm = clamp(Number(e.target.value), 60, 220); _bpmV.textContent = Math.round(state.bpm); refreshTransport();
  });
  
  const _meter = $("meterMode");
  _meter.addEventListener("change", e=>{
      state.steps = Math.max(1, Number(e.target.value)); 
      initPattern(state.steps); renderHeader(); renderGrid(); setStatus(`STEPS: ${state.steps}`);
  });

  $("fileList").addEventListener("keydown", async e=>{
    if(!state.files.length) return;
    if(e.key==="ArrowDown") state.selectedFileIndex = clamp(state.selectedFileIndex+1, 0, state.files.length-1);
    if(e.key==="ArrowUp") state.selectedFileIndex = clamp(state.selectedFileIndex-1, 0, state.files.length-1);
    if(e.key==="Enter") await previewFile(state.selectedFileIndex);
    if(/^[1-6]$/.test(e.key)){
      const idx = Number(e.key)-1; const cat = CATS[idx]; const f = state.files[state.selectedFileIndex];
      if(f){ f.category = cat; f.override = true; renderFileList(); updateVisualDistribution(); toast(`CLASS SET: ${cat}`); }
    }
    renderFileList();
    const sel = $("fileList").querySelector(".selected"); if(sel) sel.scrollIntoView({block:"nearest"});
  });

  renderHeader(); renderGrid(); renderFileList();
  requestAnimationFrame(animLoop);
})();
</script>
</body>
</html>
