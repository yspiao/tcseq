<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>TCSEQ</title>
  <style>
    :root{
      --bg:#070707;
      --panel:#0f1114;
      --panel2:#0b0d10;
      --line:#2b2f36;
      --line2:#1e2229;
      --text:#e7e7e7;
      --muted:#a6a6a6;
      --muted2:#7a7a7a;
      --accent:#1a2a3d; /* deep blue, kept subtle */
      --accent2:#111820;
      --danger:#d04b4b;
      --ok:#6bd06b;
      --font: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family:var(--font);
      letter-spacing:0.2px;
    }
    button, select, input{
      font-family:var(--font);
      background:transparent;
      color:var(--text);
      border:1px solid var(--line);
      padding:6px 10px;
      font-size:12px;
      line-height:1;
      outline:none;
    }
    button{
      cursor:pointer;
      user-select:none;
    }
    button:hover, select:hover{border-color:#3b414a}
    button:active{transform:translateY(1px)}
    button.primary{
      border-color:#3b4655;
      background:var(--accent2);
    }
    button.primary:hover{background:var(--accent)}
    button.ghost{
      border-color:var(--line2);
      color:var(--muted);
    }
    button.ghost:hover{border-color:var(--line)}
    button.danger{border-color:rgba(208,75,75,.55); color:#ffd1d1}
    button[disabled], select[disabled]{opacity:.45; cursor:not-allowed}
    .app{
      height:100%;
      display:flex;
      flex-direction:column;
    }
    /* Top bar (no boxed TCSEQ) */
    .topbar{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      border-bottom:1px solid var(--line2);
      background:#050505;
    }
    .brand{
      font-size:14px;
      letter-spacing:2px;
      margin-right:auto;
      color:#efefef;
      user-select:none;
    }
    .topbar .cluster{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .mini{
      font-size:11px;
      color:var(--muted);
      border:1px solid var(--line2);
      padding:5px 8px;
    }
    /* Main layout */
    .main{
      flex:1;
      min-height:0;
      display:grid;
      grid-template-columns: 340px 1fr;
      gap:10px;
      padding:10px;
    }
    .panel{
      border:1px solid var(--line2);
      background:var(--panel);
      min-height:0;
    }
    .left{
      display:flex;
      flex-direction:column;
      min-height:0;
      gap:10px;
    }
    .left .panel{padding:10px}
    .panel-title{
      font-size:12px;
      color:var(--muted);
      letter-spacing:1px;
      margin:0 0 8px 0;
      display:flex;
      align-items:center;
      justify-content:space-between;
    }
    .row{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .control-row{
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .control-row .leftbtns, .control-row .rightbtns{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .filelist{
      border:1px solid var(--line2);
      background:var(--panel2);
      padding:6px;
      height:240px;
      overflow:auto;
    }
    .fileitem{
      display:grid;
      grid-template-columns: 1fr 92px;
      gap:8px;
      padding:6px 6px;
      border-bottom:1px solid rgba(255,255,255,0.04);
      align-items:center;
    }
    .fileitem:last-child{border-bottom:none}
    .fname{
      cursor:pointer;
      color:#eaeaea;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      padding:2px 0;
    }
    .fname:hover{color:#ffffff; text-decoration:underline}
    .cat{
      justify-self:end;
      text-align:right;
      color:var(--muted);
      cursor:pointer;
      padding:2px 6px;
      border:1px solid var(--line2);
      background:#0a0c10;
      user-select:none;
    }
    .cat:hover{border-color:var(--line)}
    .fileitem.selected{
      background:rgba(26,42,61,.25);
      outline:1px solid rgba(255,255,255,0.06);
    }
    .hint{
      color:var(--muted2);
      font-size:11px;
      line-height:1.3;
      margin-top:8px;
    }

    /* Sequencer + right visuals */
    .work{
      display:flex;
      flex-direction:column;
      min-height:0;
      gap:10px;
    }
    .seqwrap{
      display:grid;
      grid-template-columns: 1fr 360px;
      gap:10px;
      min-height:0;
    }
    .sequencer{
      padding:10px;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .seq-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      margin-bottom:8px;
    }
    .seq-head .leftmeta{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      color:var(--muted);
      font-size:11px;
    }
    .seq-head .rightmeta{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-end;
    }
    .gridwrap{
      border:1px solid var(--line2);
      background:var(--panel2);
      padding:8px;
      overflow:auto;
      min-height:0;
    }
    .legend{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      align-items:center;
      color:var(--muted);
      font-size:11px;
      margin-bottom:8px;
      user-select:none;
    }
    .legend .sw{
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .swbox{
      width:10px;height:10px;
      border:1px solid var(--line2);
      background:#050607;
    }
    .swbox.ghost{background:#0b111a}
    .swbox.hit{background:#162437}
    .swbox.acc{background:#223d5c}
    .grid{
      display:grid;
      grid-template-columns: 90px repeat(16, 16px);
      gap:6px;
      align-items:center;
    }
    .rlabel{
      color:var(--muted);
      font-size:11px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      padding-right:4px;
    }
    .step{
      width:16px;height:16px;
      border:1px solid var(--line2);
      background:#050607;
      cursor:pointer;
      position:relative;
      user-select:none;
    }
    .step:hover{border-color:var(--line)}
    .step[data-state="1"]{background:#0b111a}
    .step[data-state="2"]{background:#162437}
    .step[data-state="3"]{background:#223d5c}
    .step.playing::after{
      content:"";
      position:absolute; inset:-2px;
      border:1px solid rgba(255,255,255,0.25);
      pointer-events:none;
    }
    .steps-header{
      display:grid;
      grid-template-columns: 90px repeat(16, 16px);
      gap:6px;
      margin-bottom:6px;
      align-items:center;
      color:var(--muted);
      font-size:10px;
      user-select:none;
    }
    .steps-header .h{ text-align:center; }
    .vispanel{
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .vis{
      border:1px solid var(--line2);
      background:var(--panel2);
      height:190px;
      position:relative;
      overflow:hidden;
    }
    canvas{
      width:100%;
      height:100%;
      display:block;
      image-rendering: pixelated;
    }
    .vislabel{
      position:absolute;
      top:8px; left:10px;
      font-size:11px;
      color:var(--muted);
      letter-spacing:1px;
      user-select:none;
      background:rgba(0,0,0,.25);
      padding:2px 6px;
      border:1px solid rgba(255,255,255,0.06);
    }

    /* Footer removed per spec; keep only a tiny status strip */
    .status{
      padding:6px 12px;
      border-top:1px solid var(--line2);
      color:var(--muted2);
      font-size:11px;
      background:#050505;
      display:flex;
      gap:10px;
      justify-content:space-between;
    }
    .status .right{white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:60%}

    /* Hidden panel mode */
    .hidden-left .main{
      grid-template-columns: 1fr;
    }
    .hidden-left .left{display:none}

    /* Modal */
    .modal-backdrop{
      position:fixed; inset:0;
      background:rgba(0,0,0,.72);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:50;
    }
    .modal{
      width:min(560px, 92vw);
      border:1px solid var(--line);
      background:#0b0c0f;
      padding:14px;
    }
    .modal h3{
      margin:0 0 10px 0;
      font-size:13px;
      color:#f0f0f0;
      letter-spacing:1px;
    }
    .modal .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .modal label{
      display:block;
      font-size:11px;
      color:var(--muted);
      margin-bottom:6px;
    }
    .modal .actions{
      margin-top:12px;
      display:flex;
      justify-content:flex-end;
      gap:8px;
      flex-wrap:wrap;
    }
    .kbd{
      border:1px solid var(--line2);
      padding:2px 6px;
      font-size:10px;
      color:var(--muted);
      background:#07090c;
    }
    .toast{
      position:fixed;
      left:12px;
      bottom:44px;
      border:1px solid var(--line2);
      background:#090a0d;
      padding:8px 10px;
      font-size:11px;
      color:var(--muted);
      display:none;
      z-index:60;
      max-width:min(560px, 92vw);
    }

    /* Responsive */
    @media (max-width: 980px){
      .main{grid-template-columns: 1fr; }
      .seqwrap{grid-template-columns: 1fr; }
      .vispanel{order:2}
      .sequencer{order:1}
      .filelist{height:200px}
      .vis{height:180px}
    }
  </style>
</head>
<body>
<div class="app" id="app">
  <div class="topbar">
    <div class="brand">TCSEQ</div>

    <div class="cluster">
      <button id="btnPlay" class="primary">PLAY</button>
      <button id="btnStop">STOP</button>
      <button id="btnRecord">RECORD</button>
      <button id="btnExport">EXPORT</button>
      <button id="btnHidePanel" class="ghost">HIDE PANEL</button>
      <button id="btnHelp" class="ghost">HELP</button>
    </div>
  </div>

  <div class="main">
    <div class="left">
      <div class="panel" id="controlPanel">
        <div class="panel-title">
          <span>CONTROL</span>
          <span class="mini" id="audioState">audio: idle</span>
        </div>

        <div class="control-row">
          <div class="leftbtns">
            <button id="btnLoad" class="primary">LOAD FILES</button>
            <button id="btnClear">CLEAR</button>
          </div>
          <div class="rightbtns">
            <button id="btnAnalyzeGenerate" class="primary">ANALYZE+GENERATE</button>
            <button id="btnDebug" class="ghost">DEBUG</button>
          </div>
        </div>

        <div class="filelist" id="fileList" tabindex="0" aria-label="file list"></div>

        <div class="hint">
          Click a filename to preview. Click the class label to manually correct classification.<br/>
          Keys: <span class="kbd">↑</span>/<span class="kbd">↓</span> select, <span class="kbd">Enter</span> preview, <span class="kbd">1-6</span> set class.
        </div>
      </div>
    </div>

    <div class="work">
      <div class="panel seqwrap">
        <div class="sequencer">
          <div class="panel-title">
            <span>SEQUENCER</span>
            <span class="mini" id="transport">bpm 170 • 1 bar • 16 steps</span>
          </div>

          <div class="seq-head">
            <div class="leftmeta">
              <span id="patternInfo">Pattern: 1 bar(s) // viewing BAR 1</span>
            </div>

            <div class="rightmeta">
              <label class="mini" style="display:flex; gap:8px; align-items:center;">
                VIEW
                <select id="viewMode">
                  <option value="follow">FOLLOW</option>
                  <option value="static">STATIC</option>
                </select>
              </label>

              <label class="mini" style="display:flex; gap:8px; align-items:center;">
                STYLE
                <select id="styleMode">
                  <option value="dnb">DNB</option>
                  <option value="jungle">JUNGLE</option>
                  <option value="breakbeat">BREAKBEAT</option>
                  <option value="minimal">MINIMAL</option>
                </select>
              </label>

              <label class="mini" style="display:flex; gap:8px; align-items:center;">
                DENS
                <input id="density" type="range" min="0" max="100" value="58" style="width:110px;">
              </label>

              <button id="btnRandom" class="primary">RANDOM PATTERN</button>
              <button id="btnResetGrid">RESET GRID</button>
            </div>
          </div>

          <div class="gridwrap" id="gridWrap">
            <div class="legend">
              <span class="sw"><span class="swbox"></span> empty</span>
              <span class="sw"><span class="swbox ghost"></span> ghost</span>
              <span class="sw"><span class="swbox hit"></span> hit</span>
              <span class="sw"><span class="swbox acc"></span> accent</span>
              <span>Enter = preview (selected file)</span>
            </div>

            <div class="steps-header" id="stepsHeader"></div>
            <div class="grid" id="grid"></div>
          </div>
        </div>

        <div class="vispanel">
          <div class="vis">
            <div class="vislabel">8‑BIT SCENE</div>
            <canvas id="cvFighters" width="320" height="180"></canvas>
          </div>
          <div class="vis">
            <div class="vislabel">PSEUDO‑3D GEOMETRY</div>
            <canvas id="cvGeo" width="320" height="180"></canvas>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="status">
    <div id="statusLeft">ready</div>
    <div class="right" id="statusRight"></div>
  </div>
</div>

<!-- Export modal -->
<div class="modal-backdrop" id="modalBackdrop" role="dialog" aria-modal="true" aria-labelledby="exportTitle">
  <div class="modal">
    <h3 id="exportTitle">EXPORT</h3>
    <div class="grid2">
      <div>
        <label>Format</label>
        <select id="exportFormat">
          <option value="wav">WAV (offline render)</option>
          <option value="webm">WEBM (real-time record)</option>
          <option value="mp3" disabled>MP3 (requires encoder)</option>
        </select>
      </div>
      <div>
        <label>Sample Rate</label>
        <select id="exportSR">
          <option value="44100">44100</option>
          <option value="48000" selected>48000</option>
        </select>
      </div>
      <div>
        <label>Length</label>
        <select id="exportBars">
          <option value="1">1 bar</option>
          <option value="2">2 bars</option>
          <option value="4" selected>4 bars</option>
          <option value="8">8 bars</option>
        </select>
      </div>
      <div>
        <label>Normalize</label>
        <select id="exportNorm">
          <option value="0">off</option>
          <option value="1" selected>on</option>
        </select>
      </div>
    </div>
    <div class="hint" style="margin-top:10px">
      WAV export is offline-rendered (no clicks/pops). WEBM export is recorded in real time. MP3 is disabled unless you add an encoder (e.g., lamejs).
    </div>
    <div class="actions">
      <button id="btnExportCancel">CANCEL</button>
      <button id="btnExportGo" class="primary">EXPORT NOW</button>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<input id="fileInput" type="file" accept="audio/*" multiple style="display:none"/>

<script>
(() => {
  "use strict";

  // ---------- Utilities ----------
  const $ = (id) => document.getElementById(id);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const now = () => performance.now();
  const toast = (msg, ms=2600) => {
    const t = $("toast");
    t.textContent = msg;
    t.style.display = "block";
    clearTimeout(toast._tm);
    toast._tm = setTimeout(()=>{ t.style.display="none"; }, ms);
  };

  function mulberry32(seed){
    let t = seed >>> 0;
    return function(){
      t += 0x6D2B79F5;
      let x = Math.imul(t ^ (t >>> 15), 1 | t);
      x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
      return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
    };
  }

  // ---------- State ----------
  const CATS = ["KICK","SNARE","HAT","CLAP","BASS","PERC/FX"];
  const STEPS = 16;
  const ROWS = CATS.length;

  const state = {
    files: [], // {id,name,file,buffer,category,autoCategory,features,override:boolean}
    selectedFileIndex: -1,
    pattern: Array.from({length: ROWS}, () => Array.from({length: STEPS}, () => 0)), // 0 empty,1 ghost,2 hit,3 accent
    bpm: 170,
    isPlaying: false,
    viewMode: "follow",
    scheduler: null,
    nextNoteTime: 0,
    currentStep: 0,
    lookaheadMs: 25,
    scheduleAhead: 0.12,
    activeSources: new Set(),
    previewSource: null,
    previewGain: null,
    record: {
      rec: null,
      chunks: [],
      isRecording: false,
      streamDest: null
    },
    debug: {
      on:false,
      lines: []
    },
    visual: {
      lastStep: -1
    }
  };

  // ---------- Audio ----------
  let audioCtx = null;
  let master = null;
  let analyser = null;

  async function ensureAudio(){
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)({latencyHint:"interactive"});
    master = audioCtx.createGain();
    master.gain.value = 0.85;
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 1024;
    master.connect(analyser);
    analyser.connect(audioCtx.destination);

    $("audioState").textContent = "audio: " + audioCtx.state;
    audioCtx.onstatechange = () => $("audioState").textContent = "audio: " + audioCtx.state;
  }

  function killAllSources(){
    for (const s of state.activeSources){
      try{ s.stop(); }catch(e){}
    }
    state.activeSources.clear();
    if (state.previewSource){
      try{ state.previewSource.stop(); }catch(e){}
      state.previewSource = null;
    }
  }

  function safeStopSource(src, when=0){
    try{ src.stop(when); }catch(e){}
  }

  // ---------- File decoding + analysis ----------
  async function decodeFile(file){
    await ensureAudio();
    const arr = await file.arrayBuffer();
    // Copy buffer to detach from file; decodeAudioData on some browsers consumes the arraybuffer.
    const copy = arr.slice(0);
    const buf = await audioCtx.decodeAudioData(copy);
    return buf;
  }

  // Cheap transient-ish + timbre features (fast, stable)
  function extractFeatures(buffer){
    const ch = buffer.getChannelData(0);
    const sr = buffer.sampleRate;
    const N = ch.length;

    // windowed energy (rough onset strength)
    const hop = 256;
    const win = 1024;
    let prevE = 0;
    let maxFlux = 0;
    let fluxSum = 0;
    let count = 0;

    // zero crossing and lowfreq energy proxy
    let zc = 0;
    for (let i=1;i<N;i++){
      if ((ch[i-1] >= 0 && ch[i] < 0) || (ch[i-1] < 0 && ch[i] >= 0)) zc++;
    }
    const zcr = zc / N;

    // Simple spectral centroid approximation via FFT on first 4096 samples (or less)
    const fftN = Math.min(4096, N);
    const frame = new Float32Array(fftN);
    for (let i=0;i<fftN;i++) frame[i] = ch[i] * (0.5 - 0.5*Math.cos(2*Math.PI*i/(fftN-1)));
    // Real FFT magnitude (naive DFT for stability; small N only)
    const bins = 128; // coarse
    let centroid = 0, magSum = 0;
    for (let k=0;k<bins;k++){
      const w = 2*Math.PI*k/fftN;
      let re=0, im=0;
      for (let n=0;n<fftN;n++){
        const ang = w*n;
        re += frame[n] * Math.cos(ang);
        im -= frame[n] * Math.sin(ang);
      }
      const mag = Math.sqrt(re*re + im*im);
      const freq = (k*sr)/fftN;
      centroid += freq * mag;
      magSum += mag;
    }
    centroid = magSum > 1e-9 ? centroid / magSum : 0;
    const centroidNorm = centroid / (sr/2);

    // onset flux over first ~1s (or shorter)
    const maxSamples = Math.min(N, sr); // 1 sec
    for (let i=0; i+win < maxSamples; i+=hop){
      let e=0;
      for (let j=0;j<win;j++){
        const v = ch[i+j];
        e += v*v;
      }
      const flux = Math.max(0, e - prevE);
      prevE = e;
      maxFlux = Math.max(maxFlux, flux);
      fluxSum += flux;
      count++;
    }
    const fluxMean = count ? (fluxSum / count) : 0;

    // low frequency ratio via single-pole lowpass
    let lp=0;
    const a = Math.exp(-2*Math.PI*160/sr);
    let lowE=0, totE=0;
    for (let i=0;i<Math.min(N, sr*0.5);i++){ // first 0.5s
      lp = a*lp + (1-a)*ch[i];
      lowE += lp*lp;
      totE += ch[i]*ch[i];
    }
    const lowRatio = totE>1e-9 ? (lowE/totE) : 0;

    // attack time: time until RMS crosses 60% of peak RMS in first 200ms
    const atkWin = Math.min(N, Math.floor(sr*0.2));
    let peak=0;
    for (let i=0;i<atkWin;i++) peak = Math.max(peak, Math.abs(ch[i]));
    const thresh = peak * 0.6;
    let atkSamp = atkWin;
    for (let i=0;i<atkWin;i++){
      if (Math.abs(ch[i]) >= thresh){ atkSamp=i; break; }
    }
    const attack = atkSamp / sr; // seconds

    return { zcr, centroidNorm, fluxMean, maxFlux, lowRatio, attack };
  }

  function classify(features){
    // Heuristics tuned for drum one-shots:
    const {zcr, centroidNorm, fluxMean, lowRatio, attack} = features;

    // hats: high centroid, high zcr, low lowRatio
    if (centroidNorm > 0.55 && zcr > 0.12 && lowRatio < 0.35) return "HAT";

    // kicks/bass: high lowRatio, low centroid
    if (lowRatio > 0.68 && centroidNorm < 0.30) return (attack < 0.015 ? "KICK" : "BASS");

    // snares/claps: mid centroid, mid zcr, moderate lowRatio
    if (centroidNorm > 0.30 && centroidNorm < 0.55){
      if (zcr > 0.10 && attack < 0.02) return "CLAP";
      return "SNARE";
    }

    // fallback
    return "PERC/FX";
  }

  // ---------- UI rendering ----------
  const fileListEl = $("fileList");
  const statusLeft = $("statusLeft");
  const statusRight = $("statusRight");

  function setStatus(left, right=""){
    statusLeft.textContent = left;
    statusRight.textContent = right;
  }

  function renderFileList(){
    fileListEl.innerHTML = "";
    state.files.forEach((f, idx) => {
      const row = document.createElement("div");
      row.className = "fileitem" + (idx === state.selectedFileIndex ? " selected" : "");
      const name = document.createElement("div");
      name.className = "fname";
      name.textContent = f.name;
      name.title = "Click to preview";
      name.addEventListener("click", async (ev) => {
        ev.stopPropagation();
        state.selectedFileIndex = idx;
        renderFileList();
        await previewFile(idx);
      });

      const cat = document.createElement("div");
      cat.className = "cat";
      cat.textContent = f.category || "—";
      cat.title = "Click to change class";
      cat.addEventListener("click", (ev) => {
        ev.stopPropagation();
        state.selectedFileIndex = idx;
        renderFileList();
        openCatMenu(cat, idx);
      });

      row.appendChild(name);
      row.appendChild(cat);
      row.addEventListener("click", () => {
        state.selectedFileIndex = idx;
        renderFileList();
      });

      fileListEl.appendChild(row);
    });

    if (state.files.length === 0){
      const empty = document.createElement("div");
      empty.style.color = "var(--muted2)";
      empty.style.fontSize = "11px";
      empty.style.padding = "8px";
      empty.textContent = "No files loaded yet.";
      fileListEl.appendChild(empty);
    }
  }

  function openCatMenu(anchorEl, fileIdx){
    // Simple in-place dropdown using a temporary select
    const f = state.files[fileIdx];
    const sel = document.createElement("select");
    sel.style.width = "100%";
    CATS.forEach(c => {
      const op = document.createElement("option");
      op.value = c; op.textContent = c;
      if (c === f.category) op.selected = true;
      sel.appendChild(op);
    });
    const wrap = anchorEl.parentElement;
    const old = anchorEl;
    wrap.replaceChild(sel, old);
    sel.focus();
    const commit = () => {
      f.category = sel.value;
      f.override = true;
      renderFileList();
      // Pattern rows do not auto-move; classification affects RANDOM PATTERN generation and visuals.
      updateVisualDistribution();
    };
    sel.addEventListener("change", commit);
    sel.addEventListener("blur", commit, {once:true});
    sel.addEventListener("keydown", (e) => {
      if (e.key === "Escape"){
        wrap.replaceChild(old, sel);
        renderFileList();
      }
      if (e.key === "Enter"){
        commit();
      }
    });
  }

  // ---------- Sequencer grid ----------
  const gridEl = $("grid");
  const headerEl = $("stepsHeader");

  function renderHeader(){
    headerEl.innerHTML = "";
    const blank = document.createElement("div");
    blank.textContent = "STEP";
    headerEl.appendChild(blank);
    for (let i=0;i<STEPS;i++){
      const h = document.createElement("div");
      h.className = "h";
      h.textContent = String(i+1);
      headerEl.appendChild(h);
    }
  }

  function renderGrid(){
    gridEl.innerHTML = "";
    for (let r=0;r<ROWS;r++){
      const lab = document.createElement("div");
      lab.className = "rlabel";
      lab.textContent = CATS[r];
      gridEl.appendChild(lab);

      for (let s=0;s<STEPS;s++){
        const cell = document.createElement("div");
        cell.className = "step";
        cell.dataset.r = String(r);
        cell.dataset.s = String(s);
        cell.dataset.state = String(state.pattern[r][s]);
        cell.addEventListener("click", (ev) => {
          ev.preventDefault();
          const cur = state.pattern[r][s];
          const next = (cur + 1) % 4;
          state.pattern[r][s] = next;
          cell.dataset.state = String(next);
          updateVisualDistribution();
        });
        gridEl.appendChild(cell);
      }
    }
  }

  function setPlayingColumn(step){
    const cells = gridEl.querySelectorAll(".step");
    cells.forEach(c => c.classList.remove("playing"));
    if (state.viewMode !== "follow") return;
    for (const c of cells){
      if (Number(c.dataset.s) === step) c.classList.add("playing");
    }
  }

  // ---------- Preview ----------
  async function previewFile(idx){
    const f = state.files[idx];
    if (!f) return;
    await ensureAudio();
    if (audioCtx.state !== "running"){
      await audioCtx.resume();
    }

    // stop previous preview only (do not touch transport)
    if (state.previewSource){
      safeStopSource(state.previewSource);
      state.previewSource = null;
    }

    // if buffer not decoded, decode
    if (!f.buffer){
      setStatus("decoding…", f.name);
      f.buffer = await decodeFile(f.file);
    }

    const src = audioCtx.createBufferSource();
    src.buffer = f.buffer;
    const g = audioCtx.createGain();
    const t0 = audioCtx.currentTime;
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.linearRampToValueAtTime(0.65, t0+0.01);
    g.gain.linearRampToValueAtTime(0.0001, t0+Math.min(0.35, f.buffer.duration));
    src.connect(g);
    g.connect(master);

    src.start();
    state.previewSource = src;
    state.previewGain = g;

    setStatus("preview", `${f.name}  •  ${f.category || "—"}`);
    src.onended = () => {
      if (state.previewSource === src){
        state.previewSource = null;
      }
    };
  }

  // ---------- Transport scheduling ----------
  function stepToTime(stepIndex){
    const spb = 60 / state.bpm;
    const stepDur = spb / 4; // 16 steps per 4/4 bar (1/16)
    return stepIndex * stepDur;
  }

  function velocityFromState(st){
    if (st === 1) return 0.25;
    if (st === 2) return 0.55;
    if (st === 3) return 0.85;
    return 0.0;
  }

  function pickBufferForCat(cat){
    // choose a buffer from files with matching category; fallback any.
    const list = state.files.filter(f => f.buffer && f.category === cat);
    if (list.length) return list[Math.floor(Math.random()*list.length)].buffer;
    const any = state.files.filter(f => f.buffer);
    if (any.length) return any[Math.floor(Math.random()*any.length)].buffer;
    return null;
  }

  function scheduleStep(step, time){
    // snapshot pattern at schedule time (prevents crackles when pattern changes during playback)
    for (let r=0;r<ROWS;r++){
      const st = state.pattern[r][step];
      if (st === 0) continue;
      const vel = velocityFromState(st);
      const cat = CATS[r];
      const buf = pickBufferForCat(cat);
      if (!buf) continue;

      const src = audioCtx.createBufferSource();
      src.buffer = buf;

      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.0001, time);
      g.gain.linearRampToValueAtTime(vel, time + 0.006);
      g.gain.linearRampToValueAtTime(0.0001, time + Math.min(0.18, buf.duration));

      src.connect(g);
      g.connect(master);
      src.start(time);
      safeStopSource(src, time + buf.duration + 0.05);

      state.activeSources.add(src);
      src.onended = () => state.activeSources.delete(src);
    }
  }

  function schedulerTick(){
    if (!state.isPlaying) return;
    const ct = audioCtx.currentTime;
    while (state.nextNoteTime < ct + state.scheduleAhead){
      scheduleStep(state.currentStep, state.nextNoteTime);
      state.nextNoteTime += stepToTime(1);
      state.currentStep = (state.currentStep + 1) % STEPS;
    }
  }

  function startTransport(){
    if (state.isPlaying) return;
    state.isPlaying = true;
    state.currentStep = 0;
    state.nextNoteTime = audioCtx.currentTime + 0.05;

    state.scheduler = setInterval(schedulerTick, state.lookaheadMs);

    setStatus("playing", "transport running");
  }

  function stopTransport(){
    state.isPlaying = false;
    if (state.scheduler){
      clearInterval(state.scheduler);
      state.scheduler = null;
    }
    // stop scheduled/active sources (hard stop)
    killAllSources();
    setPlayingColumn(-1);
    setStatus("stopped", "");
  }

  // ---------- Random pattern generation ----------
  function resetPattern(){
    for (let r=0;r<ROWS;r++) for (let s=0;s<STEPS;s++) state.pattern[r][s] = 0;
    renderGrid();
    updateVisualDistribution();
  }

  function setHit(cat, step, st=2){
    const r = CATS.indexOf(cat);
    if (r < 0) return;
    state.pattern[r][((step%STEPS)+STEPS)%STEPS] = st;
  }

  function generateBase(style, rng){
    resetPattern();
    // Reasonable defaults
    if (style === "minimal"){
      setHit("KICK",0,3); setHit("KICK",8,2);
      setHit("SNARE",4,3); setHit("SNARE",12,3);
      for (let i=0;i<STEPS;i+=2) setHit("HAT", i, 1);
      setHit("CLAP",12,2);
      return;
    }

    if (style === "dnb"){
      setHit("KICK",0,3); setHit("KICK",10,2);
      setHit("SNARE",4,3); setHit("SNARE",12,3);
      for (let i=0;i<STEPS;i++){
        if (i%2===0) setHit("HAT", i, 2);
        if (i%4===2 && rng()<0.4) setHit("HAT", i, 1);
      }
      if (rng()<0.6) setHit("CLAP",12,2);
      if (rng()<0.35) setHit("PERC/FX",14,1);
      if (rng()<0.35) setHit("PERC/FX",2,1);
      return;
    }

    if (style === "breakbeat"){
      // Amen-ish skeleton
      setHit("KICK",0,3); setHit("KICK",7,2); setHit("KICK",10,2);
      setHit("SNARE",4,3); setHit("SNARE",11,2); setHit("SNARE",12,3);
      setHit("HAT",2,1); setHit("HAT",6,1); setHit("HAT",8,1); setHit("HAT",14,1);
      if (rng()<0.7) setHit("CLAP",12,2);
      setHit("PERC/FX",15,1);
      return;
    }

    // jungle
    setHit("KICK",0,3); setHit("KICK",6,2); setHit("KICK",9,2);
    setHit("SNARE",4,3); setHit("SNARE",12,3);
    setHit("HAT",2,1); setHit("HAT",3,1); setHit("HAT",6,1); setHit("HAT",8,1); setHit("HAT",10,1); setHit("HAT",14,1);
    setHit("PERC/FX",15,2);
    if (rng()<0.5) setHit("CLAP",12,2);
  }

  function applyDensity(density, rng, style){
    // density: 0..100; adds/removes hits without altering audio graph (no playback pops)
    const d = density / 100;

    // Thin out if low density
    for (let r=0;r<ROWS;r++){
      for (let s=0;s<STEPS;s++){
        const st = state.pattern[r][s];
        if (st === 0) continue;
        const keepP = 0.25 + 0.75*d;
        if (rng() > keepP){
          state.pattern[r][s] = 0;
        }
      }
    }

    // Add embellishments if high density
    const addP = Math.max(0, d - 0.45) * 1.6; // 0..~0.88
    for (let s=0;s<STEPS;s++){
      if (rng() < addP){
        // hats / perc accents
        if (rng() < 0.65){
          const st = rng()<0.25 ? 3 : (rng()<0.65 ? 2 : 1);
          state.pattern[CATS.indexOf("HAT")][s] = Math.max(state.pattern[CATS.indexOf("HAT")][s], st);
        } else {
          const rr = rng() < 0.5 ? "PERC/FX" : "CLAP";
          const st = rng()<0.18 ? 3 : 1;
          state.pattern[CATS.indexOf(rr)][s] = Math.max(state.pattern[CATS.indexOf(rr)][s], st);
        }
      }
    }

    // Style-specific ghosting
    if (style === "dnb" || style === "jungle"){
      for (let s=0;s<STEPS;s++){
        if (rng() < 0.22*d){
          const st = (s%4===3) ? 1 : 0;
          if (st) state.pattern[CATS.indexOf("SNARE")][s] = Math.max(state.pattern[CATS.indexOf("SNARE")][s], 1);
        }
      }
    }
  }

  function randomizePattern(){
    const style = $("styleMode").value;
    const density = Number($("density").value);
    const seed = (Date.now() ^ Math.floor(Math.random()*1e9)) >>> 0;
    const rng = mulberry32(seed);

    generateBase(style, rng);
    applyDensity(density, rng, style);

    // Render only (no audio graph rebuild -> prevents playback crackle)
    renderGrid();
    updateVisualDistribution();
    setStatus("pattern", `randomized • ${style.toUpperCase()} • dens ${density}`);
  }

  // ---------- Visuals (8-bit + pseudo 3D) ----------
  const cvFight = $("cvFighters");
  const ctxFight = cvFight.getContext("2d");
  const cvGeo = $("cvGeo");
  const ctxGeo = cvGeo.getContext("2d");

  // Offscreen low-res for pixel effect
  const offFight = document.createElement("canvas");
  offFight.width = 160; offFight.height = 90;
  const offFightCtx = offFight.getContext("2d");

  const offGeo = document.createElement("canvas");
  offGeo.width = 160; offGeo.height = 90;
  const offGeoCtx = offGeo.getContext("2d");

  const fighters = [];
  let geoRot = 0;

  // ---------- Visual step triggers + arcade scene + smooth geometry morph ----------
  const vis = {
    pulse: 0,
    energy: 0,
    trig: (() => {
      const o = {};
      for (const c of CATS) o[c] = 0;
      return o;
    })()
  };

  function easeInOut(t){
    return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3) / 2;
  }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function approach(cur, target, maxDelta){
    if (cur < target) return Math.min(target, cur + maxDelta);
    return Math.max(target, cur - maxDelta);
  }

  const game = (() => {
    const G = {
      inited:false,
      level:1,
      score:0,
      lives:3,
      kills:0,
      wave:0,
      msg:"",
      msgT:0,
      shake:0,
      flash:0,
      scroll:0,
      stars:[],
      bullets:[],
      enemies:[],
      parts:[],
      density:0.5,
      lead:"PERC/FX",
      // last LCD dims
      lx:0, ly:0, lw:0, lh:0,
      player:{ x:0, y:0, vy:0, targetY:0, cd:0, superCd:0 },

      recalc(){
        const dist = patternDistribution();
        const total = Object.values(dist).reduce((a,b)=>a+b,0) || 1;
        this.density = clamp(total/(ROWS*STEPS), 0, 1);
        this.lead = Object.entries(dist).sort((a,b)=>b[1]-a[1])[0]?.[0] || "PERC/FX";
      },

      reset(){
        this.inited=true;
        this.level=1; this.score=0; this.lives=3; this.kills=0; this.wave=0;
        this.msg=""; this.msgT=0; this.shake=0; this.flash=0; this.scroll=0;
        this.stars=[]; this.bullets=[]; this.enemies=[]; this.parts=[];
        this.player={ x:0, y:0, vy:0, targetY:0, cd:0, superCd:0 };
        this.recalc();
      },

      levelUp(){
        this.level = clamp(this.level+1, 1, 99);
        this.wave++;
        this.msg = "LEVEL " + this.level;
        this.msgT = 1500;
        this.flash = Math.max(this.flash, 0.6);
      },

      spawnEnemy(type="scout"){
        const lx=this.lx, ly=this.ly, lw=this.lw, lh=this.lh;
        const yMin = ly + 16, yMax = ly + lh - 20;
        const y = clamp(yMin + Math.random()*(yMax-yMin), yMin, yMax);
        const base = ({
          scout:{hp:1, sp: 18, pts: 25, sz: 5},
          brute:{hp:3, sp: 12, pts: 60, sz: 7},
          glitch:{hp:2, sp: 14, pts: 50, sz: 6},
          boss:{hp:14, sp: 7, pts: 400, sz: 12}
        })[type] || {hp:1, sp: 16, pts: 25, sz: 5};

        const vx = -(base.sp/60) * (1 + this.level*0.06) * (0.85+Math.random()*0.3);
        this.enemies.push({x: lx+lw-10, y, vx, hp:base.hp, maxHp:base.hp, type, sz:base.sz, t:0});
      },

      fire(power=1, mode="shot"){
        const p = this.player;
        if (p.cd > 0) return;
        const speed = (mode==="beam") ? 2.7 : 2.1;
        const spread = (mode==="spread") ? 3 : 0;
        const count = (mode==="spread") ? 3 : 1;
        for (let i=0;i<count;i++){
          const dy = spread ? (i-1)*spread : 0;
          this.bullets.push({x:p.x+7, y:p.y+2+dy, vx:speed, pow:power, life:900});
        }
        p.cd = (mode==="beam") ? 80 : 110;
        this.flash = Math.max(this.flash, 0.18 + 0.08*power);
      },

      bomb(){
        const p = this.player;
        if (p.superCd > 0) return;
        p.superCd = 1250;
        this.shake = Math.max(this.shake, 0.9);
        this.flash = Math.max(this.flash, 0.9);
        for (const e of this.enemies){
          e.hp -= 2;
        }
        for (let i=0;i<18;i++){
          this.parts.push({x:p.x+8, y:p.y+3, vx:(Math.random()-0.5)*1.6, vy:(Math.random()-0.5)*1.2, life:400+Math.random()*300});
        }
      },

      tick(dt, lx, ly, lw, lh, amp){
        if (!this.inited) this.reset();
        this.lx=lx; this.ly=ly; this.lw=lw; this.lh=lh;

        this.recalc();

        // starfield init
        if (this.stars.length < 34){
          while (this.stars.length < 34){
            this.stars.push({x: Math.random()*lw, y: Math.random()*lh, sp: 0.15 + Math.random()*0.45, tw: Math.random()*Math.PI*2});
          }
        }
        this.scroll += dt * (0.02 + this.level*0.001);
        for (const s of this.stars){
          s.x -= dt*s.sp*(0.025 + this.level*0.002);
          s.tw += dt*0.004;
          if (s.x < 0) { s.x += lw; s.y = Math.random()*lh; s.sp = 0.15 + Math.random()*0.55; }
        }

        // player movement (auto + beat-reactive; not a simple bob)
        const p = this.player;
        if (p.x === 0){
          p.x = lx + 12;
          p.y = ly + Math.floor(lh*0.55);
          p.targetY = p.y;
        }
        const t = now();
        const wander = Math.sin((t + this.level*300)*0.0022) * (2 + 6*this.density);
        const beatNudge = (amp>0.012 ? (amp*60) : 0);
        p.targetY = ly + Math.floor(lh*0.55 + wander + Math.sin(t*0.0016)*4 + beatNudge);
        p.targetY = clamp(p.targetY, ly+16, ly+lh-18);
        p.vy += (p.targetY - p.y) * 0.008;
        p.vy *= 0.82;
        p.y += p.vy;

        p.cd = Math.max(0, p.cd - dt);
        p.superCd = Math.max(0, p.superCd - dt);

        // wave-like spawn (progressive difficulty)
        const spawnRate = (0.45 + this.level*0.06) * (0.25 + this.density*1.2); // enemies/sec
        this._spawnAcc = (this._spawnAcc || 0) + dt * spawnRate / 1000;
        while (this._spawnAcc > 1){
          this._spawnAcc -= 1;
          const roll = Math.random();
          let type = "scout";
          if (this.level >= 4 && roll < 0.18) type = "brute";
          if (this.level >= 6 && roll < 0.10) type = "glitch";
          if (this.level % 8 === 0 && this.kills>0 && (this.kills % 32 === 0)) type = "boss";
          this.spawnEnemy(type);
        }

        // enemies
        for (const e of this.enemies){
          e.t += dt;
          e.x += e.vx * dt;
          if (e.type==="glitch"){
            e.y += Math.sin((now()+e.t)*0.02)*0.15;
            if (Math.random() < 0.02) this.parts.push({x:e.x, y:e.y, vx:(Math.random()-0.5)*1.2, vy:(Math.random()-0.5)*1.0, life:220});
          }
        }

        // bullets
        for (const b of this.bullets){
          b.x += b.vx * dt;
          b.life -= dt;
        }

        // collisions
        const hit = (b,e) => (Math.abs(b.x - e.x) < (e.sz+2) && Math.abs(b.y - e.y) < (e.sz+2));
        for (const b of this.bullets){
          if (b.life <= 0) continue;
          for (const e of this.enemies){
            if (e.hp <= 0) continue;
            if (hit(b,e)){
              e.hp -= b.pow;
              b.life = 0;
              this.shake = Math.max(this.shake, 0.25 + 0.12*b.pow);
              for (let i=0;i<6;i++){
                this.parts.push({x:e.x, y:e.y, vx:(Math.random()-0.5)*1.2, vy:(Math.random()-0.5)*1.0, life:260+Math.random()*220});
              }
              if (e.hp <= 0){
                this.kills++;
                this.score += (e.type==="boss") ? 400 : (e.type==="brute" ? 60 : (e.type==="glitch" ? 50 : 25));
                this.flash = Math.max(this.flash, 0.35);
                const thresh = 10 + this.level*6;
                if (this.kills % thresh === 0) this.levelUp();
              }
              break;
            }
          }
        }

        // enemy reaches left => damage
        for (const e of this.enemies){
          if (e.hp>0 && e.x < lx+10){
            e.hp = 0;
            this.lives--;
            this.shake = Math.max(this.shake, 0.8);
            this.flash = Math.max(this.flash, 0.6);
            this.msg = "HIT!";
            this.msgT = 700;
            if (this.lives <= 0){
              this.lives = 3;
              this.level = 1;
              this.kills = 0;
              this.score = 0;
              this.enemies = [];
              this.bullets = [];
              this.parts = [];
              this.msg = "RESTART";
              this.msgT = 1200;
            }
          }
        }

        // cleanup
        this.enemies = this.enemies.filter(e => e.x > lx-40 && e.hp>0);
        this.bullets = this.bullets.filter(b => b.life>0 && b.x < lx+lw+20);
        for (const pt of this.parts){
          pt.x += pt.vx * dt;
          pt.y += pt.vy * dt;
          pt.life -= dt;
        }
        this.parts = this.parts.filter(pt => pt.life > 0);

        // decay FX
        this.shake *= 0.9;
        this.flash *= 0.86;
        this.msgT = Math.max(0, this.msgT - dt);
      },

      onStep(evt){
        const k = evt.cats["KICK"] || 0;
        const b = evt.cats["BASS"] || 0;
        const s = evt.cats["SNARE"] || 0;
        const c = evt.cats["CLAP"] || 0;
        const h = evt.cats["HAT"] || 0;
        const p = evt.cats["PERC/FX"] || 0;

        if (k || b){
          const pow = (k===3||b===3) ? 3 : (k===2||b===2) ? 2 : 1;
          const mode = (b===3) ? "beam" : "shot";
          this.fire(pow, mode);
        }
        if (s || c){
          const mode = (s===3||c===3) ? "spread" : "shot";
          this.fire((s===3||c===3) ? 2 : 1, mode);
          if (this.enemies.length < 8 + this.level*1.2){
            const type = (this.level >= 6 && (s===3||c===3) && Math.random()<0.35) ? "glitch"
                       : (this.level >= 4 && Math.random()<0.25) ? "brute"
                       : "scout";
            this.spawnEnemy(type);
          }
        }
        if (p===3){
          this.bomb();
        } else if (p){
          this.shake = Math.max(this.shake, 0.15 + 0.1*p);
        }
        if (h){
          this.player.vy += (Math.random()<0.5?-1:1) * (0.18*h);
        }
      },

      render(g, lx, ly, lw, lh){
        const drawSpr = (x,y,rows,scale=1) => {
          g.fillStyle = "#111417";
          for (let r=0;r<rows.length;r++){
            const row = rows[r];
            for (let c=0;c<row.length;c++){
              if (row[c] === "#"){
                g.fillRect(x + c*scale, y + r*scale, scale, scale);
              }
            }
          }
        };

        // screen shake in LCD coords
        const sh = this.shake;
        const ox = Math.round((Math.random()-0.5) * sh * 4);
        const oy = Math.round((Math.random()-0.5) * sh * 3);

        g.save();
        g.translate(ox, oy);

        if (this.flash > 0.02){
          g.fillStyle = `rgba(255,255,255,${0.07*this.flash})`;
          g.fillRect(lx, ly, lw, lh);
        }

        // stars (scrolling background)
        g.fillStyle = "rgba(0,0,0,0.45)";
        for (const s of this.stars){
          const tw = 0.5 + 0.5*Math.sin(s.tw);
          if (tw > 0.52) g.fillRect(lx + (s.x|0), ly + (s.y|0), 1, 1);
        }

        // subtle platform line
        g.fillStyle = "rgba(0,0,0,0.18)";
        g.fillRect(lx+8, ly+lh-14, lw-16, 1);

        // player ship
        const ship = [
          "..#.....",
          ".###....",
          "#####...",
          ".###....",
          "..#.....",
          "...#....",
        ];
        drawSpr(this.player.x|0, this.player.y|0, ship, 1);

        // bullets
        g.fillStyle = "#111417";
        for (const b of this.bullets){
          const x = b.x|0, y = b.y|0;
          g.fillRect(x, y, 2, 1);
          if (b.pow >= 2) g.fillRect(x, y-1, 1, 3);
        }

        // aliens
        const alienA = [
          ".###.",
          "#####",
          "#.#.#",
          "#####",
          ".#.#.",
        ];
        const alienB = [
          ".####.",
          "######",
          "##..##",
          "######",
          ".#..#.",
          "..##..",
        ];
        const alienG = [
          ".#.#.",
          "#####",
          "#...#",
          "#####",
          ".###.",
        ];
        const boss = [
          "..#####..",
          ".#######.",
          "###.#.###",
          "#########",
          "##.###.##",
          ".##...##.",
        ];

        for (const e of this.enemies){
          const x = (e.x|0), y = (e.y|0);
          let spr = alienA;
          if (e.type==="brute") spr = alienB;
          if (e.type==="glitch") spr = alienG;
          if (e.type==="boss") spr = boss;
          drawSpr(x, y, spr, 1);
          if (e.maxHp > 1){
            g.fillStyle = "rgba(0,0,0,0.35)";
            g.fillRect(x, y-3, spr[0].length, 1);
            const fillW = Math.round((spr[0].length) * clamp(e.hp/e.maxHp,0,1));
            g.fillStyle = "#111417";
            g.fillRect(x, y-3, fillW, 1);
          }
        }

        // particles
        g.fillStyle = "rgba(0,0,0,0.35)";
        for (const pt of this.parts){
          g.fillRect(pt.x|0, pt.y|0, 1, 1);
        }

        // tiny HUD (pseudo-text)
        const textTiny = (x,y,str) => {
          g.fillStyle = "rgba(0,0,0,0.55)";
          for (let i=0;i<str.length;i++){
            const ch = str.charCodeAt(i);
            const bits = (ch ^ (ch>>3)) & 0xff;
            for (let b=0;b<6;b++){
              if (bits & (1<<b)) g.fillRect(x + i*4 + (b%3), y + (b>2?1:0), 1, 1);
            }
          }
        };
        textTiny(lx+10, ly+6, `LV${String(this.level).padStart(2,"0")}`);
        textTiny(lx+34, ly+6, `HP${this.lives}`);
        textTiny(lx+10, ly+lh-10, `SC${String(this.score).padStart(4,"0")}`);

        if (this.msgT > 0 && this.msg){
          g.fillStyle = "rgba(0,0,0,0.25)";
          g.fillRect(lx+Math.floor(lw/2)-22, ly+Math.floor(lh/2)-3, 44, 7);
          textTiny(lx+Math.floor(lw/2)-18, ly+Math.floor(lh/2)-1, this.msg);
        }

        g.restore();
      }
    };
    return G;
  })();

  const geoMorph = (() => {
    return {
      inited:false,
      nextVariant: 0,
      t: 1,
      from: [],
      target: [],
      points: [],
      visibleCount: 90,
      targetCount: 90,
      energy: 0,
      requestUpdate: true,
      init(){
        this.inited=true;
        this.nextVariant=0;
        this.t=1;
        this.from=[];
        this.target=[];
        this.points=[];
        this.visibleCount=90;
        this.targetCount=90;
        this.energy=0;
        this.requestUpdate=true;
      }
    };
  })();

  function geoShapePoint(variant, u, tt){
    const a = u * Math.PI * 2;
    if (variant === 0){ // cube wire
      const e = Math.floor(u*12);
      const f = (u*12) - e;
      const s = 1.2;
      const v = [
        [-s,-s,-s],[ s,-s,-s],[ s, s,-s],[-s, s,-s],
        [-s,-s, s],[ s,-s, s],[ s, s, s],[-s, s, s],
      ];
      const edges = [[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];
      const [i,j] = edges[e%edges.length];
      const p=v[i], q=v[j];
      return [lerp(p[0],q[0],f), lerp(p[1],q[1],f), lerp(p[2],q[2],f)];
    }
    if (variant === 1){ // tetra edges
      const v = [[0,1.3,0],[-1.2,-1.0,-0.9],[1.2,-1.0,-0.9],[0,-1.0,1.1]];
      const edges = [[0,1],[0,2],[0,3],[1,2],[2,3],[3,1]];
      const e = Math.floor(u*edges.length);
      const f = (u*edges.length)-e;
      const [i,j]=edges[e];
      const p=v[i], q=v[j];
      return [lerp(p[0],q[0],f), lerp(p[1],q[1],f), lerp(p[2],q[2],f)];
    }
    if (variant === 2){ // sphere
      const th = a;
      const ph = Math.acos(lerp(-1,1,(u*0.97 + 0.015)%1));
      const r = 1.25;
      return [r*Math.sin(ph)*Math.cos(th), r*Math.cos(ph), r*Math.sin(ph)*Math.sin(th)];
    }
    if (variant === 3){ // torus
      const R=1.15, r=0.45;
      const b = a*1.3 + tt*0.4;
      const x = (R + r*Math.cos(b))*Math.cos(a);
      const y = r*Math.sin(b);
      const z = (R + r*Math.cos(b))*Math.sin(a);
      return [x, y, z];
    }
    if (variant === 4){ // cone spiral
      const z = lerp(-1.2, 1.2, u);
      const rr = lerp(1.25, 0.15, u);
      const ang = a*2.2 + tt*0.8;
      return [Math.cos(ang)*rr, Math.sin(ang)*rr*0.7, z];
    }
    if (variant === 5){ // prism loop
      const k = a;
      const x = Math.sign(Math.cos(k)) * (0.9 + 0.3*Math.cos(3*k));
      const y = Math.sign(Math.sin(k)) * (0.7 + 0.2*Math.sin(2*k));
      const z = Math.sin(k*2 + tt*0.6)*0.9;
      return [x, y, z];
    }
    if (variant === 6){ // triple ring
      const ring = Math.floor(u*3);
      const uu = (u*3)-ring;
      const aa = uu*Math.PI*2;
      const R = 1.2;
      if (ring===0) return [Math.cos(aa)*R, Math.sin(aa)*0.8, 0];
      if (ring===1) return [Math.cos(aa)*R, 0, Math.sin(aa)*0.8];
      return [0, Math.cos(aa)*R, Math.sin(aa)*0.8];
    }
    if (variant === 7){ // double helix
      const z = lerp(-1.2, 1.2, u);
      const ang = a*2.4 + tt*1.1;
      const x = Math.cos(ang)*1.0;
      const y = Math.sin(ang)*0.7;
      const off = (u<0.5?1:-1)*0.25;
      return [x+off, y, z];
    }
    if (variant === 8){ // atom rings
      const ring = Math.floor(u*3);
      const uu = (u*3)-ring;
      const aa = uu*Math.PI*2;
      const R = 1.25;
      if (ring===0) return [Math.cos(aa)*R, Math.sin(aa)*0.65, 0];
      if (ring===1) return [Math.cos(aa)*R, 0, Math.sin(aa)*0.65];
      return [0, Math.cos(aa)*R, Math.sin(aa)*0.65];
    }
    // trefoil knot
    const x = (Math.sin(a) + 2*Math.sin(2*a)) * 0.6;
    const y = (Math.cos(a) - 2*Math.cos(2*a)) * 0.35;
    const z = (-Math.sin(3*a)) * 0.55;
    return [x, y, z];
  }

  function geoBuildTarget(variant, count, tt){
    const pts = new Array(count);
    for (let i=0;i<count;i++){
      const u = i / count;
      const p = geoShapePoint(variant, u, tt);
      const j = 0.06*Math.sin((i*17.13) + tt*1.7);
      pts[i] = {x:p[0] + j, y:p[1] - j*0.7, z:p[2] + j*0.5, a:1};
    }
    return pts;
  }

  function onStep(step){
    const cats = {};
    for (const c of CATS) cats[c]=0;

    let hits=0, acc=0;
    for (let r=0;r<ROWS;r++){
      const st = state.pattern[r][step];
      if (st){
        cats[CATS[r]] = Math.max(cats[CATS[r]], st);
        hits++;
        if (st===3) acc++;
      }
    }

    // visual trigger envelope
    vis.pulse = 1.0;
    vis.energy = clamp(vis.energy + 0.15 + 0.12*acc, 0, 1.7);
    for (const c of CATS){
      vis.trig[c] = Math.max(vis.trig[c], cats[c]/3);
    }

    // drive arcade scene and geometry
    game.onStep({step, cats, hits, acc});
    geoMorph.energy = Math.max(geoMorph.energy, 0.25 + 0.15*acc + 0.08*hits);
    if (acc) geoMorph.requestUpdate = true;
  }


  function patternDistribution(){
    const dist = {};
    for (const c of CATS) dist[c]=0;
    for (let r=0;r<ROWS;r++){
      for (let s=0;s<STEPS;s++){
        dist[CATS[r]] += (state.pattern[r][s] ? 1 : 0);
      }
    }
    return dist;
  }

  function updateFighters(){
    const dist = patternDistribution();
    const total = Object.values(dist).reduce((a,b)=>a+b,0) || 1;

    // desired fighter count based on density
    const desired = clamp(Math.round(4 + (total/ (ROWS*STEPS)) * 10), 4, 14);
    while (fighters.length < desired){
      fighters.push(makeFighter());
    }
    while (fighters.length > desired){
      fighters.pop();
    }

    // assign archetypes based on distribution
    const weights = [
      ["KICK", dist["KICK"]],
      ["SNARE", dist["SNARE"]],
      ["HAT", dist["HAT"]],
      ["CLAP", dist["CLAP"]],
      ["BASS", dist["BASS"]],
      ["PERC/FX", dist["PERC/FX"]],
    ].sort((a,b)=>b[1]-a[1]);

    fighters.forEach((f,i) => {
      const t = weights[i % weights.length][0];
      f.type = t;
      // adjust size/speed by type
      f.size = (t==="KICK"||t==="BASS") ? 6 : (t==="SNARE"||t==="CLAP") ? 5 : 4;
      f.speed = (t==="HAT") ? 1.5 : (t==="PERC/FX") ? 1.25 : 1.0;
      f.hp = clamp(8 + Math.floor(dist[t]/2), 6, 18);
    });
  }

  function makeFighter(){
    return {
      x: Math.random()*150+5,
      y: Math.random()*60+18,
      vx: (Math.random()<0.5?-1:1)*(0.6+Math.random()*0.6),
      dir: 1,
      size: 5,
      speed: 1,
      hp: 10,
      cool: 0,
      type: "PERC/FX"
    };
  }

  function rmsFromAnalyser(){
    if (!analyser) return 0;
    const arr = new Uint8Array(analyser.fftSize);
    analyser.getByteTimeDomainData(arr);
    let sum=0;
    for (let i=0;i<arr.length;i++){
      const v = (arr[i]-128)/128;
      sum += v*v;
    }
    return Math.sqrt(sum/arr.length);
  }

  
  function drawFighters(dt){
    const g = offFightCtx;
    const w = offFight.width, h = offFight.height;
    g.clearRect(0,0,w,h);

    // ---------- Pocket-operator-ish LCD frame ----------
    g.fillStyle = "#050607";
    g.fillRect(0,0,w,h);

    const lx = 6, ly = 9, lw = w-12, lh = h-18;

    // bezel
    g.fillStyle = "#0b0d10";
    g.fillRect(lx-2, ly-2, lw+4, lh+4);

    // LCD screen
    g.fillStyle = "#cfd4d6";
    g.fillRect(lx, ly, lw, lh);

    // subtle dithering/noise (stable-ish)
    const t = now();
    g.fillStyle = "rgba(0,0,0,0.04)";
    for (let i=0;i<90;i++){
      const nx = lx + ((i*19 + Math.floor(t/50)) % lw);
      const ny = ly + ((i*11 + Math.floor(t/70)) % lh);
      g.fillRect(nx, ny, 1, 1);
    }

    // top "UI" ticks (PO-style decoration)
    g.fillStyle = "rgba(0,0,0,0.25)";
    for (let i=0;i<lw;i+=6){
      g.fillRect(lx+i, ly+3, 2, 1);
    }

    const amp = rmsFromAnalyser();

    // Run "arcade" scene inside LCD (level progression + aliens + combat)
    game.tick(dt, lx, ly, lw, lh, amp);
    game.render(g, lx, ly, lw, lh);

    // scanlines (very subtle)
    g.fillStyle = "rgba(0,0,0,0.03)";
    for (let y=ly; y<ly+lh; y+=3){
      g.fillRect(lx, y, lw, 1);
    }

    // scale to main canvas with pixelated look
    ctxFight.imageSmoothingEnabled = false;
    ctxFight.clearRect(0,0,cvFight.width,cvFight.height);
    ctxFight.drawImage(offFight, 0, 0, cvFight.width, cvFight.height);
  }


  
  function drawGeo(dt){
    const g = offGeoCtx;
    const w = offGeo.width, h = offGeo.height;
    g.clearRect(0,0,w,h);

    // background
    g.fillStyle = "#050607";
    g.fillRect(0,0,w,h);

    if (!geoMorph.inited) geoMorph.init();

    const dist = patternDistribution();
    const total = Object.values(dist).reduce((a,b)=>a+b,0);
    const density = clamp(total/(ROWS*STEPS), 0, 1);
    const lead = Object.entries(dist).sort((a,b)=>b[1]-a[1])[0]?.[0] || "PERC/FX";
    const leadIdx = Math.max(0, CATS.indexOf(lead));
    const amp = rmsFromAnalyser();

    // variant changes with smoothing; no hard switch
    const tt = now()/1000;
    const desiredVariant = (Math.floor(now()/1600) + leadIdx) % 10;

    // point count grows/shrinks smoothly with density + beat energy
    const desiredCount = clamp(Math.round(70 + density*80 + geoMorph.energy*18), 55, 160);

    // start a new morph when variant changes or when target count drifts
    const needNew =
      geoMorph.requestUpdate ||
      (geoMorph.target.length === 0) ||
      (desiredVariant !== geoMorph.nextVariant) ||
      (Math.abs(desiredCount - geoMorph.targetCount) > 10);

    if (needNew){
      geoMorph.requestUpdate = false;
      geoMorph.t = 0;
      geoMorph.from = geoMorph.points.length ? geoMorph.points.map(p => ({x:p.x,y:p.y,z:p.z,a:p.a})) : [];
      geoMorph.nextVariant = desiredVariant;
      geoMorph.targetCount = desiredCount;
      geoMorph.target = geoBuildTarget(desiredVariant, desiredCount, tt);
      if (!geoMorph.visibleCount) geoMorph.visibleCount = desiredCount;
    }

    // morph progress
    const speed = 700 / (1 + Math.min(1.2, geoMorph.energy)*0.9);
    geoMorph.t = clamp(geoMorph.t + dt / speed, 0, 1);
    const e = easeInOut(geoMorph.t);

    // smoothly change visible point count so points "grow in"
    geoMorph.visibleCount = approach(geoMorph.visibleCount, geoMorph.targetCount, dt*0.08);

    const vc = Math.max(1, Math.floor(geoMorph.visibleCount));
    const fromN = geoMorph.from.length || 1;
    const tgtN = geoMorph.target.length || 1;

    // update current points array
    if (geoMorph.points.length < vc){
      while (geoMorph.points.length < vc){
        geoMorph.points.push({x:0,y:0,z:0,a:0});
      }
    } else if (geoMorph.points.length > vc){
      geoMorph.points.length = vc;
    }

    for (let i=0;i<vc;i++){
      const fp = geoMorph.from.length ? geoMorph.from[i % fromN] : {x:0,y:0,z:0,a:0};
      const tp = geoMorph.target[i % tgtN] || {x:0,y:0,z:0,a:1};
      const px = lerp(fp.x, tp.x, e);
      const py = lerp(fp.y, tp.y, e);
      const pz = lerp(fp.z, tp.z, e);
      const pa = lerp(fp.a ?? 1, 1, e);
      geoMorph.points[i].x = px;
      geoMorph.points[i].y = py;
      geoMorph.points[i].z = pz;
      // fade-in/out (gives "points increasing" feel)
      geoMorph.points[i].a = clamp(pa * (i < geoMorph.visibleCount ? 1 : 0), 0, 1);
    }

    // rotation + mild warp
    geoRot += dt*0.0012*(1 + amp*7);
    geoMorph.energy = Math.max(0, geoMorph.energy*0.92 - dt*0.00025);

    function project(p){
      const z = p[2] + 3.6;
      const s = 62 / z;
      return [w/2 + p[0]*s, h/2 + p[1]*s];
    }
    function rotY(p, a){
      const [x,y,z] = p;
      const ca=Math.cos(a), sa=Math.sin(a);
      return [x*ca + z*sa, y, -x*sa + z*ca];
    }
    function rotX(p, a){
      const [x,y,z] = p;
      const ca=Math.cos(a), sa=Math.sin(a);
      return [x, y*ca - z*sa, y*sa + z*ca];
    }

    const warp = 1 + amp*0.55 + geoMorph.energy*0.12;
    const pts2 = new Array(vc);

    for (let i=0;i<vc;i++){
      const p = geoMorph.points[i];
      let v = [p.x*warp, p.y*warp, p.z];
      v = rotY(v, geoRot);
      v = rotX(v, geoRot*0.83);
      pts2[i] = project(v);
    }

    // draw lines (soft, continuous)
    g.strokeStyle = "rgba(34,61,92,0.65)";
    g.lineWidth = 1;
    g.beginPath();
    for (let i=0;i<vc-1;i++){
      const a = pts2[i], b = pts2[i+1];
      g.moveTo(a[0], a[1]);
      g.lineTo(b[0], b[1]);
      if (i % 7 === 0 && i+13 < vc){
        const c = pts2[i+13];
        g.moveTo(a[0], a[1]);
        g.lineTo(c[0], c[1]);
      }
    }
    g.stroke();

    // points
    g.fillStyle = "rgba(231,231,231,0.42)";
    for (let i=0;i<vc;i++){
      const p = pts2[i];
      g.fillRect(Math.round(p[0]), Math.round(p[1]), 1, 1);
    }

    // subtle ghost trail (keeps it "silky")
    if (amp > 0.010){
      g.fillStyle = `rgba(231,231,231,${clamp(amp*2.2, 0, 0.12)})`;
      for (let i=0;i<vc;i+=3){
        const p = pts2[i];
        g.fillRect(Math.round(p[0])+1, Math.round(p[1]), 1, 1);
      }
    }

    ctxGeo.imageSmoothingEnabled = false;
    ctxGeo.clearRect(0,0,cvGeo.width,cvGeo.height);
    ctxGeo.drawImage(offGeo, 0, 0, cvGeo.width, cvGeo.height);
  }


  function updateVisualDistribution(){
    updateFighters();
    // keep visuals in sync with pattern edits
    try{ game.recalc(); }catch(e){}
    geoMorph.requestUpdate = true;
  }

  let lastFrame = now();
  function animLoop(){
    const t = now();
    const dt = t - lastFrame;
    lastFrame = t;

    if (state.isPlaying){
      // update playing column indicator
      const stepDur = (60/state.bpm)/4;
      const rel = audioCtx ? (audioCtx.currentTime - (state.nextNoteTime - stepDur*(state.currentStep))) : 0;
      // Use modulo time tracking with currentStep already advanced; fallback via currentStep-1.
      const displayStep = (state.currentStep - 1 + STEPS) % STEPS;
      setPlayingColumn(displayStep);

      // step-triggered visuals (game/geo) — avoids "just bobbing"
      if (displayStep !== state.visual.lastStep){
        state.visual.lastStep = displayStep;
        onStep(displayStep);
      }
    }

    drawFighters(dt);
    drawGeo(dt);

    // decay envelopes for smooth motion
    vis.pulse *= 0.88;
    vis.energy *= 0.90;
    for (const c of CATS) vis.trig[c] *= 0.86;

    requestAnimationFrame(animLoop);
  }

  // ---------- Recording / Export ----------
  async function toggleRecord(){
    await ensureAudio();
    if (audioCtx.state !== "running") await audioCtx.resume();

    if (!state.record.isRecording){
      // Create stream destination once
      if (!state.record.streamDest){
        state.record.streamDest = audioCtx.createMediaStreamDestination();
        master.connect(state.record.streamDest);
      }
      const rec = new MediaRecorder(state.record.streamDest.stream, {mimeType: "audio/webm"});
      state.record.rec = rec;
      state.record.chunks = [];
      rec.ondataavailable = (e) => { if (e.data && e.data.size) state.record.chunks.push(e.data); };
      rec.onstop = () => {
        const blob = new Blob(state.record.chunks, {type:"audio/webm"});
        downloadBlob(blob, `tcseq_record_${Date.now()}.webm`);
        state.record.chunks = [];
      };
      rec.start();
      state.record.isRecording = true;
      $("btnRecord").textContent = "RECORDING…";
      setStatus("record", "audio/webm");
      toast("Recording started (WEBM). Click RECORD again to stop.");
    } else {
      state.record.isRecording = false;
      $("btnRecord").textContent = "RECORD";
      try{ state.record.rec.stop(); }catch(e){}
      setStatus("record", "stopped");
      toast("Recording saved.");
    }
  }

  function downloadBlob(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 5000);
  }

  function audioBufferToWav(ab, normalize){
    // 16-bit PCM WAV
    const numCh = ab.numberOfChannels;
    const sr = ab.sampleRate;
    const len = ab.length;

    // interleave
    const interleaved = new Float32Array(len * numCh);
    let max = 0;
    for (let ch=0; ch<numCh; ch++){
      const data = ab.getChannelData(ch);
      for (let i=0; i<len; i++){
        const v = data[i];
        max = Math.max(max, Math.abs(v));
        interleaved[i*numCh + ch] = v;
      }
    }
    let gain = 1;
    if (normalize && max > 1e-9) gain = 0.98 / max;

    const bytesPerSample = 2;
    const blockAlign = numCh * bytesPerSample;
    const byteRate = sr * blockAlign;
    const dataSize = len * blockAlign;

    const buf = new ArrayBuffer(44 + dataSize);
    const view = new DataView(buf);

    function writeStr(off, s){
      for (let i=0;i<s.length;i++) view.setUint8(off+i, s.charCodeAt(i));
    }

    writeStr(0, "RIFF");
    view.setUint32(4, 36 + dataSize, true);
    writeStr(8, "WAVE");
    writeStr(12, "fmt ");
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, numCh, true);
    view.setUint32(24, sr, true);
    view.setUint32(28, byteRate, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, 16, true);
    writeStr(36, "data");
    view.setUint32(40, dataSize, true);

    let offset = 44;
    for (let i=0; i<interleaved.length; i++){
      let v = clamp(interleaved[i]*gain, -1, 1);
      view.setInt16(offset, v < 0 ? v*0x8000 : v*0x7FFF, true);
      offset += 2;
    }
    return new Blob([buf], {type:"audio/wav"});
  }

  async function offlineRenderToBuffer(sampleRate, bars){
    // Offline render current pattern (uses decoded buffers only)
    const spb = 60 / state.bpm;
    const stepDur = spb / 4;
    const barDur = stepDur * STEPS;
    const duration = barDur * bars;

    const length = Math.ceil(duration * sampleRate);
    const oac = new OfflineAudioContext(2, length, sampleRate);
    const out = oac.createGain();
    out.gain.value = 0.9;
    out.connect(oac.destination);

    function scheduleBuf(buf, time, vel){
      // mix stereo: use buffer channel count
      const src = oac.createBufferSource();
      src.buffer = buf;
      const g = oac.createGain();
      g.gain.setValueAtTime(0.0001, time);
      g.gain.linearRampToValueAtTime(vel, time + 0.006);
      g.gain.linearRampToValueAtTime(0.0001, time + Math.min(0.18, buf.duration));
      src.connect(g);
      g.connect(out);
      src.start(time);
    }

    // Ensure we have at least one buffer per category, else skip
    const pool = {};
    for (const c of CATS) pool[c] = state.files.filter(f => f.buffer && f.category === c).map(f => f.buffer);
    const any = state.files.filter(f => f.buffer).map(f => f.buffer);

    for (let bar=0; bar<bars; bar++){
      const baseT = bar*barDur;
      for (let step=0; step<STEPS; step++){
        const t = baseT + step*stepDur;
        for (let r=0;r<ROWS;r++){
          const st = state.pattern[r][step];
          if (!st) continue;
          const vel = velocityFromState(st);
          const cat = CATS[r];
          const list = pool[cat];
          const buf = (list && list.length) ? list[Math.floor(Math.random()*list.length)]
                    : (any.length ? any[Math.floor(Math.random()*any.length)] : null);
          if (buf) scheduleBuf(buf, t, vel);
        }
      }
    }

    const rendered = await oac.startRendering();
    return rendered;
  }

  function openExportModal(){
    $("modalBackdrop").style.display = "flex";
  }
  function closeExportModal(){
    $("modalBackdrop").style.display = "none";
  }

  async function exportNow(){
    closeExportModal();
    const fmt = $("exportFormat").value;
    const sr = Number($("exportSR").value);
    const bars = Number($("exportBars").value);
    const norm = $("exportNorm").value === "1";

    if (state.files.filter(f => f.buffer).length === 0){
      toast("Nothing decoded yet. Load files and run ANALYZE+GENERATE first.");
      return;
    }

    if (fmt === "wav"){
      setStatus("export", "offline rendering…");
      const rendered = await offlineRenderToBuffer(sr, bars);
      const blob = audioBufferToWav(rendered, norm);
      downloadBlob(blob, `tcseq_${state.bpm}bpm_${bars}bars_${sr}hz.wav`);
      setStatus("export", "done");
      toast("WAV exported.");
      return;
    }

    if (fmt === "webm"){
      // Real-time export: arm recorder, play for bars, stop.
      await ensureAudio();
      if (audioCtx.state !== "running") await audioCtx.resume();

      if (state.record.isRecording){
        toast("Stop current recording first.");
        return;
      }
      // Start recording
      await toggleRecord();
      // Ensure transport playing
      if (!state.isPlaying) startTransport();

      const spb = 60/state.bpm;
      const barDur = (spb*4);
      const ms = barDur*bars*1000;
      toast(`Recording ${bars} bar(s) …`);
      setTimeout(async () => {
        // stop record (leaves transport running)
        if (state.record.isRecording) await toggleRecord();
        setStatus("export", "webm done");
      }, ms);
      return;
    }

    toast("MP3 export disabled (encoder not included).");
  }

  // ---------- Analyze+Generate button ----------
  async function analyzeAndGenerate(){
    if (state.files.length === 0){
      toast("Load audio files first.");
      return;
    }
    await ensureAudio();
    if (audioCtx.state !== "running") await audioCtx.resume();

    setStatus("analyze", "decoding + classifying…");

    // Decode any missing buffers (cap 200 files as spec)
    const cap = 200;
    if (state.files.length > cap){
      toast(`Loaded ${state.files.length} files; only first ${cap} will be used.`);
    }

    for (let i=0;i<Math.min(state.files.length, cap);i++){
      const f = state.files[i];
      if (!f.buffer){
        try{
          f.buffer = await decodeFile(f.file);
        } catch (e){
          console.warn(e);
          state.debug.lines.push(`[decode fail] ${f.name}: ${String(e)}`);
        }
      }
      if (f.buffer && !f.features){
        f.features = extractFeatures(f.buffer);
        if (!f.override){
          f.autoCategory = classify(f.features);
          f.category = f.autoCategory;
        }
      }
    }

    renderFileList();

    // Generate default pattern tuned to the distribution
    const dist = {};
    for (const c of CATS) dist[c] = 0;
    for (const f of state.files){
      if (f.buffer && f.category) dist[f.category] = (dist[f.category]||0)+1;
    }

    // Choose style from UI, but bias density by number of hats/percs
    const style = $("styleMode").value;
    const density = Number($("density").value);
    const seed = (Date.now() ^ 0x9E3779B9) >>> 0;
    const rng = mulberry32(seed);

    generateBase(style, rng);

    // push a little more hats/percs if they exist
    const hatBoost = clamp(dist["HAT"]/Math.max(1,state.files.length), 0, 1);
    const dens2 = clamp(Math.round(density + hatBoost*18), 0, 100);
    applyDensity(dens2, rng, style);

    renderGrid();
    updateVisualDistribution();

    setStatus("ready", `classified ${state.files.filter(f=>f.buffer).length} file(s)`);
    toast("Analyze+Generate complete. Click filenames to preview; click class labels to correct.");
  }

  // ---------- Load/Clear ----------
  async function loadFiles(){
    const preferFSA = ("showOpenFilePicker" in window);
    let files = [];
    try{
      if (preferFSA){
        const handles = await window.showOpenFilePicker({
          multiple: true,
          types: [{ description: "Audio", accept: { "audio/*": [".wav",".mp3",".aif",".aiff",".ogg",".m4a",".flac"] } }]
        });
        for (const h of handles){
          const file = await h.getFile();
          files.push(file);
        }
      } else {
        $("fileInput").click();
        return;
      }
    } catch (e){
      // user cancelled
      return;
    }

    addFiles(files);
  }

  function addFiles(files){
    if (!files || !files.length) return;
    const current = state.files.length;
    const cap = 200;
    const room = cap - current;
    const take = files.slice(0, Math.max(0, room));

    if (take.length < files.length){
      toast(`File cap is ${cap}. Extra files were ignored.`);
    }

    for (const file of take){
      state.files.push({
        id: cryptoRandomId(),
        name: file.name,
        file,
        buffer: null,
        features: null,
        autoCategory: null,
        category: null,
        override: false
      });
    }
    if (state.selectedFileIndex < 0 && state.files.length) state.selectedFileIndex = 0;
    renderFileList();
    setStatus("loaded", `${state.files.length} file(s)`);
  }

  function clearAll(){
    stopTransport();
    state.files = [];
    state.selectedFileIndex = -1;
    resetPattern();
    renderFileList();
    setStatus("cleared", "");
  }

  function cryptoRandomId(){
    if (crypto && crypto.getRandomValues){
      const a = new Uint32Array(2);
      crypto.getRandomValues(a);
      return (a[0].toString(16)+a[1].toString(16));
    }
    return String(Math.random()).slice(2);
  }

  // ---------- Debug ----------
  function toggleDebug(){
    state.debug.on = !state.debug.on;
    if (state.debug.on){
      toast("Debug ON. Open console for logs.");
      console.log("[TCSEQ debug] state:", state);
    } else {
      toast("Debug OFF.");
    }
  }

  // ---------- Help ----------
  function showHelp(){
    toast("Workflow: LOAD FILES → ANALYZE+GENERATE → RANDOM PATTERN (optional) → PLAY. Click filename to preview; click class to correct. EXPORT renders audio.");
  }

  // ---------- Wiring ----------
  $("btnLoad").addEventListener("click", loadFiles);
  $("fileInput").addEventListener("change", (e) => {
    addFiles(Array.from(e.target.files || []));
    e.target.value = "";
  });
  $("btnClear").addEventListener("click", clearAll);

  $("btnAnalyzeGenerate").addEventListener("click", analyzeAndGenerate);

  $("btnPlay").addEventListener("click", async () => {
    await ensureAudio();
    if (audioCtx.state !== "running") await audioCtx.resume();
    if (!state.isPlaying) startTransport();
  });

  $("btnStop").addEventListener("click", () => stopTransport());
  $("btnRecord").addEventListener("click", toggleRecord);
  $("btnExport").addEventListener("click", openExportModal);
  $("btnHidePanel").addEventListener("click", () => {
    $("app").classList.toggle("hidden-left");
  });
  $("btnDebug").addEventListener("click", toggleDebug);
  $("btnHelp").addEventListener("click", showHelp);

  $("btnRandom").addEventListener("click", () => {
    // Fix: randomize does not touch running nodes; safe during playback (no click)
    randomizePattern();
  });
  $("btnResetGrid").addEventListener("click", resetPattern);

  $("viewMode").addEventListener("change", (e) => {
    state.viewMode = e.target.value;
    setPlayingColumn(-1);
  });

  $("modalBackdrop").addEventListener("click", (e) => {
    if (e.target === $("modalBackdrop")) closeExportModal();
  });
  $("btnExportCancel").addEventListener("click", closeExportModal);
  $("btnExportGo").addEventListener("click", exportNow);

  // Keyboard in file list
  fileListEl.addEventListener("keydown", async (e) => {
    if (state.files.length === 0) return;

    const max = state.files.length - 1;
    if (e.key === "ArrowDown"){
      e.preventDefault();
      state.selectedFileIndex = clamp(state.selectedFileIndex + 1, 0, max);
      renderFileList();
      scrollSelectedIntoView();
    }
    if (e.key === "ArrowUp"){
      e.preventDefault();
      state.selectedFileIndex = clamp(state.selectedFileIndex - 1, 0, max);
      renderFileList();
      scrollSelectedIntoView();
    }
    if (e.key === "Enter"){
      e.preventDefault();
      await previewFile(state.selectedFileIndex);
    }
    // 1-6 sets category quickly
    if (/^[1-6]$/.test(e.key)){
      const idx = Number(e.key) - 1;
      const cat = CATS[idx];
      const f = state.files[state.selectedFileIndex];
      if (f){
        f.category = cat;
        f.override = true;
        renderFileList();
        updateVisualDistribution();
        toast(`Set class: ${cat}`);
      }
    }
  });

  function scrollSelectedIntoView(){
    const sel = fileListEl.querySelector(".fileitem.selected");
    if (sel) sel.scrollIntoView({block:"nearest"});
  }

  // Startup render
  renderHeader();
  renderGrid();
  renderFileList();
  updateVisualDistribution();
  setStatus("ready", "load up to 200 files");

  requestAnimationFrame(animLoop);
})();
</script>
</body>
</html>
