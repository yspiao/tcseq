<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>TCSEQ</title>
  <style>
    :root{
      --bg:#070707;
      --panel:#0f1114;
      --panel2:#0b0d10;
      --line:#2b2f36;
      --line2:#1e2229;
      --text:#e7e7e7;
      --muted:#a6a6a6;
      --muted2:#7a7a7a;
      --accent:#1a2a3d; /* deep blue, kept subtle */
      --accent2:#111820;
      --danger:#d04b4b;
      --ok:#6bd06b;
      --font: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family:var(--font);
      letter-spacing:0.2px;
    }
    button, select, input{
      font-family:var(--font);
      background:transparent;
      color:var(--text);
      border:1px solid var(--line);
      padding:6px 10px;
      font-size:12px;
      line-height:1;
      outline:none;
    }
    button{
      cursor:pointer;
      user-select:none;
    }
    button:hover, select:hover{border-color:#3b414a}
    button:active{transform:translateY(1px)}
    button.primary{
      border-color:#3b4655;
      background:var(--accent2);
    }
    button.primary:hover{background:var(--accent)}
    button.ghost{
      border-color:var(--line2);
      color:var(--muted);
    }
    button.ghost:hover{border-color:var(--line)}
    button.danger{border-color:rgba(208,75,75,.55); color:#ffd1d1}
    button[disabled], select[disabled]{opacity:.45; cursor:not-allowed}
    .app{
      height:100%;
      display:flex;
      flex-direction:column;
    }
    /* Top bar (no boxed TCSEQ) */
    .topbar{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      border-bottom:1px solid var(--line2);
      background:#050505;
    }
    .brand{
      font-size:14px;
      letter-spacing:2px;
      margin-right:auto;
      color:#efefef;
      user-select:none;
    }
    .topbar .cluster{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .mini{
      font-size:11px;
      color:var(--muted);
      border:1px solid var(--line2);
      padding:5px 8px;
    }
    /* Main layout */
    .main{
      flex:1;
      min-height:0;
      display:grid;
      grid-template-columns: 340px 1fr;
      gap:10px;
      padding:10px;
    }
    .panel{
      border:1px solid var(--line2);
      background:var(--panel);
      min-height:0;
    }
    .left{
      display:flex;
      flex-direction:column;
      min-height:0;
      gap:10px;
    }
    .left .panel{padding:10px}
    .panel-title{
      font-size:12px;
      color:var(--muted);
      letter-spacing:1px;
      margin:0 0 8px 0;
      display:flex;
      align-items:center;
      justify-content:space-between;
    }
    .row{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .control-row{
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .control-row .leftbtns, .control-row .rightbtns{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .filelist{
      border:1px solid var(--line2);
      background:var(--panel2);
      padding:6px;
      height:240px;
      overflow:auto;
    }
    .fileitem{
      display:grid;
      grid-template-columns: 1fr 92px;
      gap:8px;
      padding:6px 6px;
      border-bottom:1px solid rgba(255,255,255,0.04);
      align-items:center;
    }
    .fileitem:last-child{border-bottom:none}
    .fname{
      cursor:pointer;
      color:#eaeaea;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      padding:2px 0;
    }
    .fname:hover{color:#ffffff; text-decoration:underline}
    .cat{
      justify-self:end;
      text-align:right;
      color:var(--muted);
      cursor:pointer;
      padding:2px 6px;
      border:1px solid var(--line2);
      background:#0a0c10;
      user-select:none;
    }
    .cat:hover{border-color:var(--line)}
    .fileitem.selected{
      background:rgba(26,42,61,.25);
      outline:1px solid rgba(255,255,255,0.06);
    }
    .hint{
      color:var(--muted2);
      font-size:11px;
      line-height:1.3;
      margin-top:8px;
    }

    /* Sequencer + right visuals */
    .work{
      display:flex;
      flex-direction:column;
      min-height:0;
      gap:10px;
    }
    .seqwrap{
      display:grid;
      grid-template-columns: 1fr 360px;
      gap:10px;
      min-height:0;
    }
    .sequencer{
      padding:10px;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .seq-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      margin-bottom:8px;
    }
    .seq-head .leftmeta{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      color:var(--muted);
      font-size:11px;
    }
    .seq-head .rightmeta{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-end;
    }
    .gridwrap{
      border:1px solid var(--line2);
      background:var(--panel2);
      padding:8px;
      overflow:auto;
      min-height:0;
    }
    .legend{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      align-items:center;
      color:var(--muted);
      font-size:11px;
      margin-bottom:8px;
      user-select:none;
    }
    .legend .sw{
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .swbox{
      width:10px;height:10px;
      border:1px solid var(--line2);
      background:#050607;
    }
    .swbox.ghost{background:#0b111a}
    .swbox.hit{background:#162437}
    .swbox.acc{background:#223d5c}
    .grid{
      display:grid;
      grid-template-columns: 90px repeat(16, 16px);
      gap:6px;
      align-items:center;
    }
    .rlabel{
      color:var(--muted);
      font-size:11px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      padding-right:4px;
    }
    .step{
      width:16px;height:16px;
      border:1px solid var(--line2);
      background:#050607;
      cursor:pointer;
      position:relative;
      user-select:none;
    }
    .step:hover{border-color:var(--line)}
    .step[data-state="1"]{background:#0b111a}
    .step[data-state="2"]{background:#162437}
    .step[data-state="3"]{background:#223d5c}
    .step.playing::after{
      content:"";
      position:absolute; inset:-2px;
      border:1px solid rgba(255,255,255,0.25);
      pointer-events:none;
    }
    .steps-header{
      display:grid;
      grid-template-columns: 90px repeat(16, 16px);
      gap:6px;
      margin-bottom:6px;
      align-items:center;
      color:var(--muted);
      font-size:10px;
      user-select:none;
    }
    .steps-header .h{ text-align:center; }
    .vispanel{
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .vis{
      border:1px solid var(--line2);
      background:var(--panel2);
      height:190px;
      position:relative;
      overflow:hidden;
    }
    canvas{
      width:100%;
      height:100%;
      display:block;
      image-rendering: pixelated;
    }
    .vislabel{
      position:absolute;
      top:8px; left:10px;
      font-size:11px;
      color:var(--muted);
      letter-spacing:1px;
      user-select:none;
      background:rgba(0,0,0,.25);
      padding:2px 6px;
      border:1px solid rgba(255,255,255,0.06);
    }

    /* Footer removed per spec; keep only a tiny status strip */
    .status{
      padding:6px 12px;
      border-top:1px solid var(--line2);
      color:var(--muted2);
      font-size:11px;
      background:#050505;
      display:flex;
      gap:10px;
      justify-content:space-between;
    }
    .status .right{white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:60%}

    /* Hidden panel mode */
    .hidden-left .main{
      grid-template-columns: 1fr;
    }
    .hidden-left .left{display:none}

    /* Modal */
    .modal-backdrop{
      position:fixed; inset:0;
      background:rgba(0,0,0,.72);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:50;
    }
    .modal{
      width:min(560px, 92vw);
      border:1px solid var(--line);
      background:#0b0c0f;
      padding:14px;
    }
    .modal h3{
      margin:0 0 10px 0;
      font-size:13px;
      color:#f0f0f0;
      letter-spacing:1px;
    }
    .modal .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .modal label{
      display:block;
      font-size:11px;
      color:var(--muted);
      margin-bottom:6px;
    }
    .modal .actions{
      margin-top:12px;
      display:flex;
      justify-content:flex-end;
      gap:8px;
      flex-wrap:wrap;
    }
    .kbd{
      border:1px solid var(--line2);
      padding:2px 6px;
      font-size:10px;
      color:var(--muted);
      background:#07090c;
    }
    .toast{
      position:fixed;
      left:12px;
      bottom:44px;
      border:1px solid var(--line2);
      background:#090a0d;
      padding:8px 10px;
      font-size:11px;
      color:var(--muted);
      display:none;
      z-index:60;
      max-width:min(560px, 92vw);
    }

    /* Responsive */
    @media (max-width: 980px){
      .main{grid-template-columns: 1fr; }
      .seqwrap{grid-template-columns: 1fr; }
      .vispanel{order:2}
      .sequencer{order:1}
      .filelist{height:200px}
      .vis{height:180px}
    }
  </style>
</head>
<body>
<div class="app" id="app">
  <div class="topbar">
    <div class="brand">TCSEQ</div>

    <div class="cluster">
      <button id="btnPlay" class="primary">PLAY</button>
      <button id="btnStop">STOP</button>
      <button id="btnRecord">RECORD</button>
      <button id="btnExport">EXPORT</button>
      <button id="btnHidePanel" class="ghost">HIDE PANEL</button>
      <button id="btnHelp" class="ghost">HELP</button>
    </div>
  </div>

  <div class="main">
    <div class="left">
      <div class="panel" id="controlPanel">
        <div class="panel-title">
          <span>CONTROL</span>
          <span class="mini" id="audioState">audio: idle</span>
        </div>

        <div class="control-row">
          <div class="leftbtns">
            <button id="btnLoad" class="primary">LOAD FILES</button>
            <button id="btnClear">CLEAR</button>
          </div>
          <div class="rightbtns">
            <button id="btnAnalyzeGenerate" class="primary">ANALYZE+GENERATE</button>
            <button id="btnDebug" class="ghost">DEBUG</button>
          </div>
        </div>

        <div class="filelist" id="fileList" tabindex="0" aria-label="file list"></div>

        <div class="hint">
          Click a filename to preview. Click the class label to manually correct classification.<br/>
          Keys: <span class="kbd">↑</span>/<span class="kbd">↓</span> select, <span class="kbd">Enter</span> preview, <span class="kbd">1-6</span> set class.
        </div>
      </div>
    </div>

    <div class="work">
      <div class="panel seqwrap">
        <div class="sequencer">
          <div class="panel-title">
            <span>SEQUENCER</span>
            <span class="mini" id="transport">bpm 170 • 1 bar • 16 steps</span>
          </div>

          <div class="seq-head">
            <div class="leftmeta">
              <span id="patternInfo">Pattern: 1 bar(s) // viewing BAR 1</span>
            </div>

            <div class="rightmeta">
              <label class="mini" style="display:flex; gap:8px; align-items:center;">
                VIEW
                <select id="viewMode">
                  <option value="follow">FOLLOW</option>
                  <option value="static">STATIC</option>
                </select>
              </label>

              <label class="mini" style="display:flex; gap:8px; align-items:center;">
                STYLE
                <select id="styleMode">
                  <option value="dnb">DNB</option>
                  <option value="jungle">JUNGLE</option>
                  <option value="breakbeat">BREAKBEAT</option>
                  <option value="minimal">MINIMAL</option>
                </select>
              </label>

              <label class="mini" style="display:flex; gap:8px; align-items:center;">
                DENS
                <input id="density" type="range" min="0" max="100" value="58" style="width:110px;">
              </label>

              <button id="btnRandom" class="primary">RANDOM PATTERN</button>
              <button id="btnResetGrid">RESET GRID</button>
            </div>
          </div>

          <div class="gridwrap" id="gridWrap">
            <div class="legend">
              <span class="sw"><span class="swbox"></span> empty</span>
              <span class="sw"><span class="swbox ghost"></span> ghost</span>
              <span class="sw"><span class="swbox hit"></span> hit</span>
              <span class="sw"><span class="swbox acc"></span> accent</span>
              <span>Enter = preview (selected file)</span>
            </div>

            <div class="steps-header" id="stepsHeader"></div>
            <div class="grid" id="grid"></div>
          </div>
        </div>

        <div class="vispanel">
          <div class="vis">
            <div class="vislabel">8‑BIT SCENE</div>
            <canvas id="cvFighters" width="320" height="180"></canvas>
          </div>
          <div class="vis">
            <div class="vislabel">PSEUDO‑3D GEOMETRY</div>
            <canvas id="cvGeo" width="320" height="180"></canvas>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="status">
    <div id="statusLeft">ready</div>
    <div class="right" id="statusRight"></div>
  </div>
</div>

<!-- Export modal -->
<div class="modal-backdrop" id="modalBackdrop" role="dialog" aria-modal="true" aria-labelledby="exportTitle">
  <div class="modal">
    <h3 id="exportTitle">EXPORT</h3>
    <div class="grid2">
      <div>
        <label>Format</label>
        <select id="exportFormat">
          <option value="wav">WAV (offline render)</option>
          <option value="webm">WEBM (real-time record)</option>
          <option value="mp3" disabled>MP3 (requires encoder)</option>
        </select>
      </div>
      <div>
        <label>Sample Rate</label>
        <select id="exportSR">
          <option value="44100">44100</option>
          <option value="48000" selected>48000</option>
        </select>
      </div>
      <div>
        <label>Length</label>
        <select id="exportBars">
          <option value="1">1 bar</option>
          <option value="2">2 bars</option>
          <option value="4" selected>4 bars</option>
          <option value="8">8 bars</option>
        </select>
      </div>
      <div>
        <label>Normalize</label>
        <select id="exportNorm">
          <option value="0">off</option>
          <option value="1" selected>on</option>
        </select>
      </div>
    </div>
    <div class="hint" style="margin-top:10px">
      WAV export is offline-rendered (no clicks/pops). WEBM export is recorded in real time. MP3 is disabled unless you add an encoder (e.g., lamejs).
    </div>
    <div class="actions">
      <button id="btnExportCancel">CANCEL</button>
      <button id="btnExportGo" class="primary">EXPORT NOW</button>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<input id="fileInput" type="file" accept="audio/*" multiple style="display:none"/>

<script>
(() => {
  "use strict";

  // ---------- Utilities ----------
  const $ = (id) => document.getElementById(id);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const now = () => performance.now();
  const toast = (msg, ms=2600) => {
    const t = $("toast");
    t.textContent = msg;
    t.style.display = "block";
    clearTimeout(toast._tm);
    toast._tm = setTimeout(()=>{ t.style.display="none"; }, ms);
  };

  function mulberry32(seed){
    let t = seed >>> 0;
    return function(){
      t += 0x6D2B79F5;
      let x = Math.imul(t ^ (t >>> 15), 1 | t);
      x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
      return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
    };
  }

  // ---------- State ----------
  const CATS = ["KICK","SNARE","HAT","CLAP","BASS","PERC/FX"];
  const STEPS = 16;
  const ROWS = CATS.length;

  const state = {
    files: [], // {id,name,file,buffer,category,autoCategory,features,override:boolean}
    selectedFileIndex: -1,
    pattern: Array.from({length: ROWS}, () => Array.from({length: STEPS}, () => 0)), // 0 empty,1 ghost,2 hit,3 accent
    bpm: 170,
    isPlaying: false,
    viewMode: "follow",
    scheduler: null,
    nextNoteTime: 0,
    currentStep: 0,
    lookaheadMs: 25,
    scheduleAhead: 0.12,
    activeSources: new Set(),
    previewSource: null,
    previewGain: null,
    record: {
      rec: null,
      chunks: [],
      isRecording: false,
      streamDest: null
    },
    debug: {
      on:false,
      lines: []
    }
  };

  // ---------- Audio ----------
  let audioCtx = null;
  let master = null;
  let analyser = null;

  async function ensureAudio(){
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)({latencyHint:"interactive"});
    master = audioCtx.createGain();
    master.gain.value = 0.85;
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 1024;
    master.connect(analyser);
    analyser.connect(audioCtx.destination);

    $("audioState").textContent = "audio: " + audioCtx.state;
    audioCtx.onstatechange = () => $("audioState").textContent = "audio: " + audioCtx.state;
  }

  function killAllSources(){
    for (const s of state.activeSources){
      try{ s.stop(); }catch(e){}
    }
    state.activeSources.clear();
    if (state.previewSource){
      try{ state.previewSource.stop(); }catch(e){}
      state.previewSource = null;
    }
  }

  function safeStopSource(src, when=0){
    try{ src.stop(when); }catch(e){}
  }

  // ---------- File decoding + analysis ----------
  async function decodeFile(file){
    await ensureAudio();
    const arr = await file.arrayBuffer();
    // Copy buffer to detach from file; decodeAudioData on some browsers consumes the arraybuffer.
    const copy = arr.slice(0);
    const buf = await audioCtx.decodeAudioData(copy);
    return buf;
  }

  // Cheap transient-ish + timbre features (fast, stable)
  function extractFeatures(buffer){
    const ch = buffer.getChannelData(0);
    const sr = buffer.sampleRate;
    const N = ch.length;

    // windowed energy (rough onset strength)
    const hop = 256;
    const win = 1024;
    let prevE = 0;
    let maxFlux = 0;
    let fluxSum = 0;
    let count = 0;

    // zero crossing and lowfreq energy proxy
    let zc = 0;
    for (let i=1;i<N;i++){
      if ((ch[i-1] >= 0 && ch[i] < 0) || (ch[i-1] < 0 && ch[i] >= 0)) zc++;
    }
    const zcr = zc / N;

    // Simple spectral centroid approximation via FFT on first 4096 samples (or less)
    const fftN = Math.min(4096, N);
    const frame = new Float32Array(fftN);
    for (let i=0;i<fftN;i++) frame[i] = ch[i] * (0.5 - 0.5*Math.cos(2*Math.PI*i/(fftN-1)));
    // Real FFT magnitude (naive DFT for stability; small N only)
    const bins = 128; // coarse
    let centroid = 0, magSum = 0;
    for (let k=0;k<bins;k++){
      const w = 2*Math.PI*k/fftN;
      let re=0, im=0;
      for (let n=0;n<fftN;n++){
        const ang = w*n;
        re += frame[n] * Math.cos(ang);
        im -= frame[n] * Math.sin(ang);
      }
      const mag = Math.sqrt(re*re + im*im);
      const freq = (k*sr)/fftN;
      centroid += freq * mag;
      magSum += mag;
    }
    centroid = magSum > 1e-9 ? centroid / magSum : 0;
    const centroidNorm = centroid / (sr/2);

    // onset flux over first ~1s (or shorter)
    const maxSamples = Math.min(N, sr); // 1 sec
    for (let i=0; i+win < maxSamples; i+=hop){
      let e=0;
      for (let j=0;j<win;j++){
        const v = ch[i+j];
        e += v*v;
      }
      const flux = Math.max(0, e - prevE);
      prevE = e;
      maxFlux = Math.max(maxFlux, flux);
      fluxSum += flux;
      count++;
    }
    const fluxMean = count ? (fluxSum / count) : 0;

    // low frequency ratio via single-pole lowpass
    let lp=0;
    const a = Math.exp(-2*Math.PI*160/sr);
    let lowE=0, totE=0;
    for (let i=0;i<Math.min(N, sr*0.5);i++){ // first 0.5s
      lp = a*lp + (1-a)*ch[i];
      lowE += lp*lp;
      totE += ch[i]*ch[i];
    }
    const lowRatio = totE>1e-9 ? (lowE/totE) : 0;

    // attack time: time until RMS crosses 60% of peak RMS in first 200ms
    const atkWin = Math.min(N, Math.floor(sr*0.2));
    let peak=0;
    for (let i=0;i<atkWin;i++) peak = Math.max(peak, Math.abs(ch[i]));
    const thresh = peak * 0.6;
    let atkSamp = atkWin;
    for (let i=0;i<atkWin;i++){
      if (Math.abs(ch[i]) >= thresh){ atkSamp=i; break; }
    }
    const attack = atkSamp / sr; // seconds

    return { zcr, centroidNorm, fluxMean, maxFlux, lowRatio, attack };
  }

  function classify(features){
    // Heuristics tuned for drum one-shots:
    const {zcr, centroidNorm, fluxMean, lowRatio, attack} = features;

    // hats: high centroid, high zcr, low lowRatio
    if (centroidNorm > 0.55 && zcr > 0.12 && lowRatio < 0.35) return "HAT";

    // kicks/bass: high lowRatio, low centroid
    if (lowRatio > 0.68 && centroidNorm < 0.30) return (attack < 0.015 ? "KICK" : "BASS");

    // snares/claps: mid centroid, mid zcr, moderate lowRatio
    if (centroidNorm > 0.30 && centroidNorm < 0.55){
      if (zcr > 0.10 && attack < 0.02) return "CLAP";
      return "SNARE";
    }

    // fallback
    return "PERC/FX";
  }

  // ---------- UI rendering ----------
  const fileListEl = $("fileList");
  const statusLeft = $("statusLeft");
  const statusRight = $("statusRight");

  function setStatus(left, right=""){
    statusLeft.textContent = left;
    statusRight.textContent = right;
  }

  function renderFileList(){
    fileListEl.innerHTML = "";
    state.files.forEach((f, idx) => {
      const row = document.createElement("div");
      row.className = "fileitem" + (idx === state.selectedFileIndex ? " selected" : "");
      const name = document.createElement("div");
      name.className = "fname";
      name.textContent = f.name;
      name.title = "Click to preview";
      name.addEventListener("click", async (ev) => {
        ev.stopPropagation();
        state.selectedFileIndex = idx;
        renderFileList();
        await previewFile(idx);
      });

      const cat = document.createElement("div");
      cat.className = "cat";
      cat.textContent = f.category || "—";
      cat.title = "Click to change class";
      cat.addEventListener("click", (ev) => {
        ev.stopPropagation();
        state.selectedFileIndex = idx;
        renderFileList();
        openCatMenu(cat, idx);
      });

      row.appendChild(name);
      row.appendChild(cat);
      row.addEventListener("click", () => {
        state.selectedFileIndex = idx;
        renderFileList();
      });

      fileListEl.appendChild(row);
    });

    if (state.files.length === 0){
      const empty = document.createElement("div");
      empty.style.color = "var(--muted2)";
      empty.style.fontSize = "11px";
      empty.style.padding = "8px";
      empty.textContent = "No files loaded yet.";
      fileListEl.appendChild(empty);
    }
  }

  function openCatMenu(anchorEl, fileIdx){
    // Simple in-place dropdown using a temporary select
    const f = state.files[fileIdx];
    const sel = document.createElement("select");
    sel.style.width = "100%";
    CATS.forEach(c => {
      const op = document.createElement("option");
      op.value = c; op.textContent = c;
      if (c === f.category) op.selected = true;
      sel.appendChild(op);
    });
    const wrap = anchorEl.parentElement;
    const old = anchorEl;
    wrap.replaceChild(sel, old);
    sel.focus();
    const commit = () => {
      f.category = sel.value;
      f.override = true;
      renderFileList();
      // Pattern rows do not auto-move; classification affects RANDOM PATTERN generation and visuals.
      updateVisualDistribution();
    };
    sel.addEventListener("change", commit);
    sel.addEventListener("blur", commit, {once:true});
    sel.addEventListener("keydown", (e) => {
      if (e.key === "Escape"){
        wrap.replaceChild(old, sel);
        renderFileList();
      }
      if (e.key === "Enter"){
        commit();
      }
    });
  }

  // ---------- Sequencer grid ----------
  const gridEl = $("grid");
  const headerEl = $("stepsHeader");

  function renderHeader(){
    headerEl.innerHTML = "";
    const blank = document.createElement("div");
    blank.textContent = "STEP";
    headerEl.appendChild(blank);
    for (let i=0;i<STEPS;i++){
      const h = document.createElement("div");
      h.className = "h";
      h.textContent = String(i+1);
      headerEl.appendChild(h);
    }
  }

  function renderGrid(){
    gridEl.innerHTML = "";
    for (let r=0;r<ROWS;r++){
      const lab = document.createElement("div");
      lab.className = "rlabel";
      lab.textContent = CATS[r];
      gridEl.appendChild(lab);

      for (let s=0;s<STEPS;s++){
        const cell = document.createElement("div");
        cell.className = "step";
        cell.dataset.r = String(r);
        cell.dataset.s = String(s);
        cell.dataset.state = String(state.pattern[r][s]);
        cell.addEventListener("click", (ev) => {
          ev.preventDefault();
          const cur = state.pattern[r][s];
          const next = (cur + 1) % 4;
          state.pattern[r][s] = next;
          cell.dataset.state = String(next);
          updateVisualDistribution();
        });
        gridEl.appendChild(cell);
      }
    }
  }

  function setPlayingColumn(step){
    const cells = gridEl.querySelectorAll(".step");
    cells.forEach(c => c.classList.remove("playing"));
    if (state.viewMode !== "follow") return;
    for (const c of cells){
      if (Number(c.dataset.s) === step) c.classList.add("playing");
    }
  }

  // ---------- Preview ----------
  async function previewFile(idx){
    const f = state.files[idx];
    if (!f) return;
    await ensureAudio();
    if (audioCtx.state !== "running"){
      await audioCtx.resume();
    }

    // stop previous preview only (do not touch transport)
    if (state.previewSource){
      safeStopSource(state.previewSource);
      state.previewSource = null;
    }

    // if buffer not decoded, decode
    if (!f.buffer){
      setStatus("decoding…", f.name);
      f.buffer = await decodeFile(f.file);
    }

    const src = audioCtx.createBufferSource();
    src.buffer = f.buffer;
    const g = audioCtx.createGain();
    const t0 = audioCtx.currentTime;
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.linearRampToValueAtTime(0.65, t0+0.01);
    g.gain.linearRampToValueAtTime(0.0001, t0+Math.min(0.35, f.buffer.duration));
    src.connect(g);
    g.connect(master);

    src.start();
    state.previewSource = src;
    state.previewGain = g;

    setStatus("preview", `${f.name}  •  ${f.category || "—"}`);
    src.onended = () => {
      if (state.previewSource === src){
        state.previewSource = null;
      }
    };
  }

  // ---------- Transport scheduling ----------
  function stepToTime(stepIndex){
    const spb = 60 / state.bpm;
    const stepDur = spb / 4; // 16 steps per 4/4 bar (1/16)
    return stepIndex * stepDur;
  }

  function velocityFromState(st){
    if (st === 1) return 0.25;
    if (st === 2) return 0.55;
    if (st === 3) return 0.85;
    return 0.0;
  }

  function pickBufferForCat(cat){
    // choose a buffer from files with matching category; fallback any.
    const list = state.files.filter(f => f.buffer && f.category === cat);
    if (list.length) return list[Math.floor(Math.random()*list.length)].buffer;
    const any = state.files.filter(f => f.buffer);
    if (any.length) return any[Math.floor(Math.random()*any.length)].buffer;
    return null;
  }

  function scheduleStep(step, time){
    // snapshot pattern at schedule time (prevents crackles when pattern changes during playback)
    for (let r=0;r<ROWS;r++){
      const st = state.pattern[r][step];
      if (st === 0) continue;
      const vel = velocityFromState(st);
      const cat = CATS[r];
      const buf = pickBufferForCat(cat);
      if (!buf) continue;

      const src = audioCtx.createBufferSource();
      src.buffer = buf;

      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.0001, time);
      g.gain.linearRampToValueAtTime(vel, time + 0.006);
      g.gain.linearRampToValueAtTime(0.0001, time + Math.min(0.18, buf.duration));

      src.connect(g);
      g.connect(master);
      src.start(time);
      safeStopSource(src, time + buf.duration + 0.05);

      state.activeSources.add(src);
      src.onended = () => state.activeSources.delete(src);
    }
  }

  function schedulerTick(){
    if (!state.isPlaying) return;
    const ct = audioCtx.currentTime;
    while (state.nextNoteTime < ct + state.scheduleAhead){
      scheduleStep(state.currentStep, state.nextNoteTime);
      state.nextNoteTime += stepToTime(1);
      state.currentStep = (state.currentStep + 1) % STEPS;
    }
  }

  function startTransport(){
    if (state.isPlaying) return;
    state.isPlaying = true;
    state.currentStep = 0;
    state.nextNoteTime = audioCtx.currentTime + 0.05;

    state.scheduler = setInterval(schedulerTick, state.lookaheadMs);

    setStatus("playing", "transport running");
  }

  function stopTransport(){
    state.isPlaying = false;
    if (state.scheduler){
      clearInterval(state.scheduler);
      state.scheduler = null;
    }
    // stop scheduled/active sources (hard stop)
    killAllSources();
    setPlayingColumn(-1);
    setStatus("stopped", "");
  }

  // ---------- Random pattern generation ----------
  function resetPattern(){
    for (let r=0;r<ROWS;r++) for (let s=0;s<STEPS;s++) state.pattern[r][s] = 0;
    renderGrid();
    updateVisualDistribution();
  }

  function setHit(cat, step, st=2){
    const r = CATS.indexOf(cat);
    if (r < 0) return;
    state.pattern[r][((step%STEPS)+STEPS)%STEPS] = st;
  }

  function generateBase(style, rng){
    resetPattern();
    // Reasonable defaults
    if (style === "minimal"){
      setHit("KICK",0,3); setHit("KICK",8,2);
      setHit("SNARE",4,3); setHit("SNARE",12,3);
      for (let i=0;i<STEPS;i+=2) setHit("HAT", i, 1);
      setHit("CLAP",12,2);
      return;
    }

    if (style === "dnb"){
      setHit("KICK",0,3); setHit("KICK",10,2);
      setHit("SNARE",4,3); setHit("SNARE",12,3);
      for (let i=0;i<STEPS;i++){
        if (i%2===0) setHit("HAT", i, 2);
        if (i%4===2 && rng()<0.4) setHit("HAT", i, 1);
      }
      if (rng()<0.6) setHit("CLAP",12,2);
      if (rng()<0.35) setHit("PERC/FX",14,1);
      if (rng()<0.35) setHit("PERC/FX",2,1);
      return;
    }

    if (style === "breakbeat"){
      // Amen-ish skeleton
      setHit("KICK",0,3); setHit("KICK",7,2); setHit("KICK",10,2);
      setHit("SNARE",4,3); setHit("SNARE",11,2); setHit("SNARE",12,3);
      setHit("HAT",2,1); setHit("HAT",6,1); setHit("HAT",8,1); setHit("HAT",14,1);
      if (rng()<0.7) setHit("CLAP",12,2);
      setHit("PERC/FX",15,1);
      return;
    }

    // jungle
    setHit("KICK",0,3); setHit("KICK",6,2); setHit("KICK",9,2);
    setHit("SNARE",4,3); setHit("SNARE",12,3);
    setHit("HAT",2,1); setHit("HAT",3,1); setHit("HAT",6,1); setHit("HAT",8,1); setHit("HAT",10,1); setHit("HAT",14,1);
    setHit("PERC/FX",15,2);
    if (rng()<0.5) setHit("CLAP",12,2);
  }

  function applyDensity(density, rng, style){
    // density: 0..100; adds/removes hits without altering audio graph (no playback pops)
    const d = density / 100;

    // Thin out if low density
    for (let r=0;r<ROWS;r++){
      for (let s=0;s<STEPS;s++){
        const st = state.pattern[r][s];
        if (st === 0) continue;
        const keepP = 0.25 + 0.75*d;
        if (rng() > keepP){
          state.pattern[r][s] = 0;
        }
      }
    }

    // Add embellishments if high density
    const addP = Math.max(0, d - 0.45) * 1.6; // 0..~0.88
    for (let s=0;s<STEPS;s++){
      if (rng() < addP){
        // hats / perc accents
        if (rng() < 0.65){
          const st = rng()<0.25 ? 3 : (rng()<0.65 ? 2 : 1);
          state.pattern[CATS.indexOf("HAT")][s] = Math.max(state.pattern[CATS.indexOf("HAT")][s], st);
        } else {
          const rr = rng() < 0.5 ? "PERC/FX" : "CLAP";
          const st = rng()<0.18 ? 3 : 1;
          state.pattern[CATS.indexOf(rr)][s] = Math.max(state.pattern[CATS.indexOf(rr)][s], st);
        }
      }
    }

    // Style-specific ghosting
    if (style === "dnb" || style === "jungle"){
      for (let s=0;s<STEPS;s++){
        if (rng() < 0.22*d){
          const st = (s%4===3) ? 1 : 0;
          if (st) state.pattern[CATS.indexOf("SNARE")][s] = Math.max(state.pattern[CATS.indexOf("SNARE")][s], 1);
        }
      }
    }
  }

  function randomizePattern(){
    const style = $("styleMode").value;
    const density = Number($("density").value);
    const seed = (Date.now() ^ Math.floor(Math.random()*1e9)) >>> 0;
    const rng = mulberry32(seed);

    generateBase(style, rng);
    applyDensity(density, rng, style);

    // Render only (no audio graph rebuild -> prevents playback crackle)
    renderGrid();
    updateVisualDistribution();
    setStatus("pattern", `randomized • ${style.toUpperCase()} • dens ${density}`);
  }

  // ---------- Visuals (8-bit + pseudo 3D) ----------
  const cvFight = $("cvFighters");
  const ctxFight = cvFight.getContext("2d");
  const cvGeo = $("cvGeo");
  const ctxGeo = cvGeo.getContext("2d");

  // Offscreen low-res for pixel effect
  const offFight = document.createElement("canvas");
  offFight.width = 160; offFight.height = 90;
  const offFightCtx = offFight.getContext("2d");

  const offGeo = document.createElement("canvas");
  offGeo.width = 160; offGeo.height = 90;
  const offGeoCtx = offGeo.getContext("2d");

  const fighters = [];
  let geoRot = 0;

  function patternDistribution(){
    const dist = {};
    for (const c of CATS) dist[c]=0;
    for (let r=0;r<ROWS;r++){
      for (let s=0;s<STEPS;s++){
        dist[CATS[r]] += (state.pattern[r][s] ? 1 : 0);
      }
    }
    return dist;
  }

  function updateFighters(){
    const dist = patternDistribution();
    const total = Object.values(dist).reduce((a,b)=>a+b,0) || 1;

    // desired fighter count based on density
    const desired = clamp(Math.round(4 + (total/ (ROWS*STEPS)) * 10), 4, 14);
    while (fighters.length < desired){
      fighters.push(makeFighter());
    }
    while (fighters.length > desired){
      fighters.pop();
    }

    // assign archetypes based on distribution
    const weights = [
      ["KICK", dist["KICK"]],
      ["SNARE", dist["SNARE"]],
      ["HAT", dist["HAT"]],
      ["CLAP", dist["CLAP"]],
      ["BASS", dist["BASS"]],
      ["PERC/FX", dist["PERC/FX"]],
    ].sort((a,b)=>b[1]-a[1]);

    fighters.forEach((f,i) => {
      const t = weights[i % weights.length][0];
      f.type = t;
      // adjust size/speed by type
      f.size = (t==="KICK"||t==="BASS") ? 6 : (t==="SNARE"||t==="CLAP") ? 5 : 4;
      f.speed = (t==="HAT") ? 1.5 : (t==="PERC/FX") ? 1.25 : 1.0;
      f.hp = clamp(8 + Math.floor(dist[t]/2), 6, 18);
    });
  }

  function makeFighter(){
    return {
      x: Math.random()*150+5,
      y: Math.random()*60+18,
      vx: (Math.random()<0.5?-1:1)*(0.6+Math.random()*0.6),
      dir: 1,
      size: 5,
      speed: 1,
      hp: 10,
      cool: 0,
      type: "PERC/FX"
    };
  }

  function rmsFromAnalyser(){
    if (!analyser) return 0;
    const arr = new Uint8Array(analyser.fftSize);
    analyser.getByteTimeDomainData(arr);
    let sum=0;
    for (let i=0;i<arr.length;i++){
      const v = (arr[i]-128)/128;
      sum += v*v;
    }
    return Math.sqrt(sum/arr.length);
  }

  function drawFighters(dt){
    const g = offFightCtx;
    const w = offFight.width, h = offFight.height;
    g.clearRect(0,0,w,h);

    // background
    g.fillStyle = "#050607";
    g.fillRect(0,0,w,h);

    // arena line
    g.fillStyle = "#1e2229";
    g.fillRect(0, h-16, w, 1);

    const amp = rmsFromAnalyser();
    const flick = clamp(Math.floor(amp*40), 0, 6);

    // subtle "scene" shifts based on leading category
    const dist = patternDistribution();
    const lead = Object.entries(dist).sort((a,b)=>b[1]-a[1])[0]?.[0] || "PERC/FX";
    const sceneTone = (lead==="KICK"||lead==="BASS") ? "#0b111a" : (lead==="HAT") ? "#080c12" : "#0a0c10";
    g.fillStyle = sceneTone;
    g.fillRect(0,0,w,h);

    // fighters
    for (let i=0;i<fighters.length;i++){
      const f = fighters[i];
      f.x += f.vx * f.speed * dt;
      if (f.x < 4){ f.x=4; f.vx *= -1; }
      if (f.x > w-8){ f.x=w-8; f.vx *= -1; }
      f.dir = f.vx>=0 ? 1 : -1;

      // interactions (simple "bump fight")
      f.cool -= dt;
      for (let j=i+1;j<fighters.length;j++){
        const o = fighters[j];
        const dx = o.x - f.x;
        const dy = o.y - f.y;
        const d2 = dx*dx + dy*dy;
        if (d2 < 70){
          // push apart
          const push = 0.02*dt;
          f.vx -= push*dx;
          o.vx += push*dx;

          if (f.cool <= 0 && Math.random() < 0.02 + amp*0.2){
            f.hp = Math.max(0, f.hp-1);
            o.hp = Math.max(0, o.hp-1);
            f.cool = 20 + Math.random()*30;
          }
        }
      }

      // draw as pixel sprite
      const sx = Math.round(f.x), sy = Math.round(f.y);
      const sz = f.size;

      // color by type (still monochrome-ish)
      let col = "#223d5c";
      if (f.type==="KICK") col="#1a2a3d";
      else if (f.type==="SNARE") col="#2b3647";
      else if (f.type==="HAT") col="#283043";
      else if (f.type==="CLAP") col="#2d3c52";
      else if (f.type==="BASS") col="#162437";
      else col="#1e2b3a";

      g.fillStyle = col;
      g.fillRect(sx, sy, sz, sz);
      // head
      g.fillRect(sx + (f.dir>0?sz: -2), sy-3, 2, 2);
      // feet
      g.fillStyle = "#0f141c";
      g.fillRect(sx, sy+sz, 2, 1);
      g.fillRect(sx+sz-2, sy+sz, 2, 1);

      // hp bar
      const hpw = clamp(Math.round((f.hp/18)*12), 0, 12);
      g.fillStyle = "#1e2229";
      g.fillRect(sx-1, sy-7, 12, 2);
      g.fillStyle = "#223d5c";
      g.fillRect(sx-1, sy-7, hpw, 2);

      // occasional flashes on snare/clap energy
      if ((lead==="SNARE" || lead==="CLAP") && flick>3){
        g.fillStyle = "rgba(255,255,255,0.05)";
        g.fillRect(0,0,w,h);
      }
    }

    // scale to main canvas with pixelated look
    ctxFight.imageSmoothingEnabled = false;
    ctxFight.clearRect(0,0,cvFight.width,cvFight.height);
    ctxFight.drawImage(offFight, 0, 0, cvFight.width, cvFight.height);
  }

  function drawGeo(dt){
    const g = offGeoCtx;
    const w = offGeo.width, h = offGeo.height;
    g.clearRect(0,0,w,h);

    // background
    g.fillStyle = "#050607";
    g.fillRect(0,0,w,h);

    const dist = patternDistribution();
    const lead = Object.entries(dist).sort((a,b)=>b[1]-a[1])[0]?.[0] || "PERC/FX";
    const amp = rmsFromAnalyser();

    // choose shape by lead
    const shape = (lead==="KICK"||lead==="BASS") ? "cube" :
                  (lead==="HAT") ? "tetra" :
                  (lead==="SNARE"||lead==="CLAP") ? "octa" : "ring";

    geoRot += dt*0.0015*(1 + amp*8);

    // Simple 3D wireframes
    function project(p){
      const z = p[2] + 3.5;
      const s = 60 / z;
      return [w/2 + p[0]*s, h/2 + p[1]*s];
    }

    function rotY(p, a){
      const [x,y,z] = p;
      const ca=Math.cos(a), sa=Math.sin(a);
      return [x*ca + z*sa, y, -x*sa + z*ca];
    }
    function rotX(p, a){
      const [x,y,z] = p;
      const ca=Math.cos(a), sa=Math.sin(a);
      return [x, y*ca - z*sa, y*sa + z*ca];
    }

    let verts=[], edges=[];
    if (shape==="cube"){
      verts = [
        [-1,-1,-1],[1,-1,-1],[1,1,-1],[-1,1,-1],
        [-1,-1, 1],[1,-1, 1],[1,1, 1],[-1,1, 1],
      ];
      edges = [[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];
    } else if (shape==="tetra"){
      verts = [[0,1,0],[-1,-1,-1],[1,-1,-1],[0,-1,1]];
      edges = [[0,1],[0,2],[0,3],[1,2],[2,3],[3,1]];
    } else if (shape==="octa"){
      verts = [[0,0,1.3],[0,0,-1.3],[1.3,0,0],[-1.3,0,0],[0,1.3,0],[0,-1.3,0]];
      edges = [[0,2],[0,3],[0,4],[0,5],[1,2],[1,3],[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]];
    } else { // ring
      const N=12;
      for (let i=0;i<N;i++){
        const a = (i/N)*Math.PI*2;
        verts.push([Math.cos(a)*1.4, Math.sin(a)*1.0, 0]);
        edges.push([i, (i+1)%N]);
      }
    }

    // transform + draw
    const jitter = amp*0.20;
    const pts = verts.map(v => {
      let p = rotY(v, geoRot);
      p = rotX(p, geoRot*0.85);
      return [p[0]*(1+jitter), p[1]*(1+jitter), p[2]];
    }).map(project);

    // color stays in the same palette (no neon)
    g.strokeStyle = "#223d5c";
    g.lineWidth = 1;

    g.beginPath();
    for (const [a,b] of edges){
      const pa = pts[a], pb = pts[b];
      g.moveTo(pa[0], pa[1]);
      g.lineTo(pb[0], pb[1]);
    }
    g.stroke();

    // points
    g.fillStyle = "rgba(231,231,231,0.45)";
    for (const p of pts){
      g.fillRect(Math.round(p[0]), Math.round(p[1]), 1, 1);
    }

    ctxGeo.imageSmoothingEnabled = false;
    ctxGeo.clearRect(0,0,cvGeo.width,cvGeo.height);
    ctxGeo.drawImage(offGeo, 0, 0, cvGeo.width, cvGeo.height);
  }

  function updateVisualDistribution(){
    updateFighters();
  }

  let lastFrame = now();
  function animLoop(){
    const t = now();
    const dt = t - lastFrame;
    lastFrame = t;

    if (state.isPlaying){
      // update playing column indicator
      const stepDur = (60/state.bpm)/4;
      const rel = audioCtx ? (audioCtx.currentTime - (state.nextNoteTime - stepDur*(state.currentStep))) : 0;
      // Use modulo time tracking with currentStep already advanced; fallback via currentStep-1.
      const displayStep = (state.currentStep - 1 + STEPS) % STEPS;
      setPlayingColumn(displayStep);
    }

    drawFighters(dt);
    drawGeo(dt);

    requestAnimationFrame(animLoop);
  }

  // ---------- Recording / Export ----------
  async function toggleRecord(){
    await ensureAudio();
    if (audioCtx.state !== "running") await audioCtx.resume();

    if (!state.record.isRecording){
      // Create stream destination once
      if (!state.record.streamDest){
        state.record.streamDest = audioCtx.createMediaStreamDestination();
        master.connect(state.record.streamDest);
      }
      const rec = new MediaRecorder(state.record.streamDest.stream, {mimeType: "audio/webm"});
      state.record.rec = rec;
      state.record.chunks = [];
      rec.ondataavailable = (e) => { if (e.data && e.data.size) state.record.chunks.push(e.data); };
      rec.onstop = () => {
        const blob = new Blob(state.record.chunks, {type:"audio/webm"});
        downloadBlob(blob, `tcseq_record_${Date.now()}.webm`);
        state.record.chunks = [];
      };
      rec.start();
      state.record.isRecording = true;
      $("btnRecord").textContent = "RECORDING…";
      setStatus("record", "audio/webm");
      toast("Recording started (WEBM). Click RECORD again to stop.");
    } else {
      state.record.isRecording = false;
      $("btnRecord").textContent = "RECORD";
      try{ state.record.rec.stop(); }catch(e){}
      setStatus("record", "stopped");
      toast("Recording saved.");
    }
  }

  function downloadBlob(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 5000);
  }

  function audioBufferToWav(ab, normalize){
    // 16-bit PCM WAV
    const numCh = ab.numberOfChannels;
    const sr = ab.sampleRate;
    const len = ab.length;

    // interleave
    const interleaved = new Float32Array(len * numCh);
    let max = 0;
    for (let ch=0; ch<numCh; ch++){
      const data = ab.getChannelData(ch);
      for (let i=0; i<len; i++){
        const v = data[i];
        max = Math.max(max, Math.abs(v));
        interleaved[i*numCh + ch] = v;
      }
    }
    let gain = 1;
    if (normalize && max > 1e-9) gain = 0.98 / max;

    const bytesPerSample = 2;
    const blockAlign = numCh * bytesPerSample;
    const byteRate = sr * blockAlign;
    const dataSize = len * blockAlign;

    const buf = new ArrayBuffer(44 + dataSize);
    const view = new DataView(buf);

    function writeStr(off, s){
      for (let i=0;i<s.length;i++) view.setUint8(off+i, s.charCodeAt(i));
    }

    writeStr(0, "RIFF");
    view.setUint32(4, 36 + dataSize, true);
    writeStr(8, "WAVE");
    writeStr(12, "fmt ");
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, numCh, true);
    view.setUint32(24, sr, true);
    view.setUint32(28, byteRate, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, 16, true);
    writeStr(36, "data");
    view.setUint32(40, dataSize, true);

    let offset = 44;
    for (let i=0; i<interleaved.length; i++){
      let v = clamp(interleaved[i]*gain, -1, 1);
      view.setInt16(offset, v < 0 ? v*0x8000 : v*0x7FFF, true);
      offset += 2;
    }
    return new Blob([buf], {type:"audio/wav"});
  }

  async function offlineRenderToBuffer(sampleRate, bars){
    // Offline render current pattern (uses decoded buffers only)
    const spb = 60 / state.bpm;
    const stepDur = spb / 4;
    const barDur = stepDur * STEPS;
    const duration = barDur * bars;

    const length = Math.ceil(duration * sampleRate);
    const oac = new OfflineAudioContext(2, length, sampleRate);
    const out = oac.createGain();
    out.gain.value = 0.9;
    out.connect(oac.destination);

    function scheduleBuf(buf, time, vel){
      // mix stereo: use buffer channel count
      const src = oac.createBufferSource();
      src.buffer = buf;
      const g = oac.createGain();
      g.gain.setValueAtTime(0.0001, time);
      g.gain.linearRampToValueAtTime(vel, time + 0.006);
      g.gain.linearRampToValueAtTime(0.0001, time + Math.min(0.18, buf.duration));
      src.connect(g);
      g.connect(out);
      src.start(time);
    }

    // Ensure we have at least one buffer per category, else skip
    const pool = {};
    for (const c of CATS) pool[c] = state.files.filter(f => f.buffer && f.category === c).map(f => f.buffer);
    const any = state.files.filter(f => f.buffer).map(f => f.buffer);

    for (let bar=0; bar<bars; bar++){
      const baseT = bar*barDur;
      for (let step=0; step<STEPS; step++){
        const t = baseT + step*stepDur;
        for (let r=0;r<ROWS;r++){
          const st = state.pattern[r][step];
          if (!st) continue;
          const vel = velocityFromState(st);
          const cat = CATS[r];
          const list = pool[cat];
          const buf = (list && list.length) ? list[Math.floor(Math.random()*list.length)]
                    : (any.length ? any[Math.floor(Math.random()*any.length)] : null);
          if (buf) scheduleBuf(buf, t, vel);
        }
      }
    }

    const rendered = await oac.startRendering();
    return rendered;
  }

  function openExportModal(){
    $("modalBackdrop").style.display = "flex";
  }
  function closeExportModal(){
    $("modalBackdrop").style.display = "none";
  }

  async function exportNow(){
    closeExportModal();
    const fmt = $("exportFormat").value;
    const sr = Number($("exportSR").value);
    const bars = Number($("exportBars").value);
    const norm = $("exportNorm").value === "1";

    if (state.files.filter(f => f.buffer).length === 0){
      toast("Nothing decoded yet. Load files and run ANALYZE+GENERATE first.");
      return;
    }

    if (fmt === "wav"){
      setStatus("export", "offline rendering…");
      const rendered = await offlineRenderToBuffer(sr, bars);
      const blob = audioBufferToWav(rendered, norm);
      downloadBlob(blob, `tcseq_${state.bpm}bpm_${bars}bars_${sr}hz.wav`);
      setStatus("export", "done");
      toast("WAV exported.");
      return;
    }

    if (fmt === "webm"){
      // Real-time export: arm recorder, play for bars, stop.
      await ensureAudio();
      if (audioCtx.state !== "running") await audioCtx.resume();

      if (state.record.isRecording){
        toast("Stop current recording first.");
        return;
      }
      // Start recording
      await toggleRecord();
      // Ensure transport playing
      if (!state.isPlaying) startTransport();

      const spb = 60/state.bpm;
      const barDur = (spb*4);
      const ms = barDur*bars*1000;
      toast(`Recording ${bars} bar(s) …`);
      setTimeout(async () => {
        // stop record (leaves transport running)
        if (state.record.isRecording) await toggleRecord();
        setStatus("export", "webm done");
      }, ms);
      return;
    }

    toast("MP3 export disabled (encoder not included).");
  }

  // ---------- Analyze+Generate button ----------
  async function analyzeAndGenerate(){
    if (state.files.length === 0){
      toast("Load audio files first.");
      return;
    }
    await ensureAudio();
    if (audioCtx.state !== "running") await audioCtx.resume();

    setStatus("analyze", "decoding + classifying…");

    // Decode any missing buffers (cap 200 files as spec)
    const cap = 200;
    if (state.files.length > cap){
      toast(`Loaded ${state.files.length} files; only first ${cap} will be used.`);
    }

    for (let i=0;i<Math.min(state.files.length, cap);i++){
      const f = state.files[i];
      if (!f.buffer){
        try{
          f.buffer = await decodeFile(f.file);
        } catch (e){
          console.warn(e);
          state.debug.lines.push(`[decode fail] ${f.name}: ${String(e)}`);
        }
      }
      if (f.buffer && !f.features){
        f.features = extractFeatures(f.buffer);
        if (!f.override){
          f.autoCategory = classify(f.features);
          f.category = f.autoCategory;
        }
      }
    }

    renderFileList();

    // Generate default pattern tuned to the distribution
    const dist = {};
    for (const c of CATS) dist[c] = 0;
    for (const f of state.files){
      if (f.buffer && f.category) dist[f.category] = (dist[f.category]||0)+1;
    }

    // Choose style from UI, but bias density by number of hats/percs
    const style = $("styleMode").value;
    const density = Number($("density").value);
    const seed = (Date.now() ^ 0x9E3779B9) >>> 0;
    const rng = mulberry32(seed);

    generateBase(style, rng);

    // push a little more hats/percs if they exist
    const hatBoost = clamp(dist["HAT"]/Math.max(1,state.files.length), 0, 1);
    const dens2 = clamp(Math.round(density + hatBoost*18), 0, 100);
    applyDensity(dens2, rng, style);

    renderGrid();
    updateVisualDistribution();

    setStatus("ready", `classified ${state.files.filter(f=>f.buffer).length} file(s)`);
    toast("Analyze+Generate complete. Click filenames to preview; click class labels to correct.");
  }

  // ---------- Load/Clear ----------
  async function loadFiles(){
    const preferFSA = ("showOpenFilePicker" in window);
    let files = [];
    try{
      if (preferFSA){
        const handles = await window.showOpenFilePicker({
          multiple: true,
          types: [{ description: "Audio", accept: { "audio/*": [".wav",".mp3",".aif",".aiff",".ogg",".m4a",".flac"] } }]
        });
        for (const h of handles){
          const file = await h.getFile();
          files.push(file);
        }
      } else {
        $("fileInput").click();
        return;
      }
    } catch (e){
      // user cancelled
      return;
    }

    addFiles(files);
  }

  function addFiles(files){
    if (!files || !files.length) return;
    const current = state.files.length;
    const cap = 200;
    const room = cap - current;
    const take = files.slice(0, Math.max(0, room));

    if (take.length < files.length){
      toast(`File cap is ${cap}. Extra files were ignored.`);
    }

    for (const file of take){
      state.files.push({
        id: cryptoRandomId(),
        name: file.name,
        file,
        buffer: null,
        features: null,
        autoCategory: null,
        category: null,
        override: false
      });
    }
    if (state.selectedFileIndex < 0 && state.files.length) state.selectedFileIndex = 0;
    renderFileList();
    setStatus("loaded", `${state.files.length} file(s)`);
  }

  function clearAll(){
    stopTransport();
    state.files = [];
    state.selectedFileIndex = -1;
    resetPattern();
    renderFileList();
    setStatus("cleared", "");
  }

  function cryptoRandomId(){
    if (crypto && crypto.getRandomValues){
      const a = new Uint32Array(2);
      crypto.getRandomValues(a);
      return (a[0].toString(16)+a[1].toString(16));
    }
    return String(Math.random()).slice(2);
  }

  // ---------- Debug ----------
  function toggleDebug(){
    state.debug.on = !state.debug.on;
    if (state.debug.on){
      toast("Debug ON. Open console for logs.");
      console.log("[TCSEQ debug] state:", state);
    } else {
      toast("Debug OFF.");
    }
  }

  // ---------- Help ----------
  function showHelp(){
    toast("Workflow: LOAD FILES → ANALYZE+GENERATE → RANDOM PATTERN (optional) → PLAY. Click filename to preview; click class to correct. EXPORT renders audio.");
  }

  // ---------- Wiring ----------
  $("btnLoad").addEventListener("click", loadFiles);
  $("fileInput").addEventListener("change", (e) => {
    addFiles(Array.from(e.target.files || []));
    e.target.value = "";
  });
  $("btnClear").addEventListener("click", clearAll);

  $("btnAnalyzeGenerate").addEventListener("click", analyzeAndGenerate);

  $("btnPlay").addEventListener("click", async () => {
    await ensureAudio();
    if (audioCtx.state !== "running") await audioCtx.resume();
    if (!state.isPlaying) startTransport();
  });

  $("btnStop").addEventListener("click", () => stopTransport());
  $("btnRecord").addEventListener("click", toggleRecord);
  $("btnExport").addEventListener("click", openExportModal);
  $("btnHidePanel").addEventListener("click", () => {
    $("app").classList.toggle("hidden-left");
  });
  $("btnDebug").addEventListener("click", toggleDebug);
  $("btnHelp").addEventListener("click", showHelp);

  $("btnRandom").addEventListener("click", () => {
    // Fix: randomize does not touch running nodes; safe during playback (no click)
    randomizePattern();
  });
  $("btnResetGrid").addEventListener("click", resetPattern);

  $("viewMode").addEventListener("change", (e) => {
    state.viewMode = e.target.value;
    setPlayingColumn(-1);
  });

  $("modalBackdrop").addEventListener("click", (e) => {
    if (e.target === $("modalBackdrop")) closeExportModal();
  });
  $("btnExportCancel").addEventListener("click", closeExportModal);
  $("btnExportGo").addEventListener("click", exportNow);

  // Keyboard in file list
  fileListEl.addEventListener("keydown", async (e) => {
    if (state.files.length === 0) return;

    const max = state.files.length - 1;
    if (e.key === "ArrowDown"){
      e.preventDefault();
      state.selectedFileIndex = clamp(state.selectedFileIndex + 1, 0, max);
      renderFileList();
      scrollSelectedIntoView();
    }
    if (e.key === "ArrowUp"){
      e.preventDefault();
      state.selectedFileIndex = clamp(state.selectedFileIndex - 1, 0, max);
      renderFileList();
      scrollSelectedIntoView();
    }
    if (e.key === "Enter"){
      e.preventDefault();
      await previewFile(state.selectedFileIndex);
    }
    // 1-6 sets category quickly
    if (/^[1-6]$/.test(e.key)){
      const idx = Number(e.key) - 1;
      const cat = CATS[idx];
      const f = state.files[state.selectedFileIndex];
      if (f){
        f.category = cat;
        f.override = true;
        renderFileList();
        updateVisualDistribution();
        toast(`Set class: ${cat}`);
      }
    }
  });

  function scrollSelectedIntoView(){
    const sel = fileListEl.querySelector(".fileitem.selected");
    if (sel) sel.scrollIntoView({block:"nearest"});
  }

  // Startup render
  renderHeader();
  renderGrid();
  renderFileList();
  updateVisualDistribution();
  setStatus("ready", "load up to 200 files");

  requestAnimationFrame(animLoop);
})();
</script>
</body>
</html>
