<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TRANSIENT DETECTION // SEQUENCER</title>
  <style>
    :root{
      --bg:#000000;
      --panel:#020a16;
      --panel2:#000c1f;
      --fg:#c8c8c8;
      --muted:#7f8792;
      --blue:#0f52c8;
      --blue2:#001f5a;
      --warn:#b38b00;
      --bad:#b00020;
      --good:#00b36b;
      --line:#223a66;
      --invbg:#c8c8c8;
      --invfg:#000000;
      --shadow: 0 0 0 1px var(--line);
      --font: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:var(--font);}
    *{box-sizing:border-box;}
    a{color:#9db7ff; text-decoration:none;}
    a:hover{text-decoration:underline;}
    .app{
      display:grid;
      grid-template-columns: 360px 1fr;
      grid-template-rows: auto 1fr auto;
      height:100%;
      gap:10px;
      padding:10px;
    }
    .titlebar{
      grid-column:1 / -1;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:8px 10px;
      background:var(--panel);
      border:1px solid var(--line);
      box-shadow:var(--shadow);
    }
    .titlebar .left{
      display:flex; gap:10px; align-items:center;
      min-width:0;
    }
    .badge{
      padding:2px 6px;
      border:1px solid var(--line);
      background:var(--blue2);
      color:var(--fg);
      letter-spacing:0.08em;
      font-size:12px;
    }
    .title{
      font-size:13px;
      letter-spacing:0.08em;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .statusline{
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
    }
    .panel{
      background:var(--panel);
      border:1px solid var(--line);
      box-shadow:var(--shadow);
      overflow:hidden;
      min-height:0;
    }
    .panelHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:8px 10px;
      border-bottom:1px solid var(--line);
      background:var(--panel2);
      letter-spacing:0.08em;
      font-size:12px;
    }
    .panelBody{
      padding:10px;
      overflow:auto;
      max-height:100%;
    }
    .sidebar{grid-row:2; grid-column:1;}
    .main{grid-row:2; grid-column:2; display:flex; flex-direction:column; min-height:0;}
    .footer{
      grid-column:1 / -1;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:8px 10px;
      background:var(--panel);
      border:1px solid var(--line);
      box-shadow:var(--shadow);
      font-size:12px;
      color:var(--muted);
    }
    .btnRow{display:flex; flex-wrap:wrap; gap:8px;}
    .btn{
      border:1px solid var(--line);
      background:var(--blue2);
      color:var(--fg);
      padding:7px 10px;
      font-family:var(--font);
      font-size:12px;
      letter-spacing:0.06em;
      cursor:pointer;
      user-select:none;
    }
    .btn:hover{background:var(--blue);}
    .btn:active{transform:translateY(1px);}
    .btn[disabled]{opacity:0.45; cursor:not-allowed;}
    .btn.secondary{background:transparent;}
    .btn.secondary:hover{background:var(--panel2);}
    .btn.danger{background:#22000a;}
    .btn.danger:hover{background:#3a0014;}
    .kv{
      display:grid;
      grid-template-columns: 120px 1fr;
      gap:6px 10px;
      font-size:12px;
      color:var(--muted);
      margin:10px 0;
    }
    .kv b{color:var(--fg); font-weight:600;}
    .divider{height:1px; background:var(--line); margin:10px 0;}
    .hint{color:var(--muted); font-size:12px; line-height:1.45;}
    .warn{color:var(--warn);}
    .good{color:var(--good);}
    .bad{color:var(--bad);}
    input[type="range"], input[type="number"], select{
      width:100%;
      background:transparent;
      color:var(--fg);
      border:1px solid var(--line);
      padding:6px 8px;
      font-family:var(--font);
      font-size:12px;
      outline:none;
    }
    input[type="range"]{padding:0; border:none;}
    label{font-size:12px; color:var(--muted); display:block; margin-bottom:4px; letter-spacing:0.06em;}
    .ctrlGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .ctrl{min-width:0;}
    .dropzone{
      border:1px dashed var(--line);
      background: #00050f;
      padding:10px;
      font-size:12px;
      color:var(--muted);
      line-height:1.45;
    }
    .dropzone.drag{border-color:#9db7ff; color:#9db7ff;}
    .fileList{
      font-size:12px;
      border:1px solid var(--line);
      background:#00040c;
      padding:8px;
      max-height:170px;
      overflow:auto;
      white-space:nowrap;
    }
    .fileItem{
      display:flex;
      justify-content:space-between;
      gap:8px;
      padding:2px 0;
      color:var(--muted);
    }
    .fileItem .name{
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      max-width:240px;
    }
    .fileItem .tag{color:var(--fg);}
    .fileItem.selected{
      background:var(--invbg);
      color:var(--invfg);
    }
    .fileItem.selected .tag{color:var(--invfg);}
    .monoBox{
      border:1px solid var(--line);
      background:#00040c;
      padding:8px;
      font-size:12px;
      color:var(--muted);
      overflow:auto;
      white-space:pre-wrap;
    }
    .seqWrap{
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height:0;
      flex:1;
    }
    .seqTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .seqTitle{
      font-size:12px;
      letter-spacing:0.08em;
      color:var(--muted);
    }
    .gridFrame{
      border:1px solid var(--line);
      background:#00040c;
      box-shadow:var(--shadow);
      padding:10px;
      min-height:0;
      overflow:auto;
    }
    .gridLegend{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      font-size:12px;
      color:var(--muted);
      margin-bottom:8px;
    }
    .glyph{
      display:inline-block;
      padding:0 6px;
      border:1px solid var(--line);
      background:var(--panel2);
      color:var(--fg);
      margin-right:6px;
    }
    .seqGrid{
      display:grid;
      grid-template-columns: 90px repeat(16, 16px);
      gap:2px;
      align-items:center;
      font-size:12px;
      line-height:1;
      user-select:none;
    }
    .rowLabel{
      color:var(--fg);
      letter-spacing:0.06em;
      font-size:12px;
      padding-right:6px;
    }
    .cell{
      width:16px; height:16px;
      display:flex; align-items:center; justify-content:center;
      border:1px solid var(--line);
      background:#000814;
      color:var(--fg);
      cursor:pointer;
    }
    .cell:hover{background:#001122;}
    .cell.off{color:#223045;}
    .cell.ghost{color:#4f5a6a;}
    .cell.hit{color:#c8c8c8;}
    .cell.accent{background:#001b44;}
    .cell.cursor{
      outline:1px solid #9db7ff;
      box-shadow: 0 0 0 1px #9db7ff inset;
    }
    .cell.cursorBlink{
      background:var(--invbg);
      color:var(--invfg);
    }
    .stepHeader{
      display:grid;
      grid-template-columns: 90px repeat(16, 16px);
      gap:2px;
      align-items:center;
      font-size:11px;
      color:var(--muted);
      margin-bottom:6px;
      user-select:none;
    }
    .stepHeader div{display:flex; justify-content:center;}
    .stepHeader .h0{justify-content:flex-start;}
    .toast{
      position:fixed;
      bottom:12px;
      left:12px;
      right:12px;
      max-width:900px;
      margin:auto;
      background:var(--panel2);
      border:1px solid var(--line);
      color:var(--fg);
      padding:10px;
      font-size:12px;
      box-shadow:var(--shadow);
      display:none;
      white-space:pre-wrap;
    }
    .toast.show{display:block;}
    .kbd{
      border:1px solid var(--line);
      padding:0 6px;
      background:#000814;
      color:var(--fg);
    }
    .mini{
      font-size:11px;
      color:var(--muted);
      margin-top:6px;
      line-height:1.4;
    }
    .hidden{display:none !important;}
    .compact .app{grid-template-columns: 1fr;}
    .compact .sidebar{display:none;}
    .compact .main{grid-column:1;}
  
    /* Mobile / narrow screens: keep sequencer visible */
    @media (max-width: 900px){
      .app{
        grid-template-columns: 1fr;
        grid-template-rows: auto auto 1fr auto;
        gap:8px;
        padding:8px;
      }
      .sidebar{grid-row:2; grid-column:1;}
      .main{grid-row:3; grid-column:1;}
      .titlebar{position:sticky; top:0; z-index:5;}
      .seqGrid{grid-template-columns: 78px repeat(16, 16px);}
      .stepHeader{grid-template-columns: 78px repeat(16, 16px);}
      .rowLabel{font-size:11px;}
      .panelHeader{gap:8px; flex-wrap:wrap;}
      .btn{padding:7px 9px;}
    }

</style>
</head>
<body>
  <div id="root" class="app">
    <div class="titlebar">
      <div class="left">
        <span class="badge">TC//DOS</span>
        <div class="title">TRANSIENT DETECTION // SEQUENCER (200 FILES)</div>
      </div>
      <div class="statusline" id="statusLine">Boot…</div>
    </div>

    <div class="panel sidebar" id="sidebar">
      <div class="panelHeader">
        <div>CONTROL</div>
        <div style="display:flex; gap:8px;">
          <button class="btn secondary" id="btnCompact">HIDE PANEL</button>
          <button class="btn secondary" id="btnHelp">HELP</button>
        </div>
      </div>
      <div class="panelBody">
        <div class="btnRow">
          <button class="btn" id="btnPick">LOAD FILES</button>
          <button class="btn secondary" id="btnClear">CLEAR</button>
        </div>

        <div class="divider"></div>

        <div id="dropzone" class="dropzone" tabindex="0">
          Drag & drop up to <b>200</b> audio files here.<br/>
          Works best on <b>localhost</b> (not <span class="warn">file://</span>).
          <div class="mini">Tip: If audio is silent, click <span class="kbd">PLAY</span> once to unlock AudioContext.</div>
        </div>

        <div class="divider"></div>

        <div class="kv">
          <div>FILES</div><div><b id="kvFiles">0</b></div>
          <div>DECODED</div><div><b id="kvDecoded">0</b></div>
          <div>ANALYZED</div><div><b id="kvAnalyzed">0</b></div>
          <div>CTX</div><div><b id="kvCtx">—</b></div>
        </div>

        <div class="fileList" id="fileList" aria-label="Loaded file list"></div>

        <div class="divider"></div>

        <div class="btnRow">
          <button class="btn" id="btnAnalyze">ANALYZE</button>
          <button class="btn secondary" id="btnAutoAssign">AUTO-ASSIGN</button>
          <button class="btn secondary" id="btnExport">EXPORT LOG</button>
        </div>

        <div class="divider"></div>

        <div class="ctrlGrid">
          <div class="ctrl">
            <label for="tempo">TEMPO (BPM)</label>
            <input id="tempo" type="number" min="40" max="260" value="120"/>
          </div>
          <div class="ctrl">
            <label for="swing">SWING (%)</label>
            <input id="swing" type="number" min="0" max="75" value="12"/>
          </div>
          <div class="ctrl">
            <label for="complexity">COMPLEXITY</label>
            <input id="complexity" type="number" min="0" max="100" value="45"/>
          </div>
          <div class="ctrl">
            <label for="variation">VARIATION</label>
            <input id="variation" type="number" min="0" max="100" value="35"/>
          </div>
          <div class="ctrl">
            <label for="bars">BARS</label>
            <select id="bars">
              <option value="1">1</option>
              <option value="2" selected>2</option>
              <option value="4">4</option>
              <option value="8">8</option>
            </select>
          </div>
          <div class="ctrl">
            <label for="glyphSet">GLYPHS</label>
            <select id="glyphSet">
              <option value="ascii" selected>ASCII</option>
              <option value="blocks">BLOCKS</option>
              <option value="dots">DOTS</option>
            </select>
          </div>
        </div>

        <div class="divider"></div>

        <div class="btnRow">
          <button class="btn" id="btnGen">GENERATE</button>
          <button class="btn" id="btnPlay">PLAY</button>
          <button class="btn danger" id="btnStop">STOP</button>
        </div>

        <div class="divider"></div>

        <div class="hint">
          Keyboard: <span class="kbd">↑</span><span class="kbd">↓</span><span class="kbd">←</span><span class="kbd">→</span> move cursor ·
          <span class="kbd">Space</span> toggle hit ·
          <span class="kbd">A</span> accent ·
          <span class="kbd">G</span> ghost ·
          <span class="kbd">M</span> mute row ·
          <span class="kbd">Tab</span> next sample ·
          <span class="kbd">1..6</span> assign category ·
          <span class="kbd">Enter</span> preview sample
        </div>
      </div>
    </div>

    <div class="panel main">
      <div class="panelHeader">
        <div>SEQUENCER</div>
        <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
          <select id="viewBar" style="width:140px;">
            <option value="follow">VIEW: FOLLOW</option>
            <option value="1">VIEW: BAR 1</option>
          </select>
          <button class="btn secondary" id="btnSeed">SEED: AUTO</button>
          <button class="btn secondary" id="btnReset">RESET GRID</button>
        </div>
      </div>

      <div class="panelBody seqWrap">
        <div class="seqTop">
          <div class="seqTitle" id="seqTitle">No pattern. Load files → Analyze → Generate.</div>
          <div class="seqTitle" id="clockTitle">—</div>
        </div>

        <div class="gridFrame">
          <div class="gridLegend">
            <span class="glyph" id="legendEmpty">.</span> empty
            <span class="glyph" id="legendGhost">:</span> ghost
            <span class="glyph" id="legendHit">*</span> hit
            <span class="glyph" id="legendAccent">#</span> accent
            <span class="glyph">↵</span> Enter = preview
          </div>

          <div class="stepHeader" id="stepHeader"></div>
          <div class="seqGrid" id="seqGrid" tabindex="0" aria-label="Step sequencer grid"></div>

          <div class="divider"></div>

          <div class="monoBox" id="inspector">INSPECTOR: (select a file or a cell)</div>
        </div>

        <div class="panel">
          <div class="panelHeader">
            <div>DEBUG</div>
            <div style="display:flex; gap:8px;">
              <button class="btn secondary" id="btnDbg">TOGGLE</button>
              <button class="btn secondary" id="btnPanic">AUDIO PANIC</button>
            </div>
          </div>
          <div class="panelBody hidden" id="debugBox">
            <div class="monoBox" id="logBox">Boot log…</div>
          </div>
        </div>
      </div>
    </div>

    <div class="footer">
      <div>
        <span class="badge">MODE</span>
        <span id="modeLine">Idle</span>
        <span style="margin-left:10px;" class="badge">SELECTED</span>
        <span id="selLine">—</span>
      </div>
      <div>
        <span class="badge">NOTE</span>
        <span id="noteLine">Serve via <b>python3 -m http.server</b> for best reliability.</span>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

<script>
(() => {
  'use strict';

  // ====== Utilities ======
  const $ = (id) => document.getElementById(id);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const now = () => (performance && performance.now) ? performance.now() : Date.now();

  function fmt(n, d=2){
    if (!isFinite(n)) return '—';
    const s = n.toFixed(d);
    return s.replace(/\.00$/, '');
  }

  function safeName(file){
    try { return file.name || '(unnamed)'; } catch { return '(unnamed)'; }
  }

  // ====== Logger ======
  class Logger{
    constructor(elStatus, elBox){
      this.elStatus = elStatus;
      this.elBox = elBox;
      this.lines = [];
      this.max = 1200;
    }
    log(msg, level='INFO'){
      const ts = new Date().toISOString().replace('T',' ').replace('Z','');
      const line = `[${ts}] ${level}: ${msg}`;
      this.lines.push(line);
      if (this.lines.length > this.max) this.lines.shift();
      if (this.elBox) this.elBox.textContent = this.lines.join('\n');
      if (this.elStatus){
        this.elStatus.textContent = msg.length > 96 ? msg.slice(0, 96) + '…' : msg;
      }
      // console mirror
      if (level === 'ERR') console.error(line);
      else if (level === 'WARN') console.warn(line);
      else console.log(line);
    }
    exportText(){ return this.lines.join('\n'); }
  }

  const toast = (() => {
    const el = $('toast');
    let t = null;
    return {
      show(msg, ms=2600){
        el.textContent = msg;
        el.classList.add('show');
        clearTimeout(t);
        t = setTimeout(() => el.classList.remove('show'), ms);
      }
    };
  })();

  // ====== Audio Engine ======
  class AudioEngine{
    constructor(logger){
      this.logger = logger;
      this.ctx = null;
      this.master = null;
      this.limiter = null;
      this.isRunning = false;
      this.schedTimer = null;
      this.lookaheadMs = 25;
      this.scheduleAhead = 0.22;
      this.nextNoteTime = 0;
      this.stepIndex = 0;
      this.pattern = null;   // {rows:[{name, bus, steps:[0..3], muted, sampleIds:[] }], bars, stepsPerBar=16}
      this.onStep = null;
      this.busGains = new Map();
      this.activeSources = new Set();
      this.maxConcurrent = 48;  // avoid runaway
    }

    async ensure(){
      if (!this.ctx){
        const Ctx = window.AudioContext || window.webkitAudioContext;
        if (!Ctx) throw new Error('Web Audio API not available in this browser.');
        this.ctx = new Ctx({latencyHint:'interactive'});
        this.master = this.ctx.createGain();
        this.master.gain.value = 0.85;

        // Gentle "limiter": compressor.
        const comp = this.ctx.createDynamicsCompressor();
        comp.threshold.value = -10;
        comp.knee.value = 20;
        comp.ratio.value = 8;
        comp.attack.value = 0.003;
        comp.release.value = 0.12;

        this.master.connect(comp).connect(this.ctx.destination);
        this.limiter = comp;
        this.logger.log(`AudioContext created. state=${this.ctx.state}, sr=${this.ctx.sampleRate}`);
      }
      if (this.ctx.state !== 'running'){
        await this.ctx.resume();
        this.logger.log(`AudioContext resumed. state=${this.ctx.state}`);
      }
      return this.ctx;
    }

    async decodeFile(file){
      const ctx = await this.ensure();
      const ab = await file.arrayBuffer();
      // decodeAudioData may reject with DataCloneError in some cases; wrap for safety.
      const buf = await new Promise((resolve, reject) => {
        ctx.decodeAudioData(ab.slice(0), resolve, reject);
      });
      return buf;
    }

    stopAllSources(){
      for (const s of this.activeSources){
        try{ s.stop(0); }catch{}
      }
      this.activeSources.clear();
    }

    async panic(){
      if (!this.ctx) return;
      this.logger.log('Audio PANIC: stopping scheduler and all sources.', 'WARN');
      this.stop();
      this.stopAllSources();
      try{
        await this.ctx.close();
      }catch{}
      this.ctx = null;
      this.master = null;
      this.limiter = null;
    }

    setPattern(pattern){
      this.pattern = pattern;
      this.stepIndex = 0;
      this.nextNoteTime = 0;
    }

    // schedule: stepDuration = 60/BPM/4 (16th notes)
    start(getEventAtStep, getBpm, getSwingPercent){
      if (!this.pattern) throw new Error('No pattern set.');
      if (this.isRunning) return;
      const stepsPerBar = 16;
      const totalSteps = this.pattern.bars * stepsPerBar;

      this.isRunning = true;
      this.logger.log('PLAY: scheduler start.');
      const ctx = this.ctx;
      this.nextNoteTime = ctx.currentTime + 0.05;
      this.stepIndex = 0;

      const stepDur = () => (60 / clamp(getBpm(), 40, 260)) / 4;

      const scheduleStep = (step, time) => {
        const evt = getEventAtStep(step);
        if (!evt) return;
        for (const hit of evt){
          if (!hit || hit.muted) continue;
          this.trigger(hit, time);
        }
      };

      const scheduler = () => {
        if (!this.isRunning) return;
        const t = this.ctx.currentTime;
        while (this.nextNoteTime < t + this.scheduleAhead){
          const s = this.stepIndex % totalSteps;
          scheduleStep(s, this.nextNoteTime);
          if (this.onStep) this.onStep(s);

          // swing: delay odd steps
          const odd = (s % 2) === 1;
          const base = stepDur();
          const swing = clamp(getSwingPercent()/100, 0, 0.75);
          const swingDelay = odd ? base * swing : 0;
          this.nextNoteTime += base + swingDelay;
          this.stepIndex++;
        }
      };

      this.schedTimer = setInterval(scheduler, this.lookaheadMs);
    }

    stop(){
      if (!this.isRunning) return;
      this.isRunning = false;
      if (this.schedTimer){
        clearInterval(this.schedTimer);
        this.schedTimer = null;
      }
      this.stopAllSources();
      this.logger.log('STOP: scheduler stopped.');
    }

    trigger(hit, time){
      // hit: {buffer, gain, pan, accentLevel, label}
      if (!this.ctx || !this.master) return;
      if (!hit.buffer) return;

      // safety: cap concurrent nodes
      if (this.activeSources.size >= this.maxConcurrent){
        // drop lowest-importance hits (ghost first)
        if (hit.accentLevel <= 1) return;
      }

      const src = this.ctx.createBufferSource();
      src.buffer = hit.buffer;

      const g = this.ctx.createGain();
      g.gain.value = hit.gain;

      const p = (this.ctx.createStereoPanner) ? this.ctx.createStereoPanner() : null;
      if (p) p.pan.value = hit.pan;

      if (p){
        src.connect(g).connect(p).connect(this.master);
      }else{
        src.connect(g).connect(this.master);
      }

      src.start(time);
      this.activeSources.add(src);
      src.onended = () => this.activeSources.delete(src);
    }
  }

  // ====== Transient Analysis (fast, no FFT) ======
  function analyzeBufferFast(audioBuffer){
    // Downmix to mono, decimate for speed.
    const sr = audioBuffer.sampleRate;
    const ch = audioBuffer.numberOfChannels;
    const len = audioBuffer.length;

    const targetSR = 11025;
    const dec = Math.max(1, Math.floor(sr / targetSR));
    const N = Math.floor(len / dec);

    let x = new Float32Array(N);
    for (let i=0, j=0; j<N; j++, i+=dec){
      let s = 0;
      for (let c=0; c<ch; c++){
        s += audioBuffer.getChannelData(c)[i] || 0;
      }
      x[j] = s / ch;
    }

    const dur = audioBuffer.duration;

    // Simple lowpass for low band.
    const fc = 200;
    const w = 2*Math.PI*fc/targetSR;
    const a = w / (w + 1);
    let lp = 0;

    let sumSq = 0, sumLpSq = 0, sumHpSq = 0;
    let peak = 0;
    let zc = 0;
    let prev = x[0] || 0;
    let prevSign = prev >= 0 ? 1 : -1;

    // Envelope for transients
    let env = 0;
    const envA = 0.02; // fast attack
    const envR = 0.004; // release
    let maxDiff = 0;
    let prevEnv = 0;

    // peak counting
    const diffs = new Float32Array(N);
    for (let i=1;i<N;i++){
      const s = x[i];
      const abs = Math.abs(s);
      peak = Math.max(peak, abs);

      // zcr
      const sign = s >= 0 ? 1 : -1;
      if (sign !== prevSign) zc++;
      prevSign = sign;

      // lowpass
      lp = lp + a*(s - lp);
      const hp = s - lp;

      sumSq += s*s;
      sumLpSq += lp*lp;
      sumHpSq += hp*hp;

      // envelope
      const target = abs;
      const coef = (target > env) ? envA : envR;
      env = env + coef*(target - env);
      const d = env - prevEnv;
      diffs[i] = d;
      if (d > maxDiff) maxDiff = d;
      prevEnv = env;

      prev = s;
    }

    const rms = Math.sqrt(sumSq / Math.max(1, N));
    const lpRms = Math.sqrt(sumLpSq / Math.max(1, N));
    const hpRms = Math.sqrt(sumHpSq / Math.max(1, N));
    const zcr = zc / Math.max(1, N);

    // Count peaks in diff envelope
    const thresh = Math.max(0.0006, maxDiff * 0.23);
    let peaks = 0;
    for (let i=2;i<N-2;i++){
      const v = diffs[i];
      if (v > thresh && v > diffs[i-1] && v >= diffs[i+1]) peaks++;
    }

    const bandRatio = hpRms / (lpRms + 1e-9);

    // "Punch" score
    const punch = clamp((maxDiff*2500) + (peak*1.2) + (rms*0.8), 0, 999);

    return {
      dur, rms, peak, lpRms, hpRms, zcr, bandRatio,
      transientMax: maxDiff,
      transientCount: peaks,
      punch
    };
  }

  function classify(features){
    const {dur, lpRms, hpRms, zcr, bandRatio, transientMax, transientCount} = features;

    // Heuristic gates
    const isShort = dur < 0.7;
    const isVeryShort = dur < 0.35;
    const lowHeavy = lpRms > hpRms * 1.8;
    const highHeavy = hpRms > lpRms * 2.2;
    const noisy = zcr > 0.08;
    const strongTransient = transientMax > 0.0009;

    if (dur > 1.0 && lowHeavy && !noisy) return 'BASS';
    if (lowHeavy && strongTransient && isShort) return 'KICK';
    if (highHeavy && noisy && isVeryShort) return 'HAT';
    if (!lowHeavy && !highHeavy && strongTransient && isShort){
      if (transientCount >= 3 && dur < 0.6) return 'CLAP';
      return 'SNARE';
    }
    if (highHeavy && strongTransient && isShort) return 'HAT';
    if (dur > 1.4) return 'FX';
    return 'PERC';
  }

  // ====== Pattern generator ("memory": anchor + variation) ======
  function seededRng(seed){
    let s = seed >>> 0;
    return () => {
      // xorshift32
      s ^= s << 13; s >>>= 0;
      s ^= s >> 17; s >>>= 0;
      s ^= s << 5;  s >>>= 0;
      return (s >>> 0) / 4294967296;
    };
  }

  function makeEmptyPattern(bars){
    const rows = [
      {name:'KICK', bus:'KICK', muted:false, steps:[], sampleIds:[]},
      {name:'SNARE', bus:'SNARE', muted:false, steps:[], sampleIds:[]},
      {name:'HAT', bus:'HAT', muted:false, steps:[], sampleIds:[]},
      {name:'CLAP', bus:'CLAP', muted:false, steps:[], sampleIds:[]},
      {name:'BASS', bus:'BASS', muted:false, steps:[], sampleIds:[]},
      {name:'PERC/FX', bus:'PERC', muted:false, steps:[], sampleIds:[]},
    ];
    const total = bars * 16;
    for (const r of rows) r.steps = new Array(total).fill(0); // 0 empty, 1 ghost, 2 hit, 3 accent
    return {bars, rows, stepsPerBar:16};
  }

  function genPattern(pattern, knobs, rng){
    const {complexity, variation} = knobs;
    const C = clamp(complexity/100, 0, 1);
    const V = clamp(variation/100, 0, 1);

    const bars = pattern.bars;
    const total = bars * 16;

    // Clear
    for (const r of pattern.rows){
      r.steps.fill(0);
    }

    const put = (rowName, step, val) => {
      const r = pattern.rows.find(x => x.bus === rowName || x.name === rowName);
      if (!r) return;
      if (step < 0 || step >= total) return;
      r.steps[step] = Math.max(r.steps[step], val);
    };

    // Anchors (stable motifs)
    for (let b=0;b<bars;b++){
      const o = b*16;
      // Kick: 1 and 3, plus occasional pickup
      put('KICK', o+0, 3);
      put('KICK', o+8, 2);
      if (rng() < 0.55*C) put('KICK', o+11, 2);

      // Snare: 2 and 4
      put('SNARE', o+4, 3);
      put('SNARE', o+12, 3);
      if (rng() < 0.40*C) put('SNARE', o+15, 1);

      // Hat: 8ths base
      for (const s of [0,2,4,6,8,10,12,14]){
        put('HAT', o+s, 2);
      }
      // accents on offbeats depending on V
      if (rng() < 0.7) put('HAT', o+2, 3);
      if (rng() < 0.7) put('HAT', o+10, 3);
      if (rng() < 0.25 + 0.5*V) put('HAT', o+15, 1);

      // Clap: optional, syncopation
      if (rng() < 0.25 + 0.35*C) put('CLAP', o+12, 2);

      // Bass: sparse anchor, more when complex
      if (rng() < 0.55*C) put('BASS', o+0, 2);
      if (rng() < 0.35*C) put('BASS', o+10, 2);
      if (rng() < 0.25*C) put('BASS', o+14, 1);

      // Perc: sprinkle with memory (repeatable positions)
      const percPos = [3,7,9,13,15];
      for (const p of percPos){
        if (rng() < (0.10 + 0.22*C)) put('PERC', o+p, rng()<0.35 ? 1 : 2);
      }
    }

    // Variation layer (controlled randomness)
    const varyRow = (bus, prob, accentProb) => {
      const r = pattern.rows.find(x => x.bus === bus || x.name === bus);
      if (!r) return;
      for (let i=0;i<total;i++){
        if (r.steps[i] === 0 && rng() < prob){
          r.steps[i] = (rng() < accentProb) ? 3 : 2;
        } else if (r.steps[i] >= 2 && rng() < (0.06 + 0.14*V)){
          // occasional removal for air
          r.steps[i] = (rng() < 0.5) ? 1 : 0;
        }
      }
    };

    varyRow('KICK', 0.03 + 0.08*C, 0.25);
    varyRow('SNARE', 0.02 + 0.06*C, 0.18);
    varyRow('HAT', 0.05 + 0.25*C, 0.14);
    varyRow('CLAP', 0.02 + 0.10*C, 0.22);
    varyRow('BASS', 0.02 + 0.10*C, 0.12);
    varyRow('PERC', 0.05 + 0.22*C, 0.18);

    return pattern;
  }

  // ====== App State ======
  const elStatus = $('statusLine');
  const logger = new Logger(elStatus, $('logBox'));

  const engine = new AudioEngine(logger);

  const state = {
    files: [],          // {file, id, status, buffer?, features?, type?}
    selectedFileId: null,
    cursor: {row:0, step:0},
    viewBar: 'follow', // 'follow' or '1'..'N'
    playheadStep: 0,
    glyphSet: 'ascii',
    seed: null,         // number or null for auto
    pattern: makeEmptyPattern(2),
    busMap: { KICK:[], SNARE:[], HAT:[], CLAP:[], BASS:[], PERC:[], FX:[] },
  };

  const glyphs = {
    ascii: {empty:'.', ghost:':', hit:'*', accent:'#'},
    blocks:{empty:'·', ghost:'░', hit:'▒', accent:'█'},
    dots:  {empty:'·', ghost:'∘', hit:'•', accent:'◆'},
  };

  
  function updateViewBarOptions(){
    const sel = $('viewBar');
    if (!sel) return;
    const current = String(state.viewBar);
    sel.innerHTML = '';
    const optFollow = document.createElement('option');
    optFollow.value = 'follow';
    optFollow.textContent = 'VIEW: FOLLOW';
    sel.appendChild(optFollow);
    for (let i=1;i<=state.pattern.bars;i++){
      const o = document.createElement('option');
      o.value = String(i);
      o.textContent = `VIEW: BAR ${i}`;
      sel.appendChild(o);
    }
    const values = Array.from(sel.options).map(o=>o.value);
    state.viewBar = values.includes(current) ? current : 'follow';
    sel.value = String(state.viewBar);
  }

function updateLegend(){
    const g = glyphs[state.glyphSet] || glyphs.ascii;
    $('legendEmpty').textContent = g.empty;
    $('legendGhost').textContent = g.ghost;
    $('legendHit').textContent = g.hit;
    $('legendAccent').textContent = g.accent;
  }

  function setMode(s){
    $('modeLine').textContent = s;
  }

  function updateKV(){
    $('kvFiles').textContent = String(state.files.length);
    const decoded = state.files.filter(f => f.buffer).length;
    const analyzed = state.files.filter(f => f.features).length;
    $('kvDecoded').textContent = String(decoded);
    $('kvAnalyzed').textContent = String(analyzed);

    if (engine.ctx){
      $('kvCtx').textContent = `${engine.ctx.state}@${engine.ctx.sampleRate}Hz`;
    } else {
      $('kvCtx').textContent = '—';
    }
  }

  function buildStepHeader(){
    const el = $('stepHeader');
    el.innerHTML = '';
    const total = state.pattern.bars * 16;
    // we render only first bar header (16) because grid is 16 cols; bars are represented by paging in playback, not in UI.
    // (keeping UI narrow by design)
    const row = document.createElement('div');
    row.className = 'h0';
    row.textContent = 'STEP';
    el.appendChild(row);
    for (let i=0;i<16;i++){
      const d = document.createElement('div');
      d.textContent = (i===0)?'1':String(i+1);
      el.appendChild(d);
    }
  }

  function buildGrid(){
    const grid = $('seqGrid');
    grid.innerHTML = '';
    buildStepHeader();

    const g = glyphs[state.glyphSet] || glyphs.ascii;

    const total = state.pattern.bars * 16;
    // Narrow UI: show 16 steps at a time, with a VIEW bar selector.
    // VIEW: FOLLOW = show bar containing playhead while playing, otherwise bar containing cursor.
    let barIndex;
    if (state.viewBar === 'follow'){
      barIndex = engine.isRunning ? Math.floor(state.playheadStep / 16) : Math.floor(state.cursor.step / 16);
    } else {
      const vb = parseInt(state.viewBar, 10);
      barIndex = isFinite(vb) ? clamp(vb-1, 0, state.pattern.bars-1) : 0;
    }
    const base = barIndex * 16;

    const title = `Pattern: ${state.pattern.bars} bar(s) // viewing BAR ${barIndex+1}`;
    $('seqTitle').textContent = title;

    // update selection line
    $('selLine').textContent = `${state.pattern.rows[state.cursor.row].name} @ step ${((state.cursor.step%16)+1)} (bar ${barIndex+1})`;

    // Render rows
    for (let r=0; r<state.pattern.rows.length; r++){
      const row = state.pattern.rows[r];

      const label = document.createElement('div');
      label.className = 'rowLabel';
      label.textContent = row.muted ? `[M] ${row.name}` : row.name;
      grid.appendChild(label);

      for (let c=0; c<16; c++){
        const step = base + c;
        const v = row.steps[step] || 0;

        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.row = String(r);
        cell.dataset.step = String(step);

        let ch = g.empty;
        if (v===1){ ch = g.ghost; cell.classList.add('ghost'); }
        else if (v===2){ ch = g.hit; cell.classList.add('hit'); }
        else if (v===3){ ch = g.accent; cell.classList.add('accent'); }
        else { cell.classList.add('off'); }

        cell.textContent = ch;

        // cursor
        if (state.cursor.row === r && state.cursor.step === step){
          cell.classList.add('cursor');
        }

        cell.addEventListener('click', () => {
          setCursor(r, step);
          toggleHit();
        });

        cell.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          setCursor(r, step);
          cycleHit();
        });

        grid.appendChild(cell);
      }
    }

    // Inspector
    renderInspector();
  }

  function setCursor(r, step){
    state.cursor.row = clamp(r, 0, state.pattern.rows.length-1);
    state.cursor.step = clamp(step, 0, state.pattern.bars*16-1);
    buildGrid();
  }

  function getCurrentRow(){
    return state.pattern.rows[state.cursor.row];
  }

  function toggleHit(){
    const row = getCurrentRow();
    const i = state.cursor.step;
    row.steps[i] = (row.steps[i] === 0) ? 2 : 0;
    buildGrid();
  }

  function cycleHit(){
    const row = getCurrentRow();
    const i = state.cursor.step;
    row.steps[i] = (row.steps[i] + 1) % 4;
    buildGrid();
  }

  function setCell(val){
    const row = getCurrentRow();
    row.steps[state.cursor.step] = val;
    buildGrid();
  }

  function toggleMuteRow(){
    const row = getCurrentRow();
    row.muted = !row.muted;
    buildGrid();
  }

  // ====== Files UI ======
  function renderFileList(){
    const el = $('fileList');
    el.innerHTML = '';
    if (state.files.length === 0){
      el.textContent = 'No files loaded.';
      return;
    }
    for (const f of state.files){
      const div = document.createElement('div');
      div.className = 'fileItem' + (state.selectedFileId === f.id ? ' selected':'');
      div.tabIndex = 0;

      const left = document.createElement('div');
      left.className = 'name';
      left.textContent = safeName(f.file);

      const right = document.createElement('div');
      let tag = '';
      if (f.type) tag = f.type;
      else if (f.buffer) tag = 'DECODED';
      else tag = f.status || 'LOADED';
      right.className = 'tag';
      right.textContent = tag;

      div.appendChild(left);
      div.appendChild(right);

      div.addEventListener('click', () => {
        state.selectedFileId = f.id;
        renderFileList();
        renderInspector();
      });

      div.addEventListener('dblclick', async () => {
        state.selectedFileId = f.id;
        renderFileList();
        await previewSelectedSample();
      });

      el.appendChild(div);
    }
  }

  function getSelectedFile(){
    return state.files.find(x => x.id === state.selectedFileId) || null;
  }

  function renderInspector(){
    const sel = getSelectedFile();
    const row = getCurrentRow();
    const bar = Math.floor(state.cursor.step/16)+1;
    const stepInBar = (state.cursor.step%16)+1;

    let txt = '';
    txt += `CELL: ${row.name} // bar=${bar}, step=${stepInBar}\n`;
    txt += `HIT: ${['EMPTY','GHOST','HIT','ACCENT'][row.steps[state.cursor.step]]}\n\n`;

    if (!sel){
      txt += 'FILE: (none selected)\n';
      txt += 'Select a file in the left list to inspect / preview.\n';
      $('inspector').textContent = txt;
      return;
    }

    txt += `FILE: ${safeName(sel.file)}\n`;
    txt += `SIZE: ${sel.file.size} bytes\n`;
    txt += `TYPE: ${sel.type || '(not analyzed)'}\n`;
    if (sel.buffer){
      txt += `DUR: ${fmt(sel.buffer.duration,3)} s\n`;
      txt += `SR : ${sel.buffer.sampleRate} Hz, CH: ${sel.buffer.numberOfChannels}\n`;
    }
    if (sel.features){
      const f = sel.features;
      txt += '\nFEATURES:\n';
      txt += `  rms=${fmt(f.rms,5)}  peak=${fmt(f.peak,5)}\n`;
      txt += `  lpRms=${fmt(f.lpRms,5)}  hpRms=${fmt(f.hpRms,5)}  ratio=${fmt(f.bandRatio,3)}\n`;
      txt += `  zcr=${fmt(f.zcr,4)}  transMax=${fmt(f.transientMax,6)}  transCount=${f.transientCount}\n`;
      txt += `  punch=${fmt(f.punch,2)}\n`;
    }

    txt += '\nASSIGN:\n';
    txt += '  Press 1..6 to force category:\n';
    txt += '    1=KICK 2=SNARE 3=HAT 4=CLAP 5=BASS 6=PERC/FX\n';
    txt += '  Tab cycles selected sample.\n';
    $('inspector').textContent = txt;
  }

  // ====== Category assignment ======
  function rebuildBusMap(){
    state.busMap = { KICK:[], SNARE:[], HAT:[], CLAP:[], BASS:[], PERC:[], FX:[] };
    for (const f of state.files){
      const t = f.type || 'PERC';
      if (t === 'FX') state.busMap.FX.push(f);
      else if (state.busMap[t]) state.busMap[t].push(f);
      else state.busMap.PERC.push(f);
    }
    // Merge FX into PERC/FX row pool
  }

  function assignSelectedType(t){
    const sel = getSelectedFile();
    if (!sel) return;
    sel.type = t;
    rebuildBusMap();
    renderFileList();
    renderInspector();
    toast.show(`Assigned: ${safeName(sel.file)} -> ${t}`);
    logger.log(`Manual assign: ${safeName(sel.file)} -> ${t}`);
  }

  function cycleSelectedSample(){
    if (state.files.length === 0) return;
    if (state.selectedFileId == null){
      state.selectedFileId = state.files[0].id;
    } else {
      const idx = state.files.findIndex(x => x.id === state.selectedFileId);
      const next = state.files[(idx+1) % state.files.length];
      state.selectedFileId = next.id;
    }
    renderFileList();
    renderInspector();
  }

  // ====== Preview ======
  async function previewSelectedSample(){
    const sel = getSelectedFile();
    if (!sel || !sel.buffer) { toast.show('No decoded buffer to preview.'); return; }
    try{
      await engine.ensure();
      const t = engine.ctx.currentTime + 0.02;
      engine.trigger({
        buffer: sel.buffer,
        gain: 0.9,
        pan: 0,
        accentLevel: 3,
        label: 'PREVIEW'
      }, t);
      toast.show('Preview: triggered.');
    }catch(err){
      logger.log(`Preview failed: ${err.message || err}`, 'ERR');
      toast.show('Preview failed. See DEBUG.');
    }
  }

  // ====== Decoding pipeline (throttled) ======
  async function decodeAll(concurrency=2){
    if (state.files.length === 0) return;
    setMode('Decoding');
    await engine.ensure();
    updateKV();
    let idx = 0;
    let inFlight = 0;

    return await new Promise((resolve) => {
      const next = async () => {
        if (idx >= state.files.length && inFlight === 0){
          setMode('Idle');
          updateKV();
          renderFileList();
          resolve(true);
          return;
        }
        while (inFlight < concurrency && idx < state.files.length){
          const item = state.files[idx++];
          if (item.buffer){ continue; }

          inFlight++;
          item.status = 'DECODING';
          renderFileList();

          (async () => {
            try{
              const buf = await engine.decodeFile(item.file);
              item.buffer = buf;
              item.status = 'DECODED';
              logger.log(`decodeAudioData OK: "${safeName(item.file)}" dur=${fmt(buf.duration,3)}s sr=${buf.sampleRate} ch=${buf.numberOfChannels}`);
            }catch(err){
              item.status = 'DECODE FAIL';
              item.error = String(err?.message || err);
              logger.log(`decodeAudioData FAIL: "${safeName(item.file)}" err=${item.error}`, 'ERR');
            }finally{
              inFlight--;
              updateKV();
              renderFileList();
              next();
            }
          })();
        }
      };
      next();
    });
  }

  // ====== Analysis ======
  async function analyzeAll(){
    if (state.files.length === 0) return;
    setMode('Analyzing');
    logger.log(`ANALYZE: start (${state.files.length} files).`);
    await decodeAll(2);

    let ok = 0, fail = 0;
    for (const item of state.files){
      if (!item.buffer){ fail++; continue; }
      try{
        item.features = analyzeBufferFast(item.buffer);
        item.type = classify(item.features);
        ok++;
      }catch(err){
        item.features = null;
        item.type = null;
        fail++;
        logger.log(`Analyze FAIL: "${safeName(item.file)}" err=${err.message || err}`, 'ERR');
      }
      if ((ok+fail) % 10 === 0){
        logger.log(`ANALYZE: progress ${ok+fail}/${state.files.length}`);
      }
    }

    rebuildBusMap();
    setMode('Idle');
    updateKV();
    renderFileList();
    renderInspector();
    logger.log(`ANALYZE: done ok=${ok}, fail=${fail}.`);
    toast.show(`Analyze done. ok=${ok}, fail=${fail}`, 3000);
  }

  // ====== Auto-assign (re-run classifier only) ======
  function autoAssign(){
    let n = 0;
    for (const item of state.files){
      if (!item.features || !item.buffer) continue;
      item.type = classify(item.features);
      n++;
    }
    rebuildBusMap();
    renderFileList();
    renderInspector();
    toast.show(`Auto-assign updated for ${n} file(s).`);
    logger.log(`AUTO-ASSIGN: ${n} files.`);
  }

  // ====== Pattern ↔ sample mapping ======
  function pickSampleForBus(bus, accentLevel, rng){
    let pool = [];
    if (bus === 'PERC'){
      pool = [...state.busMap.PERC, ...state.busMap.FX];
    } else {
      pool = state.busMap[bus] || [];
    }
    if (!pool || pool.length === 0) return null;

    // Choose based on "punch": strong accents prefer punchy samples.
    const sorted = pool.slice().sort((a,b) => (b.features?.punch||0) - (a.features?.punch||0));
    if (accentLevel === 3){
      const top = sorted.slice(0, Math.min(8, sorted.length));
      return top[Math.floor(rng()*top.length)];
    } else if (accentLevel === 2){
      const mid = sorted.slice(0, Math.min(14, sorted.length));
      return mid[Math.floor(rng()*mid.length)];
    } else {
      return sorted[Math.floor(rng()*sorted.length)];
    }
  }

  function busPan(bus){
    // Subtle stereo layout, not DAW-like.
    switch(bus){
      case 'KICK': return 0.00;
      case 'SNARE': return -0.08;
      case 'CLAP': return 0.10;
      case 'HAT': return 0.22;
      case 'BASS': return -0.18;
      case 'PERC': return 0.30;
      default: return 0;
    }
  }

  function levelGain(level){
    // 0 empty, 1 ghost, 2 hit, 3 accent
    if (level === 1) return 0.22;
    if (level === 2) return 0.55;
    if (level === 3) return 0.95;
    return 0;
  }

  function buildEventGetter(){
    const bars = state.pattern.bars;
    const total = bars * 16;
    const rng = seededRng(getSeed());
    return (step) => {
      const events = [];
      for (const row of state.pattern.rows){
        if (row.muted) continue;
        const level = row.steps[step] || 0;
        if (level === 0) continue;

        const bus = (row.name === 'PERC/FX') ? 'PERC' : row.bus;
        const sample = pickSampleForBus(bus, level, rng);
        if (!sample || !sample.buffer) continue;

        events.push({
          buffer: sample.buffer,
          gain: levelGain(level),
          pan: busPan(bus),
          accentLevel: level,
          muted: false,
          label: `${row.name}:${level}`
        });
      }
      return events;
    };
  }

  // ====== Seed ======
  function getSeed(){
    if (typeof state.seed === 'number') return state.seed >>> 0;
    // Auto seed: stable within a session by default
    if (state._autoSeed == null){
      state._autoSeed = (Math.random()*0xFFFFFFFF) >>> 0;
    }
    return state._autoSeed;
  }

  function toggleSeed(){
    if (typeof state.seed === 'number'){
      state.seed = null;
      $('btnSeed').textContent = 'SEED: AUTO';
      toast.show('Seed set to AUTO.');
    } else {
      // derive from time
      const s = (Date.now() & 0xFFFFFFFF) >>> 0;
      state.seed = s;
      $('btnSeed').textContent = `SEED: ${s.toString(16).toUpperCase()}`;
      toast.show('Seed locked (from time).');
    }
    logger.log(`Seed changed: ${typeof state.seed === 'number' ? state.seed : 'AUTO'}`);
  }

  // ====== Generate ======
  function generate(){
    state.pattern.bars = parseInt($('bars').value, 10);
    state.pattern = makeEmptyPattern(state.pattern.bars);

    const rng = seededRng(getSeed());
    const knobs = {
      complexity: clamp(parseInt($('complexity').value,10) || 0, 0, 100),
      variation: clamp(parseInt($('variation').value,10) || 0, 0, 100),
    };
    genPattern(state.pattern, knobs, rng);

    // Keep cursor in range
    state.cursor.row = clamp(state.cursor.row, 0, state.pattern.rows.length-1);
    state.cursor.step = clamp(state.cursor.step, 0, state.pattern.bars*16-1);

    // Update engine pattern
    engine.setPattern(state.pattern);

    updateViewBarOptions();
    buildGrid();
    updateKV();

    const poolInfo = `Pools: K=${state.busMap.KICK.length} S=${state.busMap.SNARE.length} H=${state.busMap.HAT.length} C=${state.busMap.CLAP.length} B=${state.busMap.BASS.length} P+F=${state.busMap.PERC.length+state.busMap.FX.length}`;
    $('seqTitle').textContent = `Generated ${state.pattern.bars} bar(s). ${poolInfo}`;
    logger.log(`GENERATE: bars=${state.pattern.bars}, complexity=${knobs.complexity}, variation=${knobs.variation}. ${poolInfo}`);
    toast.show('Pattern generated.');
  }

  function resetGrid(){
    const bars = parseInt($('bars').value, 10) || 2;
    state.pattern = makeEmptyPattern(bars);
    engine.setPattern(state.pattern);
    state.cursor = {row:0, step:0};
    updateViewBarOptions();
    buildGrid();
    logger.log('Grid reset.');
    toast.show('Grid reset.');
  }

  // ====== Play/Stop ======
  async function play(){
    try{
      await engine.ensure();
      engine.setPattern(state.pattern);

      const getter = buildEventGetter();

      const getBpm = () => clamp(parseFloat($('tempo').value) || 120, 40, 260);
      const getSwing = () => clamp(parseFloat($('swing').value) || 0, 0, 75);

      engine.onStep = (s) => {
        // blink cursor on current step position (bar view follows cursor, so update step only)
        state.playheadStep = s;
        if (state.viewBar === 'follow'){
          // rebuild grid only when bar changes
          const showing = Math.floor((engine.isRunning ? state.playheadStep : state.cursor.step) / 16);
          const want = Math.floor(s / 16);
          if (engine.isRunning && want !== showing){
            buildGrid();
          }
        }
        highlightPlaybackStep(s);
        $('clockTitle').textContent = `PLAYHEAD: step ${(s%16)+1} / 16  (bar ${Math.floor(s/16)+1} / ${state.pattern.bars})`;
      };

      engine.start(getter, getBpm, getSwing);
      setMode('Playing');
      toast.show('PLAY.');
    }catch(err){
      logger.log(`PLAY failed: ${err.message || err}`, 'ERR');
      toast.show('PLAY failed. See DEBUG.');
    }
    updateKV();
  }

  function stop(){
    engine.stop();
    setMode('Idle');
    $('clockTitle').textContent = '—';
    clearPlaybackHighlight();
    toast.show('STOP.');
    updateKV();
  }

  function highlightPlaybackStep(globalStep){
    // highlight the cell that corresponds to globalStep in the currently displayed bar
    let barIndex;
    if (state.viewBar === 'follow'){
      barIndex = Math.floor((engine.isRunning ? state.playheadStep : state.cursor.step) / 16);
    } else {
      const vb = parseInt(state.viewBar, 10);
      barIndex = isFinite(vb) ? clamp(vb-1, 0, state.pattern.bars-1) : 0;
    }
    const base = barIndex * 16;
    if (globalStep < base || globalStep >= base + 16) return;

    const c = globalStep - base;
    const grid = $('seqGrid');
    const cells = grid.querySelectorAll('.cell');
    cells.forEach(el => el.classList.remove('cursorBlink'));
    // find cells at column c across rows: layout: label + 16 cells per row
    const rows = state.pattern.rows.length;
    for (let r=0; r<rows; r++){
      const idx = r*(1+16) + 1 + c;
      const el = grid.children[idx];
      if (el && el.classList.contains('cell')) el.classList.add('cursorBlink');
    }
  }

  function clearPlaybackHighlight(){
    const grid = $('seqGrid');
    if (!grid) return;
    grid.querySelectorAll('.cell').forEach(el => el.classList.remove('cursorBlink'));
  }

  // ====== Export log ======
  function downloadText(filename, text){
    const blob = new Blob([text], {type:'text/plain;charset=utf-8'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 800);
  }

  function exportLog(){
    const sys = [
      '=== SYSTEM ===',
      `UserAgent: ${navigator.userAgent}`,
      `Platform : ${navigator.platform}`,
      `Time     : ${new Date().toString()}`,
      `URL      : ${location.href}`,
      `Secure   : ${location.protocol === 'https:'}`,
      `Ctx      : ${engine.ctx ? (engine.ctx.state+' @ '+engine.ctx.sampleRate+'Hz') : 'none'}`
    ].join('\n');

    const inv = [
      '\n=== INVENTORY ===',
      `Files total: ${state.files.length}`,
      ...state.files.map(f => {
        const ft = f.features || {};
        return `- ${safeName(f.file)} | status=${f.status||''} | type=${f.type||''} | dur=${f.buffer?fmt(f.buffer.duration,3):'—'} | punch=${ft.punch??'—'} | err=${f.error||''}`;
      })
    ].join('\n');

    const text = sys + '\n\n' + logger.exportText() + '\n' + inv + '\n';
    const ts = new Date().toISOString().replace(/[:.]/g,'-');
    downloadText(`tc_dos_log_${ts}.txt`, text);
    toast.show('Exported log.');
  }

  // ====== Load files ======
  function clearAll(){
    stop();
    state.files = [];
    state.selectedFileId = null;
    state.busMap = { KICK:[], SNARE:[], HAT:[], CLAP:[], BASS:[], PERC:[], FX:[] };
    resetGrid();
    renderFileList();
    renderInspector();
    updateKV();
    logger.log('CLEAR: all state reset.');
    toast.show('Cleared.');
  }

  function addFiles(fileList){
    const files = Array.from(fileList || []);
    if (files.length === 0) return;

    // Keep only audio-like.
    const audioFiles = files.filter(f => (f && (f.type.startsWith('audio/') || /\.(wav|mp3|aif|aiff|flac|ogg|m4a)$/i.test(f.name||''))));
    if (audioFiles.length === 0){
      toast.show('No audio files detected.');
      return;
    }

    const cap = 200;
    const remaining = cap - state.files.length;
    const toAdd = audioFiles.slice(0, Math.max(0, remaining));
    if (toAdd.length === 0){
      toast.show('File cap reached (200).');
      return;
    }

    const startId = state.files.length ? Math.max(...state.files.map(x => x.id)) + 1 : 1;
    toAdd.forEach((file, i) => {
      state.files.push({ id: startId+i, file, status:'LOADED', buffer:null, features:null, type:null, error:null });
    });

    if (state.selectedFileId == null && state.files.length > 0){
      state.selectedFileId = state.files[0].id;
    }

    logger.log(`LOAD: added ${toAdd.length} file(s). total=${state.files.length}`);
    toast.show(`Loaded ${toAdd.length} file(s).`);
    renderFileList();
    renderInspector();
    updateKV();
  }

  async function pickFiles(){
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'audio/*';
    input.multiple = true;
    input.addEventListener('change', async () => {
      addFiles(input.files);
    });
    input.click();
  }

  // ====== Help ======
  function showHelp(){
    const msg =
`HELP // QUICK START

1) LOAD FILES (or drag & drop)
2) ANALYZE
   - Decodes audio + estimates transients & band-energy
   - Classifies into: KICK / SNARE / HAT / CLAP / BASS / PERC / FX
3) GENERATE
   - Creates a 16-step grid per bar (narrow DOS layout)
   - Uses "memory" anchors + controlled variation
4) PLAY

Troubleshooting
- If you used file:// and decoding/playback is unreliable, serve via localhost:
  python3 -m http.server 8000
  then open: http://localhost:8000/index.html
- If audio is silent: click PLAY once to unlock AudioContext.
- Export log (EXPORT LOG) if something fails.

Editing
- Click: toggle hit
- Right-click: cycle empty→ghost→hit→accent
- 1..6: force category for selected sample
- Enter: preview selected sample
`;
    toast.show(msg, 10000);
  }

  // ====== Keyboard controls ======
  function handleKey(e){
    const k = e.key;
    const rMax = state.pattern.rows.length - 1;
    const sMax = state.pattern.bars*16 - 1;
    let handled = true;

    if (k === 'ArrowUp') setCursor(state.cursor.row - 1, state.cursor.step);
    else if (k === 'ArrowDown') setCursor(state.cursor.row + 1, state.cursor.step);
    else if (k === 'ArrowLeft') setCursor(state.cursor.row, state.cursor.step - 1);
    else if (k === 'ArrowRight') setCursor(state.cursor.row, state.cursor.step + 1);
    else if (k === ' ') { e.preventDefault(); toggleHit(); }
    else if (k === 'a' || k === 'A') setCell(3);
    else if (k === 'g' || k === 'G') setCell(1);
    else if (k === 'm' || k === 'M') toggleMuteRow();
    else if (k === 'Tab'){ e.preventDefault(); cycleSelectedSample(); }
    else if (k === 'Enter'){ previewSelectedSample(); }
    else if (k === '1') assignSelectedType('KICK');
    else if (k === '2') assignSelectedType('SNARE');
    else if (k === '3') assignSelectedType('HAT');
    else if (k === '4') assignSelectedType('CLAP');
    else if (k === '5') assignSelectedType('BASS');
    else if (k === '6') assignSelectedType('PERC');
    else handled = false;

    if (handled){
      renderInspector();
    }
  }

  // ====== UI wiring ======
  $('btnPick').addEventListener('click', pickFiles);
  $('btnClear').addEventListener('click', clearAll);
  $('btnAnalyze').addEventListener('click', analyzeAll);
  $('btnAutoAssign').addEventListener('click', autoAssign);
  $('btnExport').addEventListener('click', exportLog);

  $('btnGen').addEventListener('click', generate);
  $('btnPlay').addEventListener('click', play);
  $('btnStop').addEventListener('click', stop);

  $('btnSeed').addEventListener('click', toggleSeed);
  $('btnReset').addEventListener('click', resetGrid);

  $('btnHelp').addEventListener('click', showHelp);

  $('btnDbg').addEventListener('click', () => {
    $('debugBox').classList.toggle('hidden');
  });

  $('btnPanic').addEventListener('click', async () => {
    await engine.panic();
    updateKV();
    toast.show('Audio engine reset.');
  });

  $('glyphSet').addEventListener('change', () => {
    state.glyphSet = $('glyphSet').value;
    updateLegend();
    updateViewBarOptions();
    buildGrid();
    logger.log(`Glyph set: ${state.glyphSet}`);
  });

  
  const viewBarSel = $('viewBar');
  if (viewBarSel){
    viewBarSel.addEventListener('change', () => {
      state.viewBar = viewBarSel.value;
      buildGrid();
      logger.log(`View bar: ${state.viewBar}`);
    });
  }

// Compact mode (hide sidebar)
  $('btnCompact').addEventListener('click', () => {
    document.body.classList.toggle('compact');
    $('btnCompact').textContent = document.body.classList.contains('compact') ? 'SHOW PANEL' : 'HIDE PANEL';
  });

  // Drag & drop
  const dz = $('dropzone');
  dz.addEventListener('dragover', (e) => { e.preventDefault(); dz.classList.add('drag'); });
  dz.addEventListener('dragleave', () => dz.classList.remove('drag'));
  dz.addEventListener('drop', (e) => {
    e.preventDefault();
    dz.classList.remove('drag');
    if (e.dataTransfer?.files) addFiles(e.dataTransfer.files);
  });

  // Keyboard focus: global
  window.addEventListener('keydown', handleKey);

  // Cursor blink (DOS-ish)
  setInterval(() => {
    const grid = $('seqGrid');
    if (!grid) return;
    const cells = grid.querySelectorAll('.cell.cursor');
    cells.forEach(el => el.classList.toggle('cursorBlink'));
  }, 480);

  // Boot
  (async () => {
    logger.log('Boot.');
    if (location.protocol === 'file:'){
      logger.log('WARNING: file:// detected. Use localhost to avoid silent failures.', 'WARN');
      $('noteLine').innerHTML = 'Warning: <b class="warn">file://</b> detected. Use <b>localhost</b> for reliable audio.';
      toast.show('Warning: file:// detected. Use localhost (python3 -m http.server).', 6000);
    }

    updateLegend();
    renderFileList();
    updateKV();
    buildGrid();
    renderInspector();

    try{
      // Lazy init: create context only after a user gesture, but we can show capability.
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (!Ctx){
        logger.log('No Web Audio API available.', 'ERR');
        $('noteLine').textContent = 'This browser does not support Web Audio API.';
      }else{
        $('noteLine').textContent = 'Ready. Load → Analyze → Generate → Play. (Best on localhost)';
      }
    }catch(err){
      logger.log(`Boot error: ${err.message || err}`, 'ERR');
    }
  })();
})();
</script>
</body>
</html>
