<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>TCSEQ</title>
  <style>
    :root{
      --bg:#070707;
      --panel:#0f1114;
      --panel2:#0b0d10;
      --line:#2b2f36;
      --line2:#1e2229;
      --text:#e7e7e7;
      --muted:#a6a6a6;
      --muted2:#7a7a7a;
      --accent:#1a2a3d; /* deep blue, kept subtle */
      --accent2:#111820;
      --danger:#d04b4b;
      --ok:#6bd06b;
      --font: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family:var(--font);
      letter-spacing:0.2px;
    }
    button, select, input{
      font-family:var(--font);
      background:transparent;
      color:var(--text);
      border:1px solid var(--line);
      padding:6px 10px;
      font-size:12px;
      line-height:1;
      outline:none;
    }
    button{
      cursor:pointer;
      user-select:none;
    }
    button:hover, select:hover{border-color:#3b414a}
    button:active{transform:translateY(1px)}
    button.primary{
      border-color:#3b4655;
      background:var(--accent2);
    }
    button.primary:hover{background:var(--accent)}
    button.ghost{
      border-color:var(--line2);
      color:var(--muted);
    }
    button.ghost:hover{border-color:var(--line)}
    button.danger{border-color:rgba(208,75,75,.55); color:#ffd1d1}
    button[disabled], select[disabled]{opacity:.45; cursor:not-allowed}
    .app{
      height:100%;
      display:flex;
      flex-direction:column;
    }
    /* Top bar (no boxed TCSEQ) */
    .topbar{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      border-bottom:1px solid var(--line2);
      background:#050505;
    }

    /* === 修改部分开始：氤氲呼吸动画 === */
    @keyframes mist-breathe {
      0% {
        color: #8899a6;
        text-shadow: 0 0 2px rgba(255, 255, 255, 0.1);
        opacity: 0.7;
      }
      50% {
        color: #ffffff;
        text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.4), 0 0 30px rgba(255, 255, 255, 0.2);
        opacity: 1;
      }
      100% {
        color: #8899a6;
        text-shadow: 0 0 2px rgba(255, 255, 255, 0.1);
        opacity: 0.7;
      }
    }

    .brand{
      font-size:14px;
      letter-spacing:2px;
      margin-right:auto;
      user-select:none;
      /* 应用新样式 */
      font-weight: 700;
      animation: mist-breathe 5s ease-in-out infinite;
    }
    /* === 修改部分结束 === */

    .topbar .cluster{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .mini{
      font-size:11px;
      color:var(--muted);
      border:1px solid var(--line2);
      padding:5px 8px;
    }
    /* Main layout */
    .main{
      flex:1;
      min-height:0;
      display:grid;
      grid-template-columns: 340px 1fr;
      gap:10px;
      padding:10px;
    }
    .panel{
      border:1px solid var(--line2);
      background:var(--panel);
      min-height:0;
    }
    .left{
      display:flex;
      flex-direction:column;
      min-height:0;
      gap:10px;
    }
    .left .panel{padding:10px}
    .panel-title{
      font-size:12px;
      color:var(--muted);
      letter-spacing:1px;
      margin:0 0 8px 0;
      display:flex;
      align-items:center;
      justify-content:space-between;
    }
    .row{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .control-row{
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .control-row .leftbtns, .control-row .rightbtns{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .filelist{
      border:1px solid var(--line2);
      background:var(--panel2);
      padding:6px;
      height:240px;
      overflow:auto;
    }
    .fileitem{
      display:grid;
      grid-template-columns: 1fr 92px;
      gap:8px;
      padding:6px 6px;
      border-bottom:1px solid rgba(255,255,255,0.04);
      align-items:center;
    }
    .fileitem:last-child{border-bottom:none}
    .fname{
      cursor:pointer;
      color:#eaeaea;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      padding:2px 0;
    }
    .fname:hover{color:#ffffff; text-decoration:underline}
    .cat{
      justify-self:end;
      text-align:right;
      color:var(--muted);
      cursor:pointer;
      padding:2px 6px;
      border:1px solid var(--line2);
      background:#0a0c10;
      user-select:none;
    }
    .cat:hover{border-color:var(--line)}
    .fileitem.selected{
      background:rgba(26,42,61,.25);
      outline:1px solid rgba(255,255,255,0.06);
    }
    .hint{
      color:var(--muted2);
      font-size:11px;
      line-height:1.3;
      margin-top:8px;
    }

    /* Sequencer + right visuals */
    .work{
      display:flex;
      flex-direction:column;
      min-height:0;
      gap:10px;
    }
    .seqwrap{
      display:grid;
      grid-template-columns: 1fr 360px;
      gap:10px;
      min-height:0;
    }
    .sequencer{
      padding:10px;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .seq-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      margin-bottom:8px;
    }
    .seq-head .leftmeta{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      color:var(--muted);
      font-size:11px;
    }
    .seq-head .rightmeta{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-end;
    }
    .gridwrap{
      border:1px solid var(--line2);
      background:var(--panel2);
      padding:8px;
      overflow:auto;
      min-height:0;
    }
    .legend{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      align-items:center;
      color:var(--muted);
      font-size:11px;
      margin-bottom:8px;
      user-select:none;
    }
    .legend .sw{
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .swbox{
      width:10px;height:10px;
      border:1px solid var(--line2);
      background:#050607;
    }
    .swbox.ghost{background:#0b111a}
    .swbox.hit{background:#162437}
    .swbox.acc{background:#223d5c}
    .grid{
      display:grid;
      grid-template-columns: 90px repeat(16, 16px);
      gap:6px;
      align-items:center;
    }
    .rlabel{
      color:var(--muted);
      font-size:11px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      padding-right:4px;
    }
    .step{
      width:16px;height:16px;
      border:1px solid var(--line2);
      background:#050607;
      cursor:pointer;
      position:relative;
      user-select:none;
    }
    .step:hover{border-color:var(--line)}
    .step[data-state="1"]{background:#0b111a}
    .step[data-state="2"]{background:#162437}
    .step[data-state="3"]{background:#223d5c}
    .step.playing::after{
      content:"";
      position:absolute; inset:-2px;
      border:1px solid rgba(255,255,255,0.25);
      pointer-events:none;
    }
    .steps-header{
      display:grid;
      grid-template-columns: 90px repeat(16, 16px);
      gap:6px;
      margin-bottom:6px;
      align-items:center;
      color:var(--muted);
      font-size:10px;
      user-select:none;
    }
    .steps-header .h{ text-align:center; }
    .vispanel{
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .vis{
      border:1px solid var(--line2);
      background:var(--panel2);
      height:190px;
      position:relative;
      overflow:hidden;
    }
    canvas{
      width:100%;
      height:100%;
      display:block;
      image-rendering: pixelated;
    }
    .vislabel{
      position:absolute;
      top:8px; left:10px;
      font-size:11px;
      color:var(--muted);
      letter-spacing:1px;
      user-select:none;
      background:rgba(0,0,0,.25);
      padding:2px 6px;
      border:1px solid rgba(255,255,255,0.06);
    }

    /* Footer removed per spec; keep only a tiny status strip */
    .status{
      padding:6px 12px;
      border-top:1px solid var(--line2);
      color:var(--muted2);
      font-size:11px;
      background:#050505;
      display:flex;
      gap:10px;
      justify-content:space-between;
    }
    .status .right{white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:60%}

    /* Hidden panel mode */
    .hidden-left .main{
      grid-template-columns: 1fr;
    }
    .hidden-left .left{display:none}

    /* Modal */
    .modal-backdrop{
      position:fixed; inset:0;
      background:rgba(0,0,0,.72);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:50;
    }
    .modal{
      width:min(560px, 92vw);
      border:1px solid var(--line);
      background:#0b0c0f;
      padding:14px;
    }
    .modal h3{
      margin:0 0 10px 0;
      font-size:13px;
      color:#f0f0f0;
      letter-spacing:1px;
    }
    .modal .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .modal label{
      display:block;
      font-size:11px;
      color:var(--muted);
      margin-bottom:6px;
    }
    .modal .actions{
      margin-top:12px;
      display:flex;
      justify-content:flex-end;
      gap:8px;
      flex-wrap:wrap;
    }
    .kbd{
      border:1px solid var(--line2);
      padding:2px 6px;
      font-size:10px;
      color:var(--muted);
      background:#07090c;
    }
    .toast{
      position:fixed;
      left:12px;
      bottom:44px;
      border:1px solid var(--line2);
      background:#090a0d;
      padding:8px 10px;
      font-size:11px;
      color:var(--muted);
      display:none;
      z-index:60;
      max-width:min(560px, 92vw);
    }

    /* Responsive */
    @media (max-width: 980px){
      .main{grid-template-columns: 1fr; }
      .seqwrap{grid-template-columns: 1fr; }
      .vispanel{order:2}
      .sequencer{order:1}
      .filelist{height:200px}
      .vis{height:180px}
    }
  </style>
</head>
<body>
<div class="app" id="app">
  <div class="topbar">
    <div class="brand">TCSEQ</div>

    <div class="cluster">
      <button id="btnPlay" class="primary">PLAY</button>
      <button id="btnStop">STOP</button>
      <button id="btnRecord">RECORD</button>
      <button id="btnExport">EXPORT</button>
      <button id="btnHidePanel" class="ghost">HIDE PANEL</button>
      <button id="btnHelp" class="ghost">HELP</button>
    </div>
  </div>

  <div class="main">
    <div class="left">
      <div class="panel" id="controlPanel">
        <div class="panel-title">
          <span>CONTROL</span>
          <span class="mini" id="audioState">audio: idle</span>
        </div>

        <div class="control-row">
          <div class="leftbtns">
            <button id="btnLoad" class="primary">LOAD FILES</button>
            <button id="btnClear">CLEAR</button>
          </div>
          <div class="rightbtns">
            <button id="btnAnalyzeGenerate" class="primary">ANALYZE+GENERATE</button>
            <button id="btnDebug" class="ghost">DEBUG</button>
          </div>
        </div>

        <div class="filelist" id="fileList" tabindex="0" aria-label="file list"></div>

        <div class="hint">
          Click a filename to preview. Click the class label to manually correct classification.<br/>
          Keys: <span class="kbd">↑</span>/<span class="kbd">↓</span> select, <span class="kbd">Enter</span> preview, <span class="kbd">1-6</span> set class.
        </div>
      </div>
    </div>

    <div class="work">
      <div class="panel seqwrap">
        <div class="sequencer">
          <div class="panel-title">
            <span>SEQUENCER</span>
            <span class="mini" id="transport">bpm 170 • 1 bar • 16 steps</span>
          </div>

          <div class="seq-head">
            <div class="leftmeta">
              <span id="patternInfo">Pattern: 1 bar(s) // viewing BAR 1</span>
            </div>

            <div class="rightmeta">
              <label class="mini" style="display:flex; gap:8px; align-items:center;">
                VIEW
                <select id="viewMode">
                  <option value="follow">FOLLOW</option>
                  <option value="static">STATIC</option>
                </select>
              </label>

              <label class="mini" style="display:flex; gap:8px; align-items:center;">
                STYLE
                <select id="styleMode">
                  <option value="dnb">DNB</option>
                  <option value="jungle">JUNGLE</option>
                  <option value="breakbeat">BREAKBEAT</option>
                  <option value="minimal">MINIMAL</option>
                </select>
              </label>

              <label class="mini" style="display:flex; gap:8px; align-items:center;">
                DENS
                <input id="density" type="range" min="0" max="200" value="58" style="width:110px;">
              </label>
              <label class="mini" style="display:flex; gap:8px; align-items:center;">
                GLITCH
                <select id="glitchStyle">
                  <option value="stutter">STUTTER</option>
                  <option value="bitcrush">BITCRUSH</option>
                  <option value="tear">TEAR</option>
                </select>
              </label>

              <label class="mini" style="display:flex; gap:8px; align-items:center;">
                AMT
                <input id="glitchAmt" type="range" min="0" max="100" value="0" style="width:110px;" step="1">
              </label>

              <label class="mini" style="display:flex; gap:8px; align-items:center;">
                BPM
                <input id="bpmBar" type="range" min="60" max="220" value="170" style="width:140px;">
                <span id="bpmVal" style="min-width:32px; text-align:right;">170</span>
              </label>

              <button id="btnRandom" class="primary">RANDOM PATTERN</button>
              <button id="btnResetGrid">RESET GRID</button>
            </div>
          </div>

          <div class="gridwrap" id="gridWrap">
            <div class="legend">
              <span class="sw"><span class="swbox"></span> empty</span>
              <span class="sw"><span class="swbox ghost"></span> ghost</span>
              <span class="sw"><span class="swbox hit"></span> hit</span>
              <span class="sw"><span class="swbox acc"></span> accent</span>
              <span>Enter = preview (selected file)</span>
            </div>

            <div class="steps-header" id="stepsHeader"></div>
            <div class="grid" id="grid"></div>
          </div>
        </div>

        <div class="vispanel">
          <div class="vis">
            <div class="vislabel">8‑BIT SCENE</div>
            <canvas id="cvFighters" width="320" height="180"></canvas>
          </div>
          <div class="vis">
            <div class="vislabel">PSEUDO‑3D GEOMETRY</div>
            <canvas id="cvGeo" width="320" height="180"></canvas>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="status">
    <div id="statusLeft">ready</div>
    <div class="right" id="statusRight"></div>
  </div>
</div>

<div class="modal-backdrop" id="modalBackdrop" role="dialog" aria-modal="true" aria-labelledby="exportTitle">
  <div class="modal">
    <h3 id="exportTitle">EXPORT</h3>
    <div class="grid2">
      <div>
        <label>Format</label>
        <select id="exportFormat">
          <option value="wav">WAV (offline render)</option>
          <option value="webm">WEBM (real-time record)</option>
          <option value="mp3" disabled>MP3 (requires encoder)</option>
        </select>
      </div>
      <div>
        <label>Sample Rate</label>
        <select id="exportSR">
          <option value="44100">44100</option>
          <option value="48000" selected>48000</option>
        </select>
      </div>
      <div>
        <label>Length</label>
        <select id="exportBars">
          <option value="1">1 bar</option>
          <option value="2">2 bars</option>
          <option value="4" selected>4 bars</option>
          <option value="8">8 bars</option>
        </select>
      </div>
      <div>
        <label>Normalize</label>
        <select id="exportNorm">
          <option value="0">off</option>
          <option value="1" selected>on</option>
        </select>
      </div>
    </div>
    <div class="hint" style="margin-top:10px">
      WAV export is offline-rendered (no clicks/pops). WEBM export is recorded in real time. MP3 is disabled unless you add an encoder (e.g., lamejs).
    </div>
    <div class="actions">
      <button id="btnExportCancel">CANCEL</button>
      <button id="btnExportGo" class="primary">EXPORT NOW</button>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<input id="fileInput" type="file" accept="audio/*" multiple style="display:none"/>

<script>
(() => {
  "use strict";

  // ---------- Utilities ----------
  const $ = (id) => document.getElementById(id);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const now = () => performance.now();
  const toast = (msg, ms=2600) => {
    const t = $("toast");
    t.textContent = msg;
    t.style.display = "block";
    clearTimeout(toast._tm);
    toast._tm = setTimeout(()=>{ t.style.display="none"; }, ms);
  };

  // ---------- Glitch controls (only affects audio when AMT > 0) ----------
  const __glitchParams = {
    style: "stutter",
    amt: 0.0
  };

  const __glitchStyleEl = $("glitchStyle");
  const __glitchAmtEl = $("glitchAmt");

  if (__glitchStyleEl){
    __glitchStyleEl.addEventListener("change", e=>{
      __glitchParams.style = String(e.target.value || "stutter");
    });
  }
  
  if (__glitchAmtEl){
    const __applyGlitchAmt = () => {
      // snap-to-zero to guarantee true bypass
      let v = Number(__glitchAmtEl.value);
      if (v <= 1) v = 0;
      if (v !== Number(__glitchAmtEl.value)) __glitchAmtEl.value = String(v);

      // linear mix; internal processor uses nonlinear scaling
      const amt = clamp(v/100, 0, 1);
      __glitchParams.amt = amt;

      if (audioCtx && state._glitch && state._glitch.wet && state._glitch.dry){
        const t = audioCtx.currentTime;
        const mix = Math.pow(amt, 0.85);
        state._glitch.wet.gain.setTargetAtTime(mix, t, 0.01);
        state._glitch.dry.gain.setTargetAtTime(1-mix, t, 0.01);
      }
};

    __glitchAmtEl.addEventListener("input", __applyGlitchAmt);
    __glitchAmtEl.addEventListener("change", __applyGlitchAmt);
    __glitchAmtEl.addEventListener("mouseup", __applyGlitchAmt);
    __glitchAmtEl.addEventListener("touchend", __applyGlitchAmt, {passive:true});
    setTimeout(__applyGlitchAmt, 0);
  }

  function mulberry32(seed){
    let t = seed >>> 0;
    return function(){
      t += 0x6D2B79F5;
      let x = Math.imul(t ^ (t >>> 15), 1 | t);
      x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
      return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
    };
  }

  // ---------- State ----------
  const CATS = ["KICK","SNARE","HAT","CLAP","BASS","PERC/FX"];
  const STEPS = 16;
  const ROWS = CATS.length;

  const state = {
    files: [], // {id,name,file,buffer,category,autoCategory,features,override:boolean}
    selectedFileIndex: -1,
    pattern: Array.from({length: ROWS}, () => Array.from({length: STEPS}, () => 0)), // 0 empty,1 ghost,2 hit,3 accent
    bpm: 170,
    isPlaying: false,
    viewMode: "follow",
    scheduler: null,
    nextNoteTime: 0,
    currentStep: 0,
    lookaheadMs: 25,
    scheduleAhead: 0.12,
    activeSources: new Set(),
    previewSource: null,
    previewGain: null,
    record: {
      rec: null,
      chunks: [],
      isRecording: false,
      streamDest: null
    },
    debug: {
      on:false,
      lines: []
    },
    visual: {
      lastStep: -1
    }
  };

  
  // ---------- Transport display ----------
  function refreshTransport(){
    const t = $("transport");
    if (!t) return;
    t.textContent = `bpm ${Math.round(state.bpm)} • 1 bar • 16 steps`;
  }
// ---------- Audio ----------
  let audioCtx = null;
  let master = null;
  let analyser = null;

let glitchNode = null;

  function createGlitchNode(ctx){
    // ScriptProcessor for broad compatibility; intentionally audible (requested "glitch" effect).
    const node = ctx.createScriptProcessor(2048, 2, 2);
    let hold = 0;
    let holdL = 0, holdR = 0;
    let bits = 10;
    let stutter = 0;
    let tearFrames = 0;

    node.onaudioprocess = (e) => {
      const in0 = e.inputBuffer.getChannelData(0);
      const in1 = (e.inputBuffer.numberOfChannels > 1) ? e.inputBuffer.getChannelData(1) : in0;
      const out0 = e.outputBuffer.getChannelData(0);
      const out1 = e.outputBuffer.getChannelData(1);

      const amt = (__glitchParams?.amt ?? 0);
      if (amt === 0){
        out0.set(in0);
        out1.set(in1);
        return;
      }
      const style = String(__glitchParams?.style ?? "stutter");
      // make low AMT clearly audible
      const a = Math.pow(amt, 0.55);

      // style-dependent knobs
      const pStutter = (style==="stutter" ? (0.00025 + 0.0022*a) : (style==="tear" ? (0.00015 + 0.0016*a) : 0));
      const pHold    = (style==="stutter" ? (0.00055 + 0.0038*a) : (style==="tear" ? (0.00035 + 0.0030*a) : 0));
      const pTear    = (style==="tear"   ? (0.00025 + 0.0025*a) : 0);
      const crush    = (style==="bitcrush" ? 1 : 0);

      // downsample factor for bitcrush (1..12)
      const ds = 1 + Math.floor(11*a);

      
// --- per-block triggers (much lower CPU; avoids freezing on load/play) ---
const N = in0.length;

if (stutter <= 0 && pStutter > 0 && Math.random() < (pStutter * N)){
  stutter = (10 + ((Math.random()*(40 + 260*a))|0));
}
if (hold <= 0 && pHold > 0 && Math.random() < (pHold * N)){
  hold = (2 + ((Math.random()*(8 + 110*a))|0));
  bits = clamp(10 - Math.floor(7*a) + ((Math.random()*2)|0), 3, 10);
  // seed freeze from first sample of this block (stable)
  holdL = in0[0]; holdR = in1[0];
}
if (tearFrames <= 0 && pTear > 0 && Math.random() < (pTear * N)){
  tearFrames = 6 + ((Math.random()*(18 + 70*a))|0);
}

for (let i=0;i<N;i++){
  let l = in0[i], r = in1[i];

  if (tearFrames > 0){
    l = -l; r = -r;
    tearFrames--;
  }

        if (crush){
          // bitcrush: downsample (sample-hold) based on AMT
          if ((i % ds) === 0){ holdL = l; holdR = r; }
          l = holdL; r = holdR;
        } else if (stutter > 0){
          // micro-stutter / freeze
          l = holdL; r = holdR;
          stutter--;
        } else if (hold > 0){
          l = holdL; r = holdR;
          hold--;
        }

        // bit-depth crush
        const q = 1 << bits;
        l = Math.round(l*q)/q;
        r = Math.round(r*q)/q;

        out0[i] = l;
        out1[i] = r;

        // keep last sample for freeze
        holdL = l; holdR = r;
      }
    };

    return node;
  }

  async function ensureAudio(){
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)({latencyHint:"interactive"});
    master = audioCtx.createGain();
    master.gain.value = 0.85;
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 1024;
    glitchNode = createGlitchNode(audioCtx);

    // --- controllable wet/dry mix (no UI change) ---
    const dry = audioCtx.createGain();
    const wet = audioCtx.createGain();
    const a0 = (__glitchParams?.amt ?? 0);
    const m0 = Math.pow(a0, 0.85); // perceptual curve: more obvious at low AMT
    wet.gain.value = m0;
    dry.gain.value = 1 - m0;

    master.connect(dry);
    dry.connect(analyser);

    master.connect(glitchNode);
    glitchNode.connect(wet);
    wet.connect(analyser);

    analyser.connect(audioCtx.destination);

    // for live updates from the AMT slider
    state._glitch = {dry, wet};

    $("audioState").textContent = "audio: " + audioCtx.state;
    audioCtx.onstatechange = () => $("audioState").textContent = "audio: " + audioCtx.state;
  }

  function killAllSources(){
    for (const s of state.activeSources){
      try{ s.stop(); }catch(e){}
    }
    state.activeSources.clear();
    if (state.previewSource){
      try{ state.previewSource.stop(); }catch(e){}
      state.previewSource = null;
    }
  }

  function safeStopSource(src, when=0){
    try{ src.stop(when); }catch(e){}
  }

  // ---------- File decoding + analysis ----------
  async function decodeFile(file){
    await ensureAudio();
    const arr = await file.arrayBuffer();
    // Copy buffer to detach from file; decodeAudioData on some browsers consumes the arraybuffer.
    const copy = arr.slice(0);
    const buf = await audioCtx.decodeAudioData(copy);
    return buf;
  }

  // Cheap transient-ish + timbre features (fast, stable)
  function extractFeatures(buffer){
    const ch = buffer.getChannelData(0);
    const sr = buffer.sampleRate;
    const N = ch.length;

    // windowed energy (rough onset strength)
    const hop = 256;
    const win = 1024;
    let prevE = 0;
    let maxFlux = 0;
    let fluxSum = 0;
    let count = 0;

    // zero crossing and lowfreq energy proxy
    let zc = 0;
    for (let i=1;i<N;i++){
      if ((ch[i-1] >= 0 && ch[i] < 0) || (ch[i-1] < 0 && ch[i] >= 0)) zc++;
    }
    const zcr = zc / N;

    // Simple spectral centroid approximation via FFT on first 4096 samples (or less)
    const fftN = Math.min(4096, N);
    const frame = new Float32Array(fftN);
    for (let i=0;i<fftN;i++) frame[i] = ch[i] * (0.5 - 0.5*Math.cos(2*Math.PI*i/(fftN-1)));
    // Real FFT magnitude (naive DFT for stability; small N only)
    const bins = 128; // coarse
    let centroid = 0, magSum = 0;
    for (let k=0;k<bins;k++){
      const w = 2*Math.PI*k/fftN;
      let re=0, im=0;
      for (let n=0;n<fftN;n++){
        const ang = w*n;
        re += frame[n] * Math.cos(ang);
        im -= frame[n] * Math.sin(ang);
      }
      const mag = Math.sqrt(re*re + im*im);
      const freq = (k*sr)/fftN;
      centroid += freq * mag;
      magSum += mag;
    }
    centroid = magSum > 1e-9 ? centroid / magSum : 0;
    const centroidNorm = centroid / (sr/2);

    // onset flux over first ~1s (or shorter)
    const maxSamples = Math.min(N, sr); // 1 sec
    for (let i=0; i+win < maxSamples; i+=hop){
      let e=0;
      for (let j=0;j<win;j++){
        const v = ch[i+j];
        e += v*v;
      }
      const flux = Math.max(0, e - prevE);
      prevE = e;
      maxFlux = Math.max(maxFlux, flux);
      fluxSum += flux;
      count++;
    }
    const fluxMean = count ? (fluxSum / count) : 0;

    // low frequency ratio via single-pole lowpass
    let lp=0;
    const a = Math.exp(-2*Math.PI*160/sr);
    let lowE=0, totE=0;
    for (let i=0;i<Math.min(N, sr*0.5);i++){ // first 0.5s
      lp = a*lp + (1-a)*ch[i];
      lowE += lp*lp;
      totE += ch[i]*ch[i];
    }
    const lowRatio = totE>1e-9 ? (lowE/totE) : 0;

    // attack time: time until RMS crosses 60% of peak RMS in first 200ms
    const atkWin = Math.min(N, Math.floor(sr*0.2));
    let peak=0;
    for (let i=0;i<atkWin;i++) peak = Math.max(peak, Math.abs(ch[i]));
    const thresh = peak * 0.6;
    let atkSamp = atkWin;
    for (let i=0;i<atkWin;i++){
      if (Math.abs(ch[i]) >= thresh){ atkSamp=i; break; }
    }
    const attack = atkSamp / sr; // seconds

    return { zcr, centroidNorm, fluxMean, maxFlux, lowRatio, attack };
  }

  function classify(features){
    // Heuristics tuned for drum one-shots:
    const {zcr, centroidNorm, fluxMean, lowRatio, attack} = features;

    // hats: high centroid, high zcr, low lowRatio
    if (centroidNorm > 0.55 && zcr > 0.12 && lowRatio < 0.35) return "HAT";

    // kicks/bass: high lowRatio, low centroid
    if (lowRatio > 0.68 && centroidNorm < 0.30) return (attack < 0.015 ? "KICK" : "BASS");

    // snares/claps: mid centroid, mid zcr, moderate lowRatio
    if (centroidNorm > 0.30 && centroidNorm < 0.55){
      if (zcr > 0.10 && attack < 0.02) return "CLAP";
      return "SNARE";
    }

    // fallback
    return "PERC/FX";
  }

  // ---------- UI rendering ----------
  const fileListEl = $("fileList");
  const statusLeft = $("statusLeft");
  const statusRight = $("statusRight");

  function setStatus(left, right=""){
    statusLeft.textContent = left;
    statusRight.textContent = right;
  }

  function renderFileList(){
    fileListEl.innerHTML = "";
    state.files.forEach((f, idx) => {
      const row = document.createElement("div");
      row.className = "fileitem" + (idx === state.selectedFileIndex ? " selected" : "");
      const name = document.createElement("div");
      name.className = "fname";
      name.textContent = f.name;
      name.title = "Click to preview";
      name.addEventListener("click", async (ev) => {
        ev.stopPropagation();
        state.selectedFileIndex = idx;
        renderFileList();
        await previewFile(idx);
      });

      const cat = document.createElement("div");
      cat.className = "cat";
      cat.textContent = f.category || "—";
      cat.title = "Click to change class";
      cat.addEventListener("click", (ev) => {
        ev.stopPropagation();
        state.selectedFileIndex = idx;
        renderFileList();
        openCatMenu(cat, idx);
      });

      row.appendChild(name);
      row.appendChild(cat);
      row.addEventListener("click", () => {
        state.selectedFileIndex = idx;
        renderFileList();
      });

      fileListEl.appendChild(row);
    });

    if (state.files.length === 0){
      const empty = document.createElement("div");
      empty.style.color = "var(--muted2)";
      empty.style.fontSize = "11px";
      empty.style.padding = "8px";
      empty.textContent = "No files loaded yet.";
      fileListEl.appendChild(empty);
    }
  }

  function openCatMenu(anchorEl, fileIdx){
    // Simple in-place dropdown using a temporary select
    const f = state.files[fileIdx];
    const sel = document.createElement("select");
    sel.style.width = "100%";
    CATS.forEach(c => {
      const op = document.createElement("option");
      op.value = c; op.textContent = c;
      if (c === f.category) op.selected = true;
      sel.appendChild(op);
    });
    const wrap = anchorEl.parentElement;
    const old = anchorEl;
    wrap.replaceChild(sel, old);
    sel.focus();
    const commit = () => {
      f.category = sel.value;
      f.override = true;
      renderFileList();
      // Pattern rows do not auto-move; classification affects RANDOM PATTERN generation and visuals.
      updateVisualDistribution();
    };
    sel.addEventListener("change", commit);
    sel.addEventListener("blur", commit, {once:true});
    sel.addEventListener("keydown", (e) => {
      if (e.key === "Escape"){
        wrap.replaceChild(old, sel);
        renderFileList();
      }
      if (e.key === "Enter"){
        commit();
      }
    });
  }

  // ---------- Sequencer grid ----------
  const gridEl = $("grid");
  const headerEl = $("stepsHeader");

  function renderHeader(){
    headerEl.innerHTML = "";
    const blank = document.createElement("div");
    blank.textContent = "STEP";
    headerEl.appendChild(blank);
    for (let i=0;i<STEPS;i++){
      const h = document.createElement("div");
      h.className = "h";
      h.textContent = String(i+1);
      headerEl.appendChild(h);
    }
  }

  function renderGrid(){
    gridEl.innerHTML = "";
    for (let r=0;r<ROWS;r++){
      const lab = document.createElement("div");
      lab.className = "rlabel";
      lab.textContent = CATS[r];
      gridEl.appendChild(lab);

      for (let s=0;s<STEPS;s++){
        const cell = document.createElement("div");
        cell.className = "step";
        cell.dataset.r = String(r);
        cell.dataset.s = String(s);
        cell.dataset.state = String(state.pattern[r][s]);
        cell.addEventListener("click", (ev) => {
          ev.preventDefault();
          const cur = state.pattern[r][s];
          const next = (cur + 1) % 4;
          state.pattern[r][s] = next;
          cell.dataset.state = String(next);
          updateVisualDistribution();
        });
        gridEl.appendChild(cell);
      }
    }
  }

  function setPlayingColumn(step){
    const cells = gridEl.querySelectorAll(".step");
    cells.forEach(c => c.classList.remove("playing"));
    if (state.viewMode !== "follow") return;
    for (const c of cells){
      if (Number(c.dataset.s) === step) c.classList.add("playing");
    }
  }

  // ---------- Preview ----------
  async function previewFile(idx){
    const f = state.files[idx];
    if (!f) return;
    await ensureAudio();
    if (audioCtx.state !== "running"){
      await audioCtx.resume();
    }

    // stop previous preview only (do not touch transport)
    if (state.previewSource){
      safeStopSource(state.previewSource);
      state.previewSource = null;
    }

    // if buffer not decoded, decode
    if (!f.buffer){
      setStatus("decoding…", f.name);
      f.buffer = await decodeFile(f.file);
    }

    const src = audioCtx.createBufferSource();
    src.buffer = f.buffer;
    const g = audioCtx.createGain();
    const t0 = audioCtx.currentTime;
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.linearRampToValueAtTime(0.65, t0+0.01);
    g.gain.linearRampToValueAtTime(0.0001, t0+Math.min(0.35, f.buffer.duration));
    src.connect(g);
    g.connect(master);

    src.start();
    state.previewSource = src;
    state.previewGain = g;

    setStatus("preview", `${f.name}  •  ${f.category || "—"}`);
    src.onended = () => {
      if (state.previewSource === src){
        state.previewSource = null;
      }
    };
  }

  // ---------- Transport scheduling ----------
  function stepToTime(stepIndex){
    const spb = 60 / state.bpm;
    const stepDur = spb / 4; // 16 steps per 4/4 bar (1/16)
    return stepIndex * stepDur;
  }

  function velocityFromState(st){
    if (st === 1) return 0.25;
    if (st === 2) return 0.55;
    if (st === 3) return 0.85;
    return 0.0;
  }

  function pickBufferForCat(cat){
    // choose a buffer from files with matching category; fallback any.
    const list = state.files.filter(f => f.buffer && f.category === cat);
    if (list.length) return list[Math.floor(Math.random()*list.length)].buffer;
    const any = state.files.filter(f => f.buffer);
    if (any.length) return any[Math.floor(Math.random()*any.length)].buffer;
    return null;
  }

  function scheduleStep(step, time){
    // snapshot pattern at schedule time (prevents crackles when pattern changes during playback)
    for (let r=0;r<ROWS;r++){
      const st = state.pattern[r][step];
      if (st === 0) continue;
      const vel = velocityFromState(st);
      const cat = CATS[r];
      const buf = pickBufferForCat(cat);
      if (!buf) continue;

      const src = audioCtx.createBufferSource();
      src.buffer = buf;

      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.0001, time);
      g.gain.linearRampToValueAtTime(vel, time + 0.006);
      g.gain.linearRampToValueAtTime(0.0001, time + Math.min(0.18, buf.duration));

      src.connect(g);
      g.connect(master);
      src.start(time);
      safeStopSource(src, time + buf.duration + 0.05);

      state.activeSources.add(src);
      src.onended = () => state.activeSources.delete(src);
    }
  }

  function schedulerTick(){
    if (!state.isPlaying) return;
    const ct = audioCtx.currentTime;
    while (state.nextNoteTime < ct + state.scheduleAhead){
      scheduleStep(state.currentStep, state.nextNoteTime);
      state.nextNoteTime += stepToTime(1);
      state.currentStep = (state.currentStep + 1) % STEPS;
    }
  }

  function startTransport(){
    if (state.isPlaying) return;
    state.isPlaying = true;
    state.currentStep = 0;
    state.nextNoteTime = audioCtx.currentTime + 0.05;

    state.scheduler = setInterval(schedulerTick, state.lookaheadMs);

    setStatus("playing", "transport running");
  }

  function stopTransport(){
    state.isPlaying = false;
    if (state.scheduler){
      clearInterval(state.scheduler);
      state.scheduler = null;
    }
    // stop scheduled/active sources (hard stop)
    killAllSources();
    setPlayingColumn(-1);
    setStatus("stopped", "");
  }

  // ---------- Random pattern generation ----------
  function resetPattern(){
    for (let r=0;r<ROWS;r++) for (let s=0;s<STEPS;s++) state.pattern[r][s] = 0;
    renderGrid();
    updateVisualDistribution();
  }

  function setHit(cat, step, st=2){
    const r = CATS.indexOf(cat);
    if (r < 0) return;
    state.pattern[r][((step%STEPS)+STEPS)%STEPS] = st;
  }

  function generateBase(style, rng){
    resetPattern();
    // Reasonable defaults
    if (style === "minimal"){
      setHit("KICK",0,3); setHit("KICK",8,2);
      setHit("SNARE",4,3); setHit("SNARE",12,3);
      for (let i=0;i<STEPS;i+=2) setHit("HAT", i, 1);
      setHit("CLAP",12,2);
      return;
    }

    if (style === "dnb"){
      setHit("KICK",0,3); setHit("KICK",10,2);
      setHit("SNARE",4,3); setHit("SNARE",12,3);
      for (let i=0;i<STEPS;i++){
        if (i%2===0) setHit("HAT", i, 2);
        if (i%4===2 && rng()<0.4) setHit("HAT", i, 1);
      }
      if (rng()<0.6) setHit("CLAP",12,2);
      if (rng()<0.35) setHit("PERC/FX",14,1);
      if (rng()<0.35) setHit("PERC/FX",2,1);
      return;
    }

    if (style === "breakbeat"){
      // Amen-ish skeleton
      setHit("KICK",0,3); setHit("KICK",7,2); setHit("KICK",10,2);
      setHit("SNARE",4,3); setHit("SNARE",11,2); setHit("SNARE",12,3);
      setHit("HAT",2,1); setHit("HAT",6,1); setHit("HAT",8,1); setHit("HAT",14,1);
      if (rng()<0.7) setHit("CLAP",12,2);
      setHit("PERC/FX",15,1);
      return;
    }

    // jungle
    setHit("KICK",0,3); setHit("KICK",6,2); setHit("KICK",9,2);
    setHit("SNARE",4,3); setHit("SNARE",12,3);
    setHit("HAT",2,1); setHit("HAT",3,1); setHit("HAT",6,1); setHit("HAT",8,1); setHit("HAT",10,1); setHit("HAT",14,1);
    setHit("PERC/FX",15,2);
    if (rng()<0.5) setHit("CLAP",12,2);
  }

  function applyDensity(density, rng, style){
    // density: 0..200; adds/removes hits without altering audio graph (no playback pops)
    const d = density / 100;

    // Thin out if low density
    for (let r=0;r<ROWS;r++){
      for (let s=0;s<STEPS;s++){
        const st = state.pattern[r][s];
        if (st === 0) continue;
        const keepP = 0.25 + 0.75*d;
        if (rng() > keepP){
          state.pattern[r][s] = 0;
        }
      }
    }

    // Add embellishments if high density
    const addP = Math.max(0, d - 0.45) * 1.6; // 0..~0.88
    for (let s=0;s<STEPS;s++){
      if (rng() < addP){
        // hats / perc accents
        if (rng() < 0.65){
          const st = rng()<0.25 ? 3 : (rng()<0.65 ? 2 : 1);
          state.pattern[CATS.indexOf("HAT")][s] = Math.max(state.pattern[CATS.indexOf("HAT")][s], st);
        } else {
          const rr = rng() < 0.5 ? "PERC/FX" : "CLAP";
          const st = rng()<0.18 ? 3 : 1;
          state.pattern[CATS.indexOf(rr)][s] = Math.max(state.pattern[CATS.indexOf(rr)][s], st);
        }
      }
    }

    // Style-specific ghosting
    if (style === "dnb" || style === "jungle"){
      for (let s=0;s<STEPS;s++){
        if (rng() < 0.22*d){
          const st = (s%4===3) ? 1 : 0;
          if (st) state.pattern[CATS.indexOf("SNARE")][s] = Math.max(state.pattern[CATS.indexOf("SNARE")][s], 1);
        }
      }
    }
  }

  function randomizePattern(){
    const style = $("styleMode").value;
    const density = Number($("density").value);
    const seed = (Date.now() ^ Math.floor(Math.random()*1e9)) >>> 0;
    const rng = mulberry32(seed);

    generateBase(style, rng);
    applyDensity(density, rng, style);

    // Render only (no audio graph rebuild -> prevents playback crackle)
    renderGrid();
    updateVisualDistribution();
    setStatus("pattern", `randomized • ${style.toUpperCase()} • dens ${density}`);
  }

  // ---------- Visuals (8-bit + pseudo 3D) ----------
  const cvFight = $("cvFighters");
  const ctxFight = cvFight.getContext("2d");
  const cvGeo = $("cvGeo");
  const ctxGeo = cvGeo.getContext("2d");

  // Offscreen low-res for pixel effect
  const offFight = document.createElement("canvas");
  offFight.width = 160; offFight.height = 90;
  const offFightCtx = offFight.getContext("2d");

  const offGeo = document.createElement("canvas");
  offGeo.width = 160; offGeo.height = 90;
  const offGeoCtx = offGeo.getContext("2d");

  const fighters = [];
  let geoRot = 0;
  let geoTime = now();
let ampSmooth = 0;
  let beatSmooth = 0;
  let mistPhase = 0;

  // ---------- Visual step triggers + arcade scene + smooth geometry morph ----------
  const vis = {
    pulse: 0,
    energy: 0,
    trig: (() => {
      const o = {};
      for (const c of CATS) o[c] = 0;
      return o;
    })()
  };

  function easeInOut(t){
    return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3) / 2;
  }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function approach(cur, target, maxDelta){
    if (cur < target) return Math.min(target, cur + maxDelta);
    return Math.max(target, cur - maxDelta);
  }

  const game = (() => {
    const G = {
      inited:false,
      level:1,
      score:0,
      lives:3,
      kills:0,
      wave:0,
      msg:"",
      msgT:0,
      shake:0,
      flash:0,
      scroll:0,
      stars:[],
      bullets:[],
      enemies:[],
      parts:[],
      density:0.5,
      lead:"PERC/FX",
      // last LCD dims
      lx:0, ly:0, lw:0, lh:0,
      player:{ x:0, y:0, vy:0, targetY:0, cd:0, superCd:0 },

      recalc(){
        const dist = patternDistribution();
        const total = Object.values(dist).reduce((a,b)=>a+b,0) || 1;
        this.density = clamp(total/(ROWS*STEPS), 0, 1);
        this.lead = Object.entries(dist).sort((a,b)=>b[1]-a[1])[0]?.[0] || "PERC/FX";
      },

      reset(){

      this.inited=true;

      // keep counters/UI text
      this.level=1; this.score=0; this.lives=3; this.kills=0; this.wave=0;
      this.msg=""; this.msgT=0; this.shake=0; this.flash=0;

      // racing state
      this.road = { z:0, curve:0, curveT:0, curveV:0, lanePhase:0 };
      this.player = { x:0, vx:0 };

      // arrays kept for compatibility
      this.stars=[];
      this.bullets=[];
      this.enemies=[];   // opponent cars
      this.parts=[];     // roadside props

      // side planets (both sides)
      this.sidePlanets = [];
      {
        const rng = mulberry32(424242);
        const count = 14;
        for (let i=0;i<count;i++){
          const side = (rng()<0.5) ? -1 : 1;
          this.sidePlanets.push({
            side,
            y: -1.2 - rng()*1.9,
            r: 6 + rng()*12,
            saturn: (rng()<0.24),
          });
        }
      }

      // Milky Way background stars: white pixel dust on black. Only stars have breathing haze.
      this.mwStars = [];
      {
        const rng = mulberry32(1337);
        const N = 820; // still light
        for (let i=0;i<N;i++){
          const x = rng();
          const y = rng();
          // diagonal band density (Milky Way)
          const a = -0.35, b = 0.62;
          const d = Math.abs(a*x - y + b) / Math.sqrt(a*a + 1);
          const band = Math.exp(-(d*d)/(0.010));
          const p = 0.10 + 0.95*band;
          if (rng() < p){
            const halo = (rng() < (0.26 + 0.30*band));
            const br = (0.18 + 0.82*(0.35 + 0.65*band)) * (0.55 + 0.85*rng());
            const a0 = 0.08 + 0.58*br;
            this.mwStars.push({x,y,a:a0,halo});
          }
        }
        // small clusters
        for (let k=0;k<26;k++){
          const cx = 0.15 + rng()*0.70;
          const cy = 0.20 + rng()*0.60;
          for (let j=0;j<10;j++){
            const x = clamp(cx + (rng()-0.5)*0.028, 0, 1);
            const y = clamp(cy + (rng()-0.5)*0.028, 0, 1);
            this.mwStars.push({x,y,a:0.10 + 0.18*rng(),halo:(rng()<0.30)});
          }
        }
      }

      this.recalc();
      },

      levelUp(){
        this.level = clamp(this.level+1, 1, 99);
        this.wave++;
        this.msg = "LEVEL " + this.level;
        this.msgT = 1500;
        this.flash = Math.max(this.flash, 0.6);
      },

      spawnEnemy(type="scout"){
        const lx=this.lx, ly=this.ly, lw=this.lw, lh=this.lh;
        const yMin = ly + 16, yMax = ly + lh - 20;
        const y = clamp(yMin + Math.random()*(yMax-yMin), yMin, yMax);
        const base = ({
          scout:{hp:1, sp: 18, pts: 25, sz: 5},
          brute:{hp:3, sp: 12, pts: 60, sz: 7},
          glitch:{hp:2, sp: 14, pts: 50, sz: 6},
          // new playful enemy types
          zigzag:{hp:1, sp: 20, pts: 35, sz: 5},
          drone:{hp:2, sp: 16, pts: 70, sz: 6},
          mine:{hp:2, sp: 9, pts: 90, sz: 6},
          meteor:{hp:1, sp: 26, pts: 40, sz: 5},
          worm:{hp:3, sp: 11, pts: 120, sz: 7},
          boss:{hp:14, sp: 7, pts: 400, sz: 12}
        })[type] || {hp:1, sp: 16, pts: 25, sz: 5};

        const vx = -(base.sp/60) * (1 + this.level*0.06) * (0.85+Math.random()*0.3);
        this.enemies.push({x: lx+lw-10, y, vx, hp:base.hp, maxHp:base.hp, type, sz:base.sz, t:0});
      },

      fire(power=1, mode="shot"){
        const p = this.player;
        if (p.cd > 0) return;
        const speed = (mode==="beam") ? 2.7 : 2.1;
        const spread = (mode==="spread") ? 3 : 0;
        const count = (mode==="spread") ? 3 : 1;
        for (let i=0;i<count;i++){
          const dy = spread ? (i-1)*spread : 0;
          this.bullets.push({x:p.x+7, y:p.y+2+dy, vx:speed, pow:power, life:900});
        }
        p.cd = (mode==="beam") ? 80 : 110;
        this.flash = Math.max(this.flash, 0.18 + 0.08*power);
      },

      bomb(){
        const p = this.player;
        if (p.superCd > 0) return;
        p.superCd = 1250;
        this.shake = Math.max(this.shake, 0.9);
        this.flash = Math.max(this.flash, 0.9);
        for (const e of this.enemies){
          e.hp -= 2;
        }
        for (let i=0;i<18;i++){
          this.parts.push({x:p.x+8, y:p.y+3, vx:(Math.random()-0.5)*1.6, vy:(Math.random()-0.5)*1.2, life:400+Math.random()*300});
        }
      },

      // sequencer step callback (prevents animation crash; drives racing events)
      onStep(evt){
        // evt: {step, cats, hits, acc}
        // Use step energy to add micro-events without affecting UI.
        try{
          const acc = evt?.acc || 0;
          const hits = evt?.hits || 0;

          // brief shake/flash on strong hits (flash is used as subtle overlay in this scene)
          if (acc > 0.65 || hits >= 2){
            this.shake = Math.max(this.shake, 0.25 + 0.25*acc);
            // message occasionally
            if (Math.random() < 0.08){
              this.msg = "BOOST";
              this.msgT = 420;
            }
          }

          // nudge curve target on accented steps for rhythmic steering
          if (acc > 0.35){
            const dir = (Math.random()<0.5?-1:1);
            this.road.curveT = clamp(this.road.curveT + dir*(0.04 + 0.10*acc), -0.85, 0.85);
          }

          // occasional burst of opponents on dense percussion
          if (hits >= 3 && Math.random() < 0.10 && this.enemies.length < 9){
            const lane = (Math.random()<0.5) ? -1 : 1;
            const x = lane*(0.25 + Math.random()*0.18);
            this.enemies.push({x, y:-1.2, sp: 1.05 + 0.65*Math.random(), col: (Math.random()<0.5) ? "#ff5a5a" : "#5affa8"});
          }
        }catch(e){}
      },

      tick(dt, lx, ly, lw, lh, amp){

      if (!this.inited) this.reset();
      this.lx=lx; this.ly=ly; this.lw=lw; this.lh=lh;

      // density + lead extraction stays as-is
      this.recalc();

      const dens = this.density || 0;
      const act = clamp((amp||0)*70, 0, 1); // audio activity

      // speed reacts to density+audio; motion gates silence
      const speed = 0.85 + 1.55*dens + 1.15*act;
      const motion = (act > 0.02) ? (0.05 + 0.95*act) : 0.004; // near-static in silence
      const dz = dt * speed * motion;

      // curve target wanders only when there's sound
      if (act > 0.02 && (((now()|0) % 900) < dt)){
        this.road.curveT = clamp((Math.random()*2 - 1) * (0.18 + 0.60*dens), -0.85, 0.85);
      }
      // smooth curve always (but dz tiny => looks static)
      const k = 0.0008 + 0.0020*dens;
      this.road.curveV = approach(this.road.curveV, this.road.curveT, dt*k);
      this.road.curve  = approach(this.road.curve,  this.road.curveV, dt*(k*0.85));

      this.road.lanePhase = (this.road.lanePhase + dz*0.020) % 1;
      this.road.z += dz;

      // auto-steer (subtle) — motion is tiny in silence so it won’t “drift”
      const leadIdx = Math.max(0, CATS.indexOf(this.lead || "PERC/FX"));
      const steer = ((leadIdx % 3) - 1) * 0.18;
      const targetX = clamp(steer + (Math.sin(now()*0.0011)*0.08*act), -0.85, 0.85);
      this.player.vx = approach(this.player.vx, (targetX - this.player.x)*0.06, dt*0.002);
      this.player.x  = clamp(this.player.x + this.player.vx, -0.92, 0.92);

      // spawn only when audible (otherwise truly quiet)
      if (act > 0.02){
        const spawnP = dt * (0.00060 + 0.00140*dens + 0.00100*act);
        if (Math.random() < spawnP && this.enemies.length < 10){
          const lane = (Math.random()<0.5) ? -1 : 1;
          const x = lane*(0.25 + Math.random()*0.20) + (Math.random()*0.08 - 0.04);
          this.enemies.push({ x, y:-1.2, sp: 0.65 + Math.random()*0.65 + dens*0.45, col: (Math.random()<0.5) ? "#ff5a5a" : "#5affa8" });
        }

        const signP = dt * (0.00038 + 0.00095*dens);
        if (Math.random() < signP && this.parts.length < 14){
          const side = (Math.random()<0.5) ? -1 : 1;
          this.parts.push({ side, y:-1.1, kind: (Math.random()<0.5) ? "BILL" : "CONE" });
        }
      }

      // update opponent cars + props (dz tiny => near static in silence)
      for (const c of this.enemies){ c.y += (dz*0.0016) * c.sp; }
      for (const p of this.parts){ p.y += (dz*0.0012) * (0.95 + dens); }

      // side planets parallax
      for (const sp of (this.sidePlanets||[])){
        sp.y += (dz*0.00075) * (0.9 + dens*0.6);
        if (sp.y > 1.35){
          sp.y = -1.35 - Math.random()*0.9;
          sp.side = (Math.random()<0.5) ? -1 : 1;
          sp.r = 6 + Math.random()*12;
          sp.saturn = (Math.random()<0.24);
        }
      }

      // cleanup + score
      this.enemies = this.enemies.filter(c=>{
        if (c.y > 1.25){ this.score += 10; return false; }
        return true;
      });
      this.parts = this.parts.filter(p=> p.y < 1.25);

      // collisions
      for (const c of this.enemies){
        const dx = Math.abs(c.x - this.player.x);
        const dy = Math.abs(c.y - 0.80);
        if (dx < 0.18 && dy < 0.10){
          this.shake = Math.max(this.shake, 0.55);
          this.msg = "CRASH!";
          this.msgT = 650;
          c.y += 0.20;
          c.x += (Math.random()<0.5?-1:1)*0.12;
        }
      }

      // decay
      this.shake = Math.max(0, this.shake - dt*0.0016);
      if (this.msgT > 0) this.msgT -= dt;
      },

      render(g, lx, ly, lw, lh){

      // ---- retro racing render + Milky Way background (no halos/circles) ----
      const ox = (this.shake>0)? ((Math.random()-0.5)*this.shake*3) : 0;
      const oy = (this.shake>0)? ((Math.random()-0.5)*this.shake*3) : 0;

      // hard black background
      g.fillStyle = "#000";
      g.fillRect(lx, ly, lw, lh);

      // Milky Way background: white pixel stars with breathing haze ONLY on pixels (no circles)
      const breathe = 0.62 + 0.38*Math.sin(now()*0.0012);
      const stars = this.mwStars || [];
      for (let i=0;i<stars.length;i++){
        const s = stars[i];
        const x = (lx + (s.x * lw) + ox)|0;
        const y = (ly + (s.y * lh) + oy)|0;

        const coreA = (s.a * (0.70 + 0.30*breathe)) * 0.90;
        g.fillStyle = `rgba(255,255,255,${coreA})`;
        g.fillRect(x, y, 1, 1);

        if (s.halo){
          const ha = (s.a * (0.18 + 0.35*breathe)) * 0.55;
          g.fillStyle = `rgba(255,255,255,${ha})`;
          g.fillRect(x-1, y, 1, 1);
          g.fillRect(x+1, y, 1, 1);
          g.fillRect(x, y-1, 1, 1);
          g.fillRect(x, y+1, 1, 1);
          const da = ha * 0.55;
          g.fillStyle = `rgba(255,255,255,${da})`;
          g.fillRect(x-1, y-1, 1, 1);
          g.fillRect(x+1, y+1, 1, 1);
        }
      }

      // horizon + perspective parameters
      const horizon = (ly + lh*0.28)|0;
      const roadWTop = lw*0.18;
      const roadWBot = lw*0.92;
      const curvePx = (this.road?.curve ?? 0) * (lw*0.22);

      // scanline road for crisp "8-bit" feel
      for (let yy=0; yy<lh; yy++){
        const y = ly + yy;
        if (y < horizon) continue;

        const t = (yy / lh);
        const persp = Math.pow(t, 1.75);
        const w = roadWTop + (roadWBot - roadWTop) * persp;
        const cx = (lx + lw*0.5 + curvePx * Math.pow(t, 2.0)) + ox;
        const x0 = (cx - w*0.5)|0;
        const x1 = (cx + w*0.5)|0;

        // outside (dark, subtle texture)
        g.fillStyle = (((yy + (((this.road?.z ?? 0)*0.02)|0)) & 8) ? "#050505" : "#080808");
        if (x0 > lx) g.fillRect(lx, y, x0-lx, 1);
        if (x1 < lx+lw) g.fillRect(x1, y, (lx+lw)-x1, 1);

        // road surface
        g.fillStyle = (((yy + (((this.road?.z ?? 0)*0.04)|0)) & 12) ? "#101010" : "#0d0d0d");
        g.fillRect(x0, y, Math.max(0, x1-x0), 1);

        // edge lines
        g.fillStyle = "#2e2e2e";
        g.fillRect(x0, y, 1, 1);
        g.fillRect(x1-1, y, 1, 1);

        // lane dashes
        const dash = ((yy*0.12 + (this.road?.z ?? 0)*0.010) % 22) < (6 + 10*t);
        if (dash){
          g.fillStyle = "#cfcfcf";
          g.fillRect((cx|0), y, 1, 1);
        }
      }

      // tiny sprite helper (local; keeps UI untouched)
      const drawSpr = (x,y,rows,scale=1,color="#cfcfcf",hi="#ffffff") => {
        for (let j=0;j<rows.length;j++){
          for (let i=0;i<rows[j].length;i++){
            const ch = rows[j][i];
            if (ch === "#"){ g.fillStyle = color; g.fillRect(x+i*scale, y+j*scale, scale, scale); }
            if (ch === "*"){ g.fillStyle = hi;    g.fillRect(x+i*scale, y+j*scale, scale, scale); }
          }
        }
      };

      // side planets (both sides of the track; grayscale; no glow)
      const pl7 = [
        "..***..",
        ".#####.",
        "#######",
        "#######",
        "#######",
        ".#####.",
        "..***..",
      ];
      const ring11 = [
        "..#######..",
        ".#########.",
        "###########",
        "###########",
        ".#########.",
        "..#######..",
      ];

      for (const sp of (this.sidePlanets||[])){
        const t = (sp.y + 1) / 2;
        const y = horizon + (lh*0.72)*t;
        const persp = Math.pow((y-ly)/lh, 1.75);
        const w = roadWTop + (roadWBot - roadWTop) * persp;
        const cx = (lx + lw*0.5 + curvePx * Math.pow((y-ly)/lh, 2.0)) + ox;
        const side = (sp.side<0) ? -1 : 1;
        const sx = (cx + side*(w*0.72))|0;

        const scale = Math.max(1, (1 + (persp*2))|0);

        // ring behind the planet
        if (sp.saturn && scale >= 1){
          const rw = ring11[0].length * scale;
          const rh = ring11.length * scale;
          drawSpr((sx - (rw>>1))|0, ((y - (rh>>1))|0), ring11, scale, "#6f6f6f", "#d7d7d7");
        }

        const pw = pl7[0].length * scale;
        const ph = pl7.length * scale;
        drawSpr((sx - (pw>>1))|0, ((y - (ph>>1))|0), pl7, scale, "#bdbdbd", "#ffffff");
      }

      // roadside props
      for (const s of (this.parts||[])){
        const t = (s.y + 1) / 2;
        const y = horizon + (lh*0.72)*t;
        const persp = Math.pow((y-ly)/lh, 1.75);
        const w = roadWTop + (roadWBot - roadWTop) * persp;
        const cx = (lx + lw*0.5 + curvePx * Math.pow((y-ly)/lh, 2.0)) + ox;
        const side = (s.side<0) ? -1 : 1;
        const sx = (cx + side*(w*0.54))|0;

        if (s.kind === "BILL"){
          drawSpr(sx, (y-2)|0, ["####","*##*","####"], 1, "#777", "#fff");
        } else {
          drawSpr(sx, (y-2)|0, [".#.","###",".#."], 1, "#ffcc55", "#fff");
        }
      }

      // opponent cars
      const carOpp = [".###.","#####","#***#","#####","o###o"];
      for (const c of (this.enemies||[])){
        const t = (c.y + 1) / 2;
        const y = horizon + (lh*0.72)*t;
        const persp = Math.pow((y-ly)/lh, 1.65);
        const w = roadWTop + (roadWBot - roadWTop) * persp;
        const cx = (lx + lw*0.5 + curvePx * Math.pow((y-ly)/lh, 2.0)) + ox;
        const x = cx + c.x * (w*0.38);

        const scale = Math.max(1, (1 + (persp*2))|0);
        // wheels are just darker edge pixels by color choice
        drawSpr((x - 2*scale)|0, (y - 3*scale)|0, [".###.","#####","#***#","#####",".###."], scale, (c.col||"#ff5a5a"), "#ffffff");
      }

      // player car (Ferrari-like pixel art; no glow)
      const carMe = [
        "....***.........",
        "...#####........",
        "..########......",
        ".####ww####.....",
        "###wwwwww###....",
        "#############...",
        "##***####***##..",
        "##..######..##..",
        "o#..######..#o..",
        "o##.######.##o..",
        ".############...",
        "..##*******##...",
        "...###...###....",
      ];

      const drawSprCar = (x,y,rows,scale=1) => {
        for (let j=0;j<rows.length;j++){
          const row = rows[j];
          for (let i=0;i<row.length;i++){
            const ch = row[i];
            if (ch === ".") continue;
            if (ch === "#") g.fillStyle = "#ff2a2a";
            else if (ch === "*") g.fillStyle = "#ffffff";
            else if (ch === "o") g.fillStyle = "#1a1a1a";
            else if (ch === "w") g.fillStyle = "#7bd4ff";
            else g.fillStyle = "#cfcfcf";
            g.fillRect(x+i*scale, y+j*scale, scale, scale);
          }
        }
      };

      const meY = (ly + lh*0.80)|0;
      const meCX = (lx + lw*0.5 + curvePx) + ox;
      const meX = meCX + (this.player?.x ?? 0) * (roadWBot*0.18);
      drawSprCar((meX - 7)|0, (meY - 6)|0, carMe, 1);

      // HUD
      g.fillStyle = "#cfcfcf";
      g.font = "10px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
      g.fillText("RACE", lx+6, ly+12);
      g.fillText("SPD " + (Math.floor((0.85 + 1.55*(this.density||0))*99)), lx+6, ly+24);
      g.fillText("SCR " + (this.score||0), lx+6, ly+36);

      if ((this.msgT||0) > 0){
        g.fillStyle = "#fff";
        g.fillText(this.msg||"", (lx + lw*0.5 - (this.msg||"").length*3)|0, (ly + lh*0.18)|0);
      }
      }

    };
    return G;
  })();

  const geoMorph = (() => {
    return {
      inited:false,
      nextVariant: 0,
      t: 1,
      from: [],
      target: [],
      points: [],
      visibleCount: 90,
      targetCount: 90,
      energy: 0,
      requestUpdate: true,
      init(){
        this.inited=true;
        this.nextVariant=0;
        this.t=1;
        this.from=[];
        this.target=[];
        this.points=[];
        this.visibleCount=90;
        this.targetCount=90;
        this.energy=0;
        this.requestUpdate=true;
      }
    };
  })();

  function geoShapePoint(variant, u, tt){
    const a = u * Math.PI * 2;
    if (variant === 0){ // cube wire
      const e = Math.floor(u*12);
      const f = (u*12) - e;
      const s = 1.2;
      const v = [
        [-s,-s,-s],[ s,-s,-s],[ s, s,-s],[-s, s,-s],
        [-s,-s, s],[ s,-s, s],[ s, s, s],[-s, s, s],
      ];
      const edges = [[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];
      const [i,j] = edges[e%edges.length];
      const p=v[i], q=v[j];
      return [lerp(p[0],q[0],f), lerp(p[1],q[1],f), lerp(p[2],q[2],f)];
    }
    if (variant === 1){ // tetra edges
      const v = [[0,1.3,0],[-1.2,-1.0,-0.9],[1.2,-1.0,-0.9],[0,-1.0,1.1]];
      const edges = [[0,1],[0,2],[0,3],[1,2],[2,3],[3,1]];
      const e = Math.floor(u*edges.length);
      const f = (u*edges.length)-e;
      const [i,j]=edges[e];
      const p=v[i], q=v[j];
      return [lerp(p[0],q[0],f), lerp(p[1],q[1],f), lerp(p[2],q[2],f)];
    }
    if (variant === 2){ // sphere
      const th = a;
      const ph = Math.acos(lerp(-1,1,(u*0.97 + 0.015)%1));
      const r = 1.25;
      return [r*Math.sin(ph)*Math.cos(th), r*Math.cos(ph), r*Math.sin(ph)*Math.sin(th)];
    }
    if (variant === 3){ // torus
      const R=1.15, r=0.45;
      const b = a*1.3 + tt*0.4;
      const x = (R + r*Math.cos(b))*Math.cos(a);
      const y = r*Math.sin(b);
      const z = (R + r*Math.cos(b))*Math.sin(a);
      return [x, y, z];
    }
    if (variant === 4){ // cone spiral
      const z = lerp(-1.2, 1.2, u);
      const rr = lerp(1.25, 0.15, u);
      const ang = a*2.2 + tt*0.8;
      return [Math.cos(ang)*rr, Math.sin(ang)*rr*0.7, z];
    }
    if (variant === 5){ // prism loop
      const k = a;
      const x = Math.sign(Math.cos(k)) * (0.9 + 0.3*Math.cos(3*k));
      const y = Math.sign(Math.sin(k)) * (0.7 + 0.2*Math.sin(2*k));
      const z = Math.sin(k*2 + tt*0.6)*0.9;
      return [x, y, z];
    }
    if (variant === 6){ // triple ring
      const ring = Math.floor(u*3);
      const uu = (u*3)-ring;
      const aa = uu*Math.PI*2;
      const R = 1.2;
      if (ring===0) return [Math.cos(aa)*R, Math.sin(aa)*0.8, 0];
      if (ring===1) return [Math.cos(aa)*R, 0, Math.sin(aa)*0.8];
      return [0, Math.cos(aa)*R, Math.sin(aa)*0.8];
    }
    if (variant === 7){ // double helix
      const z = lerp(-1.2, 1.2, u);
      const ang = a*2.4 + tt*1.1;
      const x = Math.cos(ang)*1.0;
      const y = Math.sin(ang)*0.7;
      const off = (u<0.5?1:-1)*0.25;
      return [x+off, y, z];
    }
    if (variant === 8){ // atom rings
      const ring = Math.floor(u*3);
      const uu = (u*3)-ring;
      const aa = uu*Math.PI*2;
      const R = 1.25;
      if (ring===0) return [Math.cos(aa)*R, Math.sin(aa)*0.65, 0];
      if (ring===1) return [Math.cos(aa)*R, 0, Math.sin(aa)*0.65];
      return [0, Math.cos(aa)*R, Math.sin(aa)*0.65];
    }
    // trefoil knot
    const x = (Math.sin(a) + 2*Math.sin(2*a)) * 0.6;
    const y = (Math.cos(a) - 2*Math.cos(2*a)) * 0.35;
    const z = (-Math.sin(3*a)) * 0.55;
    return [x, y, z];
  }

  function geoBuildTarget(variant, count, tt){
    const pts = new Array(count);
    for (let i=0;i<count;i++){
      const u = i / count;
      const p = geoShapePoint(variant, u, tt);
      const baseJ = 0.06*Math.sin((i*17.13) + tt*1.7);
      const e = (geoMorph && geoMorph.energy) ? geoMorph.energy : 0;
      const w1 = 0.05*e*Math.sin((i*7.77) + tt*2.6);
      const w2 = 0.035*e*Math.sin((i*3.31) - tt*3.4);
      const j = baseJ + w1 - w2;
      pts[i] = {x:p[0] + j, y:p[1] - j*0.7 + w2*0.6, z:p[2] + j*0.5 + w1*0.4, a:1};
    }
    return pts;
  }

  function onStep(step){
    const cats = {};
    for (const c of CATS) cats[c]=0;

    let hits=0, acc=0;
    for (let r=0;r<ROWS;r++){
      const st = state.pattern[r][step];
      if (st){
        cats[CATS[r]] = Math.max(cats[CATS[r]], st);
        hits++;
        if (st===3) acc++;
      }
    }

    // visual trigger envelope
    vis.pulse = 1.0;
    vis.energy = clamp(vis.energy + 0.15 + 0.12*acc, 0, 1.7);
    for (const c of CATS){
      vis.trig[c] = Math.max(vis.trig[c], cats[c]/3);
    }

    // drive arcade scene and geometry
    game.onStep({step, cats, hits, acc});
    geoMorph.energy = Math.max(geoMorph.energy, 0.25 + 0.15*acc + 0.08*hits);
    if (acc) geoMorph.requestUpdate = true;
  }


  function patternDistribution(){
    const dist = {};
    for (const c of CATS) dist[c]=0;
    for (let r=0;r<ROWS;r++){
      for (let s=0;s<STEPS;s++){
        dist[CATS[r]] += (state.pattern[r][s] ? 1 : 0);
      }
    }
    return dist;
  }

  function updateFighters(){
    const dist = patternDistribution();
    const total = Object.values(dist).reduce((a,b)=>a+b,0) || 1;

    // desired fighter count based on density
    const desired = clamp(Math.round(4 + (total/ (ROWS*STEPS)) * 10), 4, 14);
    while (fighters.length < desired){
      fighters.push(makeFighter());
    }
    while (fighters.length > desired){
      fighters.pop();
    }

    // assign archetypes based on distribution
    const weights = [
      ["KICK", dist["KICK"]],
      ["SNARE", dist["SNARE"]],
      ["HAT", dist["HAT"]],
      ["CLAP", dist["CLAP"]],
      ["BASS", dist["BASS"]],
      ["PERC/FX", dist["PERC/FX"]],
    ].sort((a,b)=>b[1]-a[1]);

    fighters.forEach((f,i) => {
      const t = weights[i % weights.length][0];
      f.type = t;
      // adjust size/speed by type
      f.size = (t==="KICK"||t==="BASS") ? 6 : (t==="SNARE"||t==="CLAP") ? 5 : 4;
      f.speed = (t==="HAT") ? 1.5 : (t==="PERC/FX") ? 1.25 : 1.0;
      f.hp = clamp(8 + Math.floor(dist[t]/2), 6, 18);
    });
  }

  function makeFighter(){
    return {
      x: Math.random()*150+5,
      y: Math.random()*60+18,
      vx: (Math.random()<0.5?-1:1)*(0.6+Math.random()*0.6),
      dir: 1,
      size: 5,
      speed: 1,
      hp: 10,
      cool: 0,
      type: "PERC/FX"
    };
  }

  function rmsFromAnalyser(){
    if (!analyser) return 0;
    const arr = new Uint8Array(analyser.fftSize);
    analyser.getByteTimeDomainData(arr);
    let sum=0;
    for (let i=0;i<arr.length;i++){
      const v = (arr[i]-128)/128;
      sum += v*v;
    }
    return Math.sqrt(sum/arr.length);
  }

  
  function drawFighters(dt){
    const g = offFightCtx;
    const w = offFight.width, h = offFight.height;
    g.clearRect(0,0,w,h);

    // ---------- Pocket-operator-ish LCD frame ----------
    g.fillStyle = "#050607";
    g.fillRect(0,0,w,h);

    const lx = 6, ly = 9, lw = w-12, lh = h-18;

    // bezel
    g.fillStyle = "#0b0d10";
    g.fillRect(lx-2, ly-2, lw+4, lh+4);

    // LCD screen
    g.fillStyle = "#cfd4d6";
    g.fillRect(lx, ly, lw, lh);

    // subtle dithering/noise (stable-ish)
    const t = now();
    g.fillStyle = "rgba(0,0,0,0.04)";
    for (let i=0;i<90;i++){
      const nx = lx + ((i*19 + Math.floor(t/50)) % lw);
      const ny = ly + ((i*11 + Math.floor(t/70)) % lh);
      g.fillRect(nx, ny, 1, 1);
    }

    // top "UI" ticks (PO-style decoration)
    g.fillStyle = "rgba(0,0,0,0.25)";
    for (let i=0;i<lw;i+=6){
      g.fillRect(lx+i, ly+3, 2, 1);
    }

    const amp = rmsFromAnalyser();

    // Run "arcade" scene inside LCD (level progression + aliens + combat)
    game.tick(dt, lx, ly, lw, lh, amp);
    game.render(g, lx, ly, lw, lh);

    // scanlines (very subtle)
    g.fillStyle = "rgba(0,0,0,0.03)";
    for (let y=ly; y<ly+lh; y+=3){
      g.fillRect(lx, y, lw, 1);
    }

    // (mist / glow overlay disabled)

    // scale to main canvas with pixelated look
    ctxFight.imageSmoothingEnabled = false;
    ctxFight.clearRect(0,0,cvFight.width,cvFight.height);
    ctxFight.drawImage(offFight, 0, 0, cvFight.width, cvFight.height);
  }


  
  function drawGeo(dt){
    const g = offGeoCtx;
    const w = offGeo.width, h = offGeo.height;
    g.clearRect(0,0,w,h);

    // background
    g.fillStyle = "#050607";
    g.fillRect(0,0,w,h);

    if (!geoMorph.inited) geoMorph.init();

    const dist = patternDistribution();
    const total = Object.values(dist).reduce((a,b)=>a+b,0);
    const density = clamp(total/(ROWS*STEPS), 0, 1);
    const lead = Object.entries(dist).sort((a,b)=>b[1]-a[1])[0]?.[0] || "PERC/FX";
    const leadIdx = Math.max(0, CATS.indexOf(lead));
    
const ampRaw = rmsFromAnalyser();
// smooth amplitude for silkier visuals
ampSmooth = approach(ampSmooth, ampRaw, dt*0.008);
const amp = ampSmooth;

// If there is effectively no sound, keep pseudo-3D almost still.
// (We gate motion on real audio amplitude, not sequencer density.)
const act3 = clamp(amp * 80, 0, 1);            // 0..1
const motion3 = (act3 > 0.02) ? (0.04 + 0.96*act3) : 0.006;
const dt3 = dt * motion3;
geoTime += dt3;
    const beat = clamp(density*0.95 + amp*0.75, 0, 1.5);
    beatSmooth = approach(beatSmooth, beat, dt*0.006);

    // variant changes with smoothing; no hard switch
    const tt = geoTime/1000;
    const GEO_VARIANTS = [0,1,2,3,4,5,6,7,8,9,20,21,22,23,24];
    const desiredVariant = GEO_VARIANTS[(Math.floor(geoTime/1600) + leadIdx) % GEO_VARIANTS.length];

    // point count grows/shrinks smoothly with density + beat energy
    const desiredCount = clamp(Math.round(70 + density*80 + geoMorph.energy*18), 55, 160);

    // start a new morph when variant changes or when target count drifts
    const needNew =
      geoMorph.requestUpdate ||
      (geoMorph.target.length === 0) ||
      (desiredVariant !== geoMorph.nextVariant) ||
      (Math.abs(desiredCount - geoMorph.targetCount) > 10);

    if (needNew){
      geoMorph.requestUpdate = false;
      geoMorph.t = 0;
      geoMorph.from = geoMorph.points.length ? geoMorph.points.map(p => ({x:p.x,y:p.y,z:p.z,a:p.a})) : [];
      geoMorph.nextVariant = desiredVariant;
      geoMorph.targetCount = desiredCount;
      geoMorph.target = geoBuildTarget(desiredVariant, desiredCount, tt);
      if (!geoMorph.visibleCount) geoMorph.visibleCount = desiredCount;
    }

    // morph progress (silky + amp/rhythm reactive)
    const targetSpeed = 980 / (1 + Math.min(1.2, geoMorph.energy)*0.70 + beatSmooth*0.95);
    geoMorph._speed = (geoMorph._speed==null) ? targetSpeed : approach(geoMorph._speed, targetSpeed, dt3*0.012);
    geoMorph.t = clamp(geoMorph.t + dt3 / geoMorph._speed, 0, 1);
    const e = easeInOut(geoMorph.t);

    // smoothly change visible point count so points "grow in"
    geoMorph.visibleCount = approach(geoMorph.visibleCount, geoMorph.targetCount, dt3*0.08);

    const vc = Math.max(1, Math.floor(geoMorph.visibleCount));
    const fromN = geoMorph.from.length || 1;
    const tgtN = geoMorph.target.length || 1;

    // update current points array
    if (geoMorph.points.length < vc){
      while (geoMorph.points.length < vc){
        geoMorph.points.push({x:0,y:0,z:0,a:0});
      }
    } else if (geoMorph.points.length > vc){
      geoMorph.points.length = vc;
    }

    for (let i=0;i<vc;i++){
      const fp = geoMorph.from.length ? geoMorph.from[i % fromN] : {x:0,y:0,z:0,a:0};
      const tp = geoMorph.target[i % tgtN] || {x:0,y:0,z:0,a:1};
      const px = lerp(fp.x, tp.x, e);
      const py = lerp(fp.y, tp.y, e);
      const pz = lerp(fp.z, tp.z, e);
      const pa = lerp(fp.a ?? 1, 1, e);
      geoMorph.points[i].x = px;
      geoMorph.points[i].y = py;
      geoMorph.points[i].z = pz;
      // fade-in/out (gives "points increasing" feel)
      geoMorph.points[i].a = clamp(pa * (i < geoMorph.visibleCount ? 1 : 0), 0, 1);
    }

    // rotation + mild warp
    geoRot += dt3*0.0012*(1 + amp*7);
    geoMorph.energy = Math.max(0, geoMorph.energy*0.92 - dt3*0.00025);

    function project(p){
      const z = p[2] + 3.6;
      const s = 62 / z;
      return [w/2 + p[0]*s, h/2 + p[1]*s];
    }
    function rotY(p, a){
      const [x,y,z] = p;
      const ca=Math.cos(a), sa=Math.sin(a);
      return [x*ca + z*sa, y, -x*sa + z*ca];
    }
    function rotX(p, a){
      const [x,y,z] = p;
      const ca=Math.cos(a), sa=Math.sin(a);
      return [x, y*ca - z*sa, y*sa + z*ca];
    }

    const warp = 1 + amp*0.55 + geoMorph.energy*0.12;
    const pts2 = new Array(vc);

    for (let i=0;i<vc;i++){
      const p = geoMorph.points[i];
      let v = [p.x*warp, p.y*warp, p.z];
      v = rotY(v, geoRot);
      v = rotX(v, geoRot*0.83);
      pts2[i] = project(v);
    }

    // draw lines (soft, continuous)
    g.strokeStyle = "rgba(34,61,92,0.65)";
    g.lineWidth = 1;
    g.beginPath();
    for (let i=0;i<vc-1;i++){
      const a = pts2[i], b = pts2[i+1];
      g.moveTo(a[0], a[1]);
      g.lineTo(b[0], b[1]);
      if (i % 7 === 0 && i+13 < vc){
        const c = pts2[i+13];
        g.moveTo(a[0], a[1]);
        g.lineTo(c[0], c[1]);
      }
    }
    g.stroke();

    // points
    g.fillStyle = "rgba(231,231,231,0.42)";
    for (let i=0;i<vc;i++){
      const p = pts2[i];
      g.fillRect(Math.round(p[0]), Math.round(p[1]), 1, 1);
    }

    // subtle ghost trail (keeps it "silky")
    if (amp > 0.010){
      g.fillStyle = `rgba(231,231,231,${clamp(amp*2.2, 0, 0.12)})`;
      for (let i=0;i<vc;i+=3){
        const p = pts2[i];
        g.fillRect(Math.round(p[0])+1, Math.round(p[1]), 1, 1);
      }
    }

    ctxGeo.imageSmoothingEnabled = false;
    ctxGeo.clearRect(0,0,cvGeo.width,cvGeo.height);
    ctxGeo.drawImage(offGeo, 0, 0, cvGeo.width, cvGeo.height);
  }


  function updateVisualDistribution(){
    updateFighters();
    // keep visuals in sync with pattern edits
    try{ game.recalc(); }catch(e){}
    geoMorph.requestUpdate = true;
  }

  let lastFrame = now();
  function animLoop(){
    const t = now();
    const dt = t - lastFrame;
    lastFrame = t;

    if (state.isPlaying){
      // update playing column indicator
      const stepDur = (60/state.bpm)/4;
      const rel = audioCtx ? (audioCtx.currentTime - (state.nextNoteTime - stepDur*(state.currentStep))) : 0;
      // Use modulo time tracking with currentStep already advanced; fallback via currentStep-1.
      const displayStep = (state.currentStep - 1 + STEPS) % STEPS;
      setPlayingColumn(displayStep);

      // step-triggered visuals (game/geo) — avoids "just bobbing"
      if (displayStep !== state.visual.lastStep){
        state.visual.lastStep = displayStep;
        onStep(displayStep);
      }
    }

    drawFighters(dt);
    drawGeo(dt);

    // decay envelopes for smooth motion
    vis.pulse *= 0.88;
    vis.energy *= 0.90;
    for (const c of CATS) vis.trig[c] *= 0.86;

    requestAnimationFrame(animLoop);
  }

  // ---------- Recording / Export ----------
  async function toggleRecord(){
    await ensureAudio();
    if (audioCtx.state !== "running") await audioCtx.resume();

    if (!state.record.isRecording){
      // Create stream destination once
      if (!state.record.streamDest){
        state.record.streamDest = audioCtx.createMediaStreamDestination();
        master.connect(state.record.streamDest);
      }
      const rec = new MediaRecorder(state.record.streamDest.stream, {mimeType: "audio/webm"});
      state.record.rec = rec;
      state.record.chunks = [];
      rec.ondataavailable = (e) => { if (e.data && e.data.size) state.record.chunks.push(e.data); };
      rec.onstop = () => {
        const blob = new Blob(state.record.chunks, {type:"audio/webm"});
        downloadBlob(blob, `tcseq_record_${Date.now()}.webm`);
        state.record.chunks = [];
      };
      rec.start();
      state.record.isRecording = true;
      $("btnRecord").textContent = "RECORDING…";
      setStatus("record", "audio/webm");
      toast("Recording started (WEBM). Click RECORD again to stop.");
    } else {
      state.record.isRecording = false;
      $("btnRecord").textContent = "RECORD";
      try{ state.record.rec.stop(); }catch(e){}
      setStatus("record", "stopped");
      toast("Recording saved.");
    }
  }

  function downloadBlob(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 5000);
  }

  function audioBufferToWav(ab, normalize){
    // 16-bit PCM WAV
    const numCh = ab.numberOfChannels;
    const sr = ab.sampleRate;
    const len = ab.length;

    // interleave
    const interleaved = new Float32Array(len * numCh);
    let max = 0;
    for (let ch=0; ch<numCh; ch++){
      const data = ab.getChannelData(ch);
      for (let i=0; i<len; i++){
        const v = data[i];
        max = Math.max(max, Math.abs(v));
        interleaved[i*numCh + ch] = v;
      }
    }
    let gain = 1;
    if (normalize && max > 1e-9) gain = 0.98 / max;

    const bytesPerSample = 2;
    const blockAlign = numCh * bytesPerSample;
    const byteRate = sr * blockAlign;
    const dataSize = len * blockAlign;

    const buf = new ArrayBuffer(44 + dataSize);
    const view = new DataView(buf);

    function writeStr(off, s){
      for (let i=0;i<s.length;i++) view.setUint8(off+i, s.charCodeAt(i));
    }

    writeStr(0, "RIFF");
    view.setUint32(4, 36 + dataSize, true);
    writeStr(8, "WAVE");
    writeStr(12, "fmt ");
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, numCh, true);
    view.setUint32(24, sr, true);
    view.setUint32(28, byteRate, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, 16, true);
    writeStr(36, "data");
    view.setUint32(40, dataSize, true);

    let offset = 44;
    for (let i=0; i<interleaved.length; i++){
      let v = clamp(interleaved[i]*gain, -1, 1);
      view.setInt16(offset, v < 0 ? v*0x8000 : v*0x7FFF, true);
      offset += 2;
    }
    return new Blob([buf], {type:"audio/wav"});
  }

  async function offlineRenderToBuffer(sampleRate, bars){
    // Offline render current pattern (uses decoded buffers only)
    const spb = 60 / state.bpm;
    const stepDur = spb / 4;
    const barDur = stepDur * STEPS;
    const duration = barDur * bars;

    const length = Math.ceil(duration * sampleRate);
    const oac = new OfflineAudioContext(2, length, sampleRate);
    const out = oac.createGain();
    out.gain.value = 0.9;
    out.connect(oac.destination);

    function scheduleBuf(buf, time, vel){
      // mix stereo: use buffer channel count
      const src = oac.createBufferSource();
      src.buffer = buf;
      const g = oac.createGain();
      g.gain.setValueAtTime(0.0001, time);
      g.gain.linearRampToValueAtTime(vel, time + 0.006);
      g.gain.linearRampToValueAtTime(0.0001, time + Math.min(0.18, buf.duration));
      src.connect(g);
      g.connect(out);
      src.start(time);
    }

    // Ensure we have at least one buffer per category, else skip
    const pool = {};
    for (const c of CATS) pool[c] = state.files.filter(f => f.buffer && f.category === c).map(f => f.buffer);
    const any = state.files.filter(f => f.buffer).map(f => f.buffer);

    for (let bar=0; bar<bars; bar++){
      const baseT = bar*barDur;
      for (let step=0; step<STEPS; step++){
        const t = baseT + step*stepDur;
        for (let r=0;r<ROWS;r++){
          const st = state.pattern[r][step];
          if (!st) continue;
          const vel = velocityFromState(st);
          const cat = CATS[r];
          const list = pool[cat];
          const buf = (list && list.length) ? list[Math.floor(Math.random()*list.length)]
                    : (any.length ? any[Math.floor(Math.random()*any.length)] : null);
          if (buf) scheduleBuf(buf, t, vel);
        }
      }
    }

    const rendered = await oac.startRendering();
    return rendered;
  }

  function openExportModal(){
    $("modalBackdrop").style.display = "flex";
  }
  function closeExportModal(){
    $("modalBackdrop").style.display = "none";
  }

  async function exportNow(){
    closeExportModal();
    const fmt = $("exportFormat").value;
    const sr = Number($("exportSR").value);
    const bars = Number($("exportBars").value);
    const norm = $("exportNorm").value === "1";

    if (state.files.filter(f => f.buffer).length === 0){
      toast("Nothing decoded yet. Load files and run ANALYZE+GENERATE first.");
      return;
    }

    if (fmt === "wav"){
      setStatus("export", "offline rendering…");
      const rendered = await offlineRenderToBuffer(sr, bars);
      const blob = audioBufferToWav(rendered, norm);
      downloadBlob(blob, `tcseq_${state.bpm}bpm_${bars}bars_${sr}hz.wav`);
      setStatus("export", "done");
      toast("WAV exported.");
      return;
    }

    if (fmt === "webm"){
      // Real-time export: arm recorder, play for bars, stop.
      await ensureAudio();
      if (audioCtx.state !== "running") await audioCtx.resume();

      if (state.record.isRecording){
        toast("Stop current recording first.");
        return;
      }
      // Start recording
      await toggleRecord();
      // Ensure transport playing
      if (!state.isPlaying) startTransport();

      const spb = 60/state.bpm;
      const barDur = (spb*4);
      const ms = barDur*bars*1000;
      toast(`Recording ${bars} bar(s) …`);
      setTimeout(async () => {
        // stop record (leaves transport running)
        if (state.record.isRecording) await toggleRecord();
        setStatus("export", "webm done");
      }, ms);
      return;
    }

    toast("MP3 export disabled (encoder not included).");
  }

  // ---------- Analyze+Generate button ----------
  async function analyzeAndGenerate(){
    if (state.files.length === 0){
      toast("Load audio files first.");
      return;
    }
    await ensureAudio();
    if (audioCtx.state !== "running") await audioCtx.resume();

    setStatus("analyze", "decoding + classifying…");

    // Decode any missing buffers (cap 200 files as spec)
    const cap = 200;
    if (state.files.length > cap){
      toast(`Loaded ${state.files.length} files; only first ${cap} will be used.`);
    }

    for (let i=0;i<Math.min(state.files.length, cap);i++){
      const f = state.files[i];
      if (!f.buffer){
        try{
          f.buffer = await decodeFile(f.file);
        } catch (e){
          console.warn(e);
          state.debug.lines.push(`[decode fail] ${f.name}: ${String(e)}`);
        }
      }
      if (f.buffer && !f.features){
        f.features = extractFeatures(f.buffer);
        if (!f.override){
          f.autoCategory = classify(f.features);
          f.category = f.autoCategory;
        }
      }
    }

    renderFileList();

    // Generate default pattern tuned to the distribution
    const dist = {};
    for (const c of CATS) dist[c] = 0;
    for (const f of state.files){
      if (f.buffer && f.category) dist[f.category] = (dist[f.category]||0)+1;
    }

    // Choose style from UI, but bias density by number of hats/percs
    const style = $("styleMode").value;
    const density = Number($("density").value);
    const seed = (Date.now() ^ 0x9E3779B9) >>> 0;
    const rng = mulberry32(seed);

    generateBase(style, rng);

    // push a little more hats/percs if they exist
    const hatBoost = clamp(dist["HAT"]/Math.max(1,state.files.length), 0, 1);
    const dens2 = clamp(Math.round(density + hatBoost*18), 0, 100);
    applyDensity(dens2, rng, style);

    renderGrid();
    updateVisualDistribution();

    setStatus("ready", `classified ${state.files.filter(f=>f.buffer).length} file(s)`);
    toast("Analyze+Generate complete. Click filenames to preview; click class labels to correct.");
  }

  // ---------- Load/Clear ----------
  async function loadFiles(){
    const preferFSA = ("showOpenFilePicker" in window);
    let files = [];
    try{
      if (preferFSA){
        const handles = await window.showOpenFilePicker({
          multiple: true,
          types: [{ description: "Audio", accept: { "audio/*": [".wav",".mp3",".aif",".aiff",".ogg",".m4a",".flac"] } }]
        });
        for (const h of handles){
          const file = await h.getFile();
          files.push(file);
        }
      } else {
        $("fileInput").click();
        return;
      }
    } catch (e){
      // user cancelled
      return;
    }

    addFiles(files);
  }

  function addFiles(files){
    if (!files || !files.length) return;
    const current = state.files.length;
    const cap = 200;
    const room = cap - current;
    const take = files.slice(0, Math.max(0, room));

    if (take.length < files.length){
      toast(`File cap is ${cap}. Extra files were ignored.`);
    }

    for (const file of take){
      state.files.push({
        id: cryptoRandomId(),
        name: file.name,
        file,
        buffer: null,
        features: null,
        autoCategory: null,
        category: null,
        override: false
      });
    }
    if (state.selectedFileIndex < 0 && state.files.length) state.selectedFileIndex = 0;
    renderFileList();
    setStatus("loaded", `${state.files.length} file(s)`);
  }

  function clearAll(){
    stopTransport();
    state.files = [];
    state.selectedFileIndex = -1;
    resetPattern();
    renderFileList();
    setStatus("cleared", "");
  }

  function cryptoRandomId(){
    if (crypto && crypto.getRandomValues){
      const a = new Uint32Array(2);
      crypto.getRandomValues(a);
      return (a[0].toString(16)+a[1].toString(16));
    }
    return String(Math.random()).slice(2);
  }

  // ---------- Debug ----------
  function toggleDebug(){
    state.debug.on = !state.debug.on;
    if (state.debug.on){
      toast("Debug ON. Open console for logs.");
      console.log("[TCSEQ debug] state:", state);
    } else {
      toast("Debug OFF.");
    }
  }

  // ---------- Help ----------
  function showHelp(){
    toast("Workflow: LOAD FILES → ANALYZE+GENERATE → RANDOM PATTERN (optional) → PLAY. Click filename to preview; click class to correct. EXPORT renders audio.");
  }

  // ---------- Wiring ----------
  $("btnLoad").addEventListener("click", loadFiles);
  $("fileInput").addEventListener("change", (e) => {
    addFiles(Array.from(e.target.files || []));
    e.target.value = "";
  });
  $("btnClear").addEventListener("click", clearAll);

  $("btnAnalyzeGenerate").addEventListener("click", analyzeAndGenerate);

  $("btnPlay").addEventListener("click", async () => {
    await ensureAudio();
    if (audioCtx.state !== "running") await audioCtx.resume();
    if (!state.isPlaying) startTransport();
  });

  $("btnStop").addEventListener("click", () => stopTransport());
  $("btnRecord").addEventListener("click", toggleRecord);
  $("btnExport").addEventListener("click", openExportModal);
  $("btnHidePanel").addEventListener("click", () => {
    $("app").classList.toggle("hidden-left");
  });
  $("btnDebug").addEventListener("click", toggleDebug);
  $("btnHelp").addEventListener("click", showHelp);

  $("btnRandom").addEventListener("click", () => {
    // Fix: randomize does not touch running nodes; safe during playback (no click)
    randomizePattern();
  });
  $("btnResetGrid").addEventListener("click", resetPattern);

  $("viewMode").addEventListener("change", (e) => {
    state.viewMode = e.target.value;
    setPlayingColumn(-1);
  });

  // ---------- BPM control ----------
  refreshTransport();
  const _bpmBar = $("bpmBar");
  const _bpmVal = $("bpmVal");
  if (_bpmBar){
    _bpmBar.value = String(state.bpm);
    if (_bpmVal) _bpmVal.textContent = String(Math.round(state.bpm));
    _bpmBar.addEventListener("input", (e) => {
      const v = clamp(Number(e.target.value) || state.bpm, 60, 220);
      state.bpm = v;
      if (_bpmVal) _bpmVal.textContent = String(Math.round(v));
      refreshTransport();
      // Resync next scheduling tick for immediate tempo response
      if (state.isPlaying && audioCtx){
        state.nextNoteTime = audioCtx.currentTime + 0.05;
      }
    });
  }

  $("modalBackdrop").addEventListener("click", (e) => {
    if (e.target === $("modalBackdrop")) closeExportModal();
  });
  $("btnExportCancel").addEventListener("click", closeExportModal);
  $("btnExportGo").addEventListener("click", exportNow);

  // Keyboard in file list
  fileListEl.addEventListener("keydown", async (e) => {
    if (state.files.length === 0) return;

    const max = state.files.length - 1;
    if (e.key === "ArrowDown"){
      e.preventDefault();
      state.selectedFileIndex = clamp(state.selectedFileIndex + 1, 0, max);
      renderFileList();
      scrollSelectedIntoView();
    }
    if (e.key === "ArrowUp"){
      e.preventDefault();
      state.selectedFileIndex = clamp(state.selectedFileIndex - 1, 0, max);
      renderFileList();
      scrollSelectedIntoView();
    }
    if (e.key === "Enter"){
      e.preventDefault();
      await previewFile(state.selectedFileIndex);
    }
    // 1-6 sets category quickly
    if (/^[1-6]$/.test(e.key)){
      const idx = Number(e.key) - 1;
      const cat = CATS[idx];
      const f = state.files[state.selectedFileIndex];
      if (f){
        f.category = cat;
        f.override = true;
        renderFileList();
        updateVisualDistribution();
        toast(`Set class: ${cat}`);
      }
    }
  });

  function scrollSelectedIntoView(){
    const sel = fileListEl.querySelector(".fileitem.selected");
    if (sel) sel.scrollIntoView({block:"nearest"});
  }

  // Startup render
  renderHeader();
  renderGrid();
  renderFileList();
  updateVisualDistribution();
  setStatus("ready", "load up to 200 files");

  requestAnimationFrame(animLoop);
})();
</script>
</body>
</html>
